{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/Prototypes/OldInputSystem/src/app/constraints.ts"],
  "sourcesContent": ["import { minimize } from '../lib/g9';\nimport { Position } from '../lib/types';\nimport { generateId, removeOne } from '../lib/helpers';\nimport Vec from '../lib/vec';\nimport Handle from './strokes/Handle';\nimport SVG from './Svg';\n\ntype VariableInfo = CanonicalVariableInfo | AbsorbedVariableInfo;\n\ninterface CanonicalVariableInfo {\n  isCanonical: true;\n  absorbedVariables: Set<Variable>;\n}\n\ninterface AbsorbedVariableInfo {\n  isCanonical: false;\n  canonicalInstance: Variable;\n  // canonicalInstance.value === absorbedVariable.value + valueOffset\n  valueOffset: number;\n}\n\nexport class Variable {\n  static readonly all = new Set<Variable>();\n\n  readonly id = generateId();\n  info: VariableInfo = {\n    isCanonical: true,\n    absorbedVariables: new Set(),\n  };\n  wasRemoved = false;\n\n  constructor(private _value: number = 0) {\n    Variable.all.add(this);\n  }\n\n  /** Removes this variable and any constraint that reference it. */\n  remove() {\n    if (this.wasRemoved) {\n      return;\n    }\n\n    Variable.all.delete(this);\n    this.wasRemoved = true;\n    for (const constraint of Constraint.all) {\n      if (constraint.variables.includes(this)) {\n        constraint.remove();\n      }\n    }\n  }\n\n  get canonicalInstance(): Variable {\n    return this.info.isCanonical ? this : this.info.canonicalInstance;\n  }\n\n  get valueOffset() {\n    return this.info.isCanonical ? 0 : this.info.valueOffset;\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  set value(newValue: number) {\n    if (this.info.isCanonical) {\n      this._value = newValue;\n      for (const child of this.info.absorbedVariables) {\n        const valueOffset = (child.info as AbsorbedVariableInfo).valueOffset;\n        child._value = newValue - valueOffset;\n      }\n    } else {\n      this.info.canonicalInstance.value = newValue + this.info.valueOffset;\n    }\n  }\n\n  absorb(that: Variable, valueOffset = 0) {\n    if (this === that) {\n      return;\n    } else if (!this.info.isCanonical || !that.info.isCanonical) {\n      this.canonicalInstance.absorb(that.canonicalInstance, valueOffset);\n      return;\n    }\n\n    // console.log(this.id, 'absorbing', that.id);\n    for (const otherVariable of that.info.absorbedVariables) {\n      // console.log(this.id, 'absorbing', otherVariable.id);\n      otherVariable.value = this.value;\n      const otherVariableInfo = otherVariable.info as AbsorbedVariableInfo;\n      otherVariableInfo.canonicalInstance = this;\n      otherVariableInfo.valueOffset += valueOffset;\n      this.info.absorbedVariables.add(otherVariable);\n    }\n\n    that.value = this.value;\n    that.info = {\n      isCanonical: false,\n      canonicalInstance: this,\n      valueOffset: valueOffset,\n    };\n    this.info.absorbedVariables.add(that);\n  }\n\n  resetInfo() {\n    if (this.info.isCanonical) {\n      this.info.absorbedVariables.clear();\n    } else {\n      this.info = {\n        isCanonical: true,\n        absorbedVariables: new Set(),\n      };\n    }\n  }\n}\n\n// #region constraint and thing clusters for solver\n\n// A group of constraints (and things that they operate on) that should be solved together.\ninterface ClusterForSolver {\n  constraints: Constraint[];\n  variables: Variable[];\n  handles: Handle[];\n  handleGetsXFrom: Map<Handle, Variable>;\n  handleGetsYFrom: Map<Handle, Variable>;\n  constrainedState: StateSet;\n}\n\nlet _clustersForSolver: Set<ClusterForSolver> | null = null;\n\nfunction getClustersForSolver(): Set<ClusterForSolver> {\n  if (_clustersForSolver) {\n    return _clustersForSolver;\n  }\n\n  for (const variable of Variable.all) {\n    variable.resetInfo();\n  }\n\n  interface Cluster {\n    constraints: Constraint[];\n    manipulationSet: ManipulationSet;\n  }\n\n  const clusters = new Set<Cluster>();\n  for (const constraint of Constraint.all) {\n    const constraints = [constraint];\n    const manipulationSet = constraint.getManipulationSet();\n    for (const cluster of clusters) {\n      if (cluster.manipulationSet.overlapsWith(manipulationSet)) {\n        constraints.push(...cluster.constraints);\n        manipulationSet.absorb(cluster.manipulationSet);\n        clusters.delete(cluster);\n      }\n    }\n    clusters.add({ constraints, manipulationSet });\n  }\n\n  _clustersForSolver = new Set(\n    Array.from(clusters).map(cluster => {\n      const origConstraints = cluster.constraints;\n      const { constraints, variables, handleGetsXFrom, handleGetsYFrom } =\n        getDedupedConstraintsAndVariables(origConstraints);\n\n      const constrainedState = new StateSet();\n      // TODO: do we really need to look at origConstraints when computing the constrained state?\n      // I'm doing this because some constraints are removed in deduping, but it's possible that\n      // there's enough info in the deduped constraints. On the other hand, also looking at\n      // origConstraints doesn't hurt so I'm leaving it here for now. (Think about this later.)\n      for (const constraint of [...origConstraints, ...constraints]) {\n        constraint.addConstrainedState(constrainedState);\n      }\n\n      return {\n        constraints,\n        variables,\n        handles: getHandlesIn(constraints),\n        handleGetsXFrom,\n        handleGetsYFrom,\n        constrainedState,\n      };\n    })\n  );\n\n  // for debugging\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (window as any).clusters = _clustersForSolver;\n\n  // console.log('clusters', _clustersForSolver);\n  SVG.showStatus(`${clusters.size} clusters`);\n\n  return _clustersForSolver;\n}\n\n// TODO: this function works, but it's gross. Refactor.\nfunction getDedupedConstraintsAndVariables(constraints: Constraint[]) {\n  // console.log('orig constraints', constraints);\n  let result: Omit<ClusterForSolver, 'handles' | 'constrainedState'> | null =\n    null;\n  while (true) {\n    const oldNumConstraints = result\n      ? result.constraints.length\n      : constraints.length;\n    const handleGetsXFrom = result\n      ? result.handleGetsXFrom\n      : new Map<Handle, Variable>();\n    const handleGetsYFrom = result\n      ? result.handleGetsYFrom\n      : new Map<Handle, Variable>();\n    result = dedupVariables(dedupConstraints(constraints));\n    for (const [handle, variable] of handleGetsXFrom) {\n      if (!result.handleGetsXFrom.has(handle)) {\n        result.handleGetsXFrom.set(handle, variable);\n      }\n    }\n    for (const [handle, variable] of handleGetsYFrom) {\n      if (!result.handleGetsYFrom.has(handle)) {\n        result.handleGetsYFrom.set(handle, variable);\n      }\n    }\n    // console.log('new len', result.constraints.length, 'old', oldNumConstraints);\n    if (result.constraints.length === oldNumConstraints) {\n      return result;\n    }\n  }\n}\n\nfunction dedupConstraints(constraints: Constraint[]): Constraint[] {\n  const constraintByKey = new Map<string, Constraint>();\n  const constraintsToProcess = new Set(constraints);\n  while (true) {\n    const constraint = removeOne(constraintsToProcess);\n    if (!constraint) {\n      break;\n    }\n\n    const key = constraint.getKeyWithDedupedHandlesAndVars();\n    const matchingConstraint = constraintByKey.get(key);\n    if (matchingConstraint) {\n      captureNewConstraints(constraintsToProcess, () =>\n        matchingConstraint.onClash(constraint)\n      );\n    } else {\n      constraintByKey.set(key, constraint);\n    }\n  }\n  return Array.from(constraintByKey.values());\n}\n\nfunction dedupVariables(constraints: Constraint[]) {\n  // Dedup variables based on Equals\n  let idx = 0;\n  while (idx < constraints.length) {\n    const constraint = constraints[idx];\n    if (!(constraint instanceof Equals)) {\n      idx++;\n      continue;\n    }\n\n    const { a, b } = constraint;\n    a.absorb(b);\n    constraints.splice(idx, 1);\n  }\n\n  // When properties are used, unify the state from the handle\n  // with that of the variable that is associated with it.\n  const handleGetsXFrom = new Map<Handle, Variable>();\n  const handleGetsYFrom = new Map<Handle, Variable>();\n  for (const c of constraints) {\n    if (c instanceof Property) {\n      (c.property === 'x' ? handleGetsXFrom : handleGetsYFrom).set(\n        c.handle.canonicalInstance,\n        c.variable.canonicalInstance\n      );\n    }\n  }\n\n  // Here's another kind of deduping that we can do for variables: when\n  // we have Sum(a, b, c) and Constant(c), variable a can absorb b w/\n  // an \"offset\" of c. (There's a lot more that we could do here, this\n  // is just an initial experiment.)\n  // TODO: handle all possible cases.\n  idx = 0;\n  while (idx < constraints.length) {\n    const constraint = constraints[idx];\n    if (!(constraint instanceof Sum)) {\n      idx++;\n      continue;\n    }\n\n    const { a, b, c: k } = constraint;\n    const constant = constraints.find(\n      c =>\n        c instanceof Constant &&\n        c.variable.canonicalInstance === k.canonicalInstance\n    ) as Constant;\n    a.absorb(b, constant.value);\n    constraints.splice(idx, 1);\n  }\n\n  // Gather all deduped variables.\n  const variables = new Set<Variable>();\n  for (const constraint of constraints) {\n    for (const variable of constraint.variables) {\n      variables.add(variable.canonicalInstance);\n    }\n  }\n\n  return {\n    variables: Array.from(variables),\n    constraints,\n    handleGetsXFrom,\n    handleGetsYFrom,\n  };\n}\n\nfunction getHandlesIn(constraints: Constraint[]) {\n  const handles = new Set<Handle>();\n  for (const constraint of constraints) {\n    for (const handle of constraint.handles) {\n      handles.add(handle.canonicalInstance);\n    }\n  }\n  return Array.from(handles);\n}\n\nfunction forgetClustersForSolver() {\n  _clustersForSolver = null;\n}\n\nexport function onHandlesReconfigured() {\n  forgetClustersForSolver();\n}\n\n// #endregion constraint and thing clusters for solver\n\n/**\n * Calls `fn`, and if that results in the creation of new constraints,\n * they will be added to `dest`, in addition to `Constraint.all`.\n */\nfunction captureNewConstraints<T>(dest: Set<Constraint>, fn: () => T): T {\n  newConstraintAccumulator = dest;\n  try {\n    return fn();\n  } finally {\n    newConstraintAccumulator = undefined;\n  }\n}\n\n// #region solving\n\nclass StateSet {\n  private readonly xs = new Set<Handle>();\n  private readonly ys = new Set<Handle>();\n  private readonly vars = new Set<Variable>();\n\n  hasX(handle: Handle): boolean {\n    return this.xs.has(handle.canonicalInstance);\n  }\n\n  hasY(handle: Handle): boolean {\n    return this.ys.has(handle.canonicalInstance);\n  }\n\n  hasVar(variable: Variable): boolean {\n    return this.vars.has(variable.canonicalInstance);\n  }\n\n  addX(handle: Handle) {\n    this.xs.add(handle.canonicalInstance);\n  }\n\n  addY(handle: Handle) {\n    this.ys.add(handle.canonicalInstance);\n  }\n\n  addVar(variable: Variable) {\n    this.vars.add(variable.canonicalInstance);\n  }\n\n  toJSON() {\n    return {\n      vars: Array.from(this.vars).map(v => ({ id: v.id, value: v.value })),\n      xs: Array.from(this.xs).map(h => ({ id: h.id, x: h.position.x })),\n      ys: Array.from(this.ys).map(h => ({ id: h.id, y: h.position.y })),\n    };\n  }\n}\n\nexport function solve() {\n  const clusters = getClustersForSolver();\n  for (const cluster of clusters) {\n    solveCluster(cluster);\n  }\n}\n\nfunction solveCluster({\n  constraints,\n  variables,\n  handles,\n  handleGetsXFrom,\n  handleGetsYFrom,\n  constrainedState,\n}: ClusterForSolver) {\n  if (constraints.length === 0) {\n    // nothing to solve!\n    return;\n  }\n\n  const knownState = computeKnownState(constraints);\n\n  // The state that goes into `inputs` is the stuff that can be modified by the solver.\n  // It excludes any value that we've already computed from known values like pin and\n  // constant constraints.\n  const inputs: number[] = [];\n  const inputDescriptions: string[] = [];\n  const varIdx = new Map<Variable, number>();\n  for (const variable of variables) {\n    if (!knownState.hasVar(variable) && constrainedState.hasVar(variable)) {\n      varIdx.set(variable, inputs.length);\n      inputs.push(variable.value);\n      inputDescriptions.push(`var ${variable.id}`);\n    }\n  }\n  const xIdx = new Map<Handle, number>();\n  const yIdx = new Map<Handle, number>();\n  for (const handle of handles) {\n    if (knownState.hasX(handle) || !constrainedState.hasX(handle)) {\n      // no op\n    } else if (handleGetsXFrom.has(handle)) {\n      xIdx.set(handle, varIdx.get(handleGetsXFrom.get(handle)!)!);\n    } else {\n      xIdx.set(handle, inputs.length);\n      inputs.push(handle.position.x);\n      inputDescriptions.push(`x ${handle.id}`);\n    }\n\n    if (knownState.hasY(handle) || !constrainedState.hasY(handle)) {\n      // no op\n    } else if (handleGetsYFrom.has(handle)) {\n      yIdx.set(handle, varIdx.get(handleGetsYFrom.get(handle)!)!);\n    } else {\n      yIdx.set(handle, inputs.length);\n      inputs.push(handle.position.y);\n      inputDescriptions.push(`y ${handle.id}`);\n    }\n  }\n\n  // This is where we actually run the solver.\n\n  function computeTotalError(currState: number[]) {\n    let error = 0;\n    for (const constraint of constraints) {\n      if (constraint instanceof Constant || constraint instanceof Pin) {\n        // Ignore -- these guys already did their job in propagateKnownState().\n        continue;\n      }\n      const positions = constraint.handles.map(handle => {\n        handle = handle.canonicalInstance;\n        const xi = xIdx.get(handle);\n        const yi = yIdx.get(handle);\n        if (xi === undefined && yi === undefined) {\n          return handle.position;\n        } else {\n          return {\n            x: xi === undefined ? handle.position.x : currState[xi],\n            y: yi === undefined ? handle.position.y : currState[yi],\n          };\n        }\n      });\n      const values = constraint.variables.map(variable => {\n        const valueOffset = variable.valueOffset;\n        variable = variable.canonicalInstance;\n        const vi = varIdx.get(variable);\n        return (\n          (vi === undefined ? variable.value : currState[vi]) - valueOffset\n        );\n      });\n      error += Math.pow(\n        constraint.getError(positions, values, knownState, constrainedState),\n        2\n      );\n    }\n    return error;\n  }\n\n  let result: ReturnType<typeof minimize>;\n  try {\n    result = minimize(computeTotalError, inputs);\n  } catch (e) {\n    console.log(\n      'minimizeError threw',\n      e,\n      'while working on cluster with',\n      constraints,\n      variables,\n      handles,\n      'with inputs',\n      inputs.map((input, idx) => ({ input, is: inputDescriptions[idx] })),\n      'known state',\n      knownState.toJSON(),\n      'and constrained state',\n      constrainedState.toJSON()\n    );\n    SVG.showStatus('' + e);\n    throw e;\n  }\n\n  // SVG.showStatus(`${result.iterations} iterations`);\n\n  // Now we write the solution from the solver back into our variables and handles.\n  const outputs = result.solution;\n  for (const variable of variables) {\n    if (!knownState.hasVar(variable) && constrainedState.hasVar(variable)) {\n      variable.value = outputs.shift()!;\n    }\n  }\n  for (const handle of handles) {\n    const x =\n      knownState.hasX(handle) || !constrainedState.hasX(handle)\n        ? handle.position.x\n        : handleGetsXFrom.has(handle)\n        ? handleGetsXFrom.get(handle)!.value\n        : outputs.shift()!;\n    const y =\n      knownState.hasY(handle) || !constrainedState.hasY(handle)\n        ? handle.position.y\n        : handleGetsYFrom.has(handle)\n        ? handleGetsYFrom.get(handle)!.value\n        : outputs.shift()!;\n    handle.position = { x, y };\n  }\n}\n\nfunction computeKnownState(constraints: Constraint[]) {\n  const knownState = new StateSet();\n  while (true) {\n    let didSomething = false;\n    for (const constraint of constraints) {\n      if (constraint.propagateKnownState(knownState)) {\n        didSomething = true;\n      }\n    }\n    if (!didSomething) {\n      break;\n    }\n  }\n  return knownState;\n}\n\n// #endregion solving\n\n// #region adding constraints\n\nclass ConstraintKeyGenerator {\n  public readonly key: string;\n\n  constructor(\n    private readonly type: string,\n    private readonly handleGroups: Handle[][],\n    private readonly variableGroups: Variable[][]\n  ) {\n    this.key = this.generateKey();\n  }\n\n  getKeyWithDedupedHandlesAndVars() {\n    return this.generateKey(true);\n  }\n\n  private generateKey(dedupHandlesAndVars = false) {\n    const handleIdGroups = this.handleGroups\n      .map(handleGroup =>\n        handleGroup\n          .map(handle => (dedupHandlesAndVars ? handle.id : handle.ownId))\n          .sort()\n          .join(',')\n      )\n      .map(handleIdGroup => `[${handleIdGroup}]`);\n    const variableIdGroups = this.variableGroups\n      .map(variableGroup =>\n        variableGroup\n          .map(variable =>\n            dedupHandlesAndVars ? variable.canonicalInstance.id : variable.id\n          )\n          .sort()\n          .join(',')\n      )\n      .map(variableIdGroup => `[${variableIdGroup}]`);\n    return `${this.type}([${handleIdGroups}],[${variableIdGroups}])`;\n  }\n}\n\nexport type OwnedVariables<OwnedVariableNames extends string> = {\n  [Key in OwnedVariableNames]: Variable;\n};\n\nexport interface AddConstraintResult<OwnedVariableNames extends string> {\n  constraints: Constraint[];\n  variables: OwnedVariables<OwnedVariableNames>;\n  remove(): void;\n}\n\nfunction addConstraint<\n  OwnedVariableNames extends string,\n  C extends Constraint<OwnedVariableNames>,\n>(\n  keyGenerator: ConstraintKeyGenerator,\n  createNew: (keyGenerator: ConstraintKeyGenerator) => C,\n  onClash: (existingConstraint: C) => AddConstraintResult<OwnedVariableNames>\n): AddConstraintResult<OwnedVariableNames> {\n  const constraint = Constraint.find(\n    constraint => constraint.key === keyGenerator.key\n  ) as C | undefined;\n  return constraint\n    ? onClash(constraint)\n    : createNew(keyGenerator).toAddConstraintResult();\n}\n\n// #endregion adding constraints\n\nclass ManipulationSet {\n  readonly xs: Set<Handle>;\n  readonly ys: Set<Handle>;\n  readonly vars: Set<Variable>;\n\n  constructor({\n    xs,\n    ys,\n    vars,\n  }: {\n    xs: Handle[];\n    ys: Handle[];\n    vars: Variable[];\n  }) {\n    this.xs = new Set(xs.map(handle => handle.canonicalInstance));\n    this.ys = new Set(ys.map(handle => handle.canonicalInstance));\n    this.vars = new Set(vars.map(variable => variable.canonicalInstance));\n  }\n\n  overlapsWith(that: ManipulationSet) {\n    for (const h of that.xs) {\n      if (this.xs.has(h)) {\n        return true;\n      }\n    }\n    for (const h of that.ys) {\n      if (this.ys.has(h)) {\n        return true;\n      }\n    }\n    for (const v of that.vars) {\n      if (this.vars.has(v)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  absorb(that: ManipulationSet) {\n    for (const h of that.xs) {\n      this.xs.add(h);\n    }\n    for (const h of that.ys) {\n      this.ys.add(h);\n    }\n    for (const v of that.vars) {\n      this.vars.add(v);\n    }\n  }\n}\n\nlet newConstraintAccumulator: Set<Constraint> | undefined;\n\nabstract class Constraint<OwnedVariableNames extends string = never> {\n  static readonly all = new Set<Constraint>();\n\n  static find(\n    pred: (constraint: Constraint) => boolean\n  ): Constraint | undefined {\n    for (const constraint of Constraint.all) {\n      if (pred(constraint)) {\n        return constraint;\n      }\n    }\n    return undefined;\n  }\n\n  wasRemoved = false;\n\n  constructor(\n    public readonly handles: Handle[],\n    public readonly variables: Variable[],\n    private readonly keyGenerator: ConstraintKeyGenerator\n  ) {\n    Constraint.all.add(this);\n    newConstraintAccumulator?.add(this);\n    forgetClustersForSolver();\n  }\n\n  abstract get ownedVariables(): {\n    [Key in OwnedVariableNames]: Variable;\n  };\n\n  /** Removes this constraint, any variables that it owns, and any constraint that references one of those variables. */\n  remove() {\n    if (this.wasRemoved) {\n      return;\n    }\n\n    // Remove me.\n    if (Constraint.all.delete(this)) {\n      forgetClustersForSolver();\n    }\n    this.wasRemoved = true;\n\n    // Remove the variables that I own and any constraint that references them.\n    for (const variable of Object.values(this.ownedVariables)) {\n      (variable as Variable).remove();\n    }\n  }\n\n  get key() {\n    return this.keyGenerator.key;\n  }\n\n  getKeyWithDedupedHandlesAndVars() {\n    return this.keyGenerator.getKeyWithDedupedHandlesAndVars();\n  }\n\n  abstract addConstrainedState(constrainedState: StateSet): void;\n\n  /**\n   * If this constraint can determine the values of any xs, ys, or variables\n   * based on other state that is already known, it should set the values\n   * of those things, add them to the known state set, and return `true`.\n   * Otherwise, it should return `false`.\n   */\n  propagateKnownState(_knownState: StateSet): boolean {\n    return false;\n  }\n\n  /**\n   * Returns the current error for this constraint. (OK if it's negative.)\n   * If this constraint owns a variable whose state is not constrained,\n   * ignore the corresponding value in `variableValues` and instead set\n   * the value of that variable to make the error equal to zero.\n   */\n  abstract getError(\n    handlePositions: Position[],\n    variableValues: number[],\n    knownState: StateSet,\n    constrainedState: StateSet\n  ): number;\n\n  abstract onClash(constraint: this): AddConstraintResult<OwnedVariableNames>;\n\n  toAddConstraintResult(): AddConstraintResult<OwnedVariableNames> {\n    return {\n      constraints: [this],\n      variables: this.ownedVariables,\n      remove: () => this.remove(),\n    };\n  }\n\n  getManipulationSet(): ManipulationSet {\n    return new ManipulationSet({\n      xs: this.handles,\n      ys: this.handles,\n      vars: this.variables,\n    });\n  }\n}\n\nexport function variable(value = 0): Variable {\n  return new Variable(value);\n}\n\nexport function constant(\n  variable: Variable,\n  value: number = variable.value\n): AddConstraintResult<never> {\n  return addConstraint(\n    new ConstraintKeyGenerator('constant', [], [[variable]]),\n    keyGenerator => new Constant(variable, value, keyGenerator),\n    existingConstraint => existingConstraint.onClash(value)\n  );\n}\n\nclass Constant extends Constraint {\n  constructor(\n    public readonly variable: Variable,\n    public value: number,\n    keyGenerator: ConstraintKeyGenerator\n  ) {\n    super([], [variable], keyGenerator);\n  }\n\n  readonly ownedVariables = {};\n\n  addConstrainedState(constrainedState: StateSet): void {\n    constrainedState.addVar(this.variable);\n  }\n\n  propagateKnownState(knownState: StateSet): boolean {\n    if (!knownState.hasVar(this.variable)) {\n      this.variable.value = this.value;\n      knownState.addVar(this.variable);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  getError(_positions: Position[], _values: number[]): number {\n    throw new Error('Constant.getError() should never be called!');\n  }\n\n  onClash(constraint: this): AddConstraintResult<never>;\n  onClash(value: number): AddConstraintResult<never>;\n  onClash(constraintOrValue: this | number): AddConstraintResult<never> {\n    this.value =\n      constraintOrValue instanceof Constant\n        ? constraintOrValue.value\n        : constraintOrValue;\n    return this.toAddConstraintResult();\n  }\n}\n\nexport function equals(a: Variable, b: Variable): AddConstraintResult<never> {\n  return addConstraint(\n    new ConstraintKeyGenerator('equals', [], [[a, b]]),\n    keyGenerator => new Equals(a, b, keyGenerator),\n    existingConstraint => existingConstraint.onClash()\n  );\n}\n\nclass Equals extends Constraint<never> {\n  constructor(\n    readonly a: Variable,\n    readonly b: Variable,\n    keyGenerator: ConstraintKeyGenerator\n  ) {\n    super([], [a, b], keyGenerator);\n  }\n\n  readonly ownedVariables = {};\n\n  addConstrainedState(constrainedState: StateSet): void {\n    constrainedState.addVar(this.a);\n    constrainedState.addVar(this.b);\n  }\n\n  propagateKnownState(knownState: StateSet): boolean {\n    if (!knownState.hasVar(this.a) && knownState.hasVar(this.b)) {\n      this.a.value = this.b.value;\n      knownState.addVar(this.a);\n      return true;\n    } else if (knownState.hasVar(this.a) && !knownState.hasVar(this.b)) {\n      this.b.value = this.a.value;\n      knownState.addVar(this.b);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  getError(_positions: Position[], values: number[]) {\n    const [aValue, bValue] = values;\n    return aValue - bValue;\n  }\n\n  onClash(): AddConstraintResult<never> {\n    return this.toAddConstraintResult();\n  }\n}\n\n/** a = b + c */\nexport function sum(\n  a: Variable,\n  b: Variable,\n  c: Variable\n): AddConstraintResult<never> {\n  return addConstraint(\n    new ConstraintKeyGenerator('sum', [], [[a], [b, c]]),\n    keyGenerator => new Sum(a, b, c, keyGenerator),\n    existingConstraint => existingConstraint.onClash(a, b, c)\n  );\n}\n\nclass Sum extends Constraint<never> {\n  constructor(\n    readonly a: Variable,\n    readonly b: Variable,\n    readonly c: Variable,\n    keyGenerator: ConstraintKeyGenerator\n  ) {\n    super([], [a, b, c], keyGenerator);\n  }\n\n  readonly ownedVariables = {};\n\n  addConstrainedState(constrainedState: StateSet): void {\n    constrainedState.addVar(this.a);\n    constrainedState.addVar(this.b);\n    constrainedState.addVar(this.c);\n  }\n\n  propagateKnownState(knownState: StateSet): boolean {\n    if (\n      !knownState.hasVar(this.a) &&\n      knownState.hasVar(this.b) &&\n      knownState.hasVar(this.c)\n    ) {\n      this.a.value = this.b.value + this.c.value;\n      knownState.addVar(this.a);\n      return true;\n    } else if (\n      knownState.hasVar(this.a) &&\n      !knownState.hasVar(this.b) &&\n      knownState.hasVar(this.c)\n    ) {\n      this.b.value = this.a.value - this.c.value;\n      knownState.addVar(this.b);\n      return true;\n    } else if (\n      knownState.hasVar(this.a) &&\n      knownState.hasVar(this.b) &&\n      !knownState.hasVar(this.c)\n    ) {\n      this.c.value = this.a.value - this.b.value;\n      knownState.addVar(this.c);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  getError(_positions: Position[], [aValue, bValue, cValue]: number[]) {\n    return aValue - (bValue + cValue);\n  }\n\n  onClash(a: Variable, b: Variable, c: Variable): AddConstraintResult<never>;\n  onClash(newerConstraint: this): AddConstraintResult<never>;\n  onClash(\n    _newerConstraintOrA: this | Variable,\n    _b?: Variable,\n    _c?: Variable\n  ): AddConstraintResult<never> {\n    // TODO: implement this\n    throw new Error('TODO');\n  }\n}\n\nexport function pin(\n  handle: Handle,\n  pos: Position = handle.position\n): AddConstraintResult<never> {\n  return addConstraint(\n    new ConstraintKeyGenerator('pin', [[handle]], []),\n    keyGenerator => new Pin(handle, pos, keyGenerator),\n    existingConstraint => existingConstraint.onClash(pos)\n  );\n}\n\nclass Pin extends Constraint<never> {\n  constructor(\n    private readonly handle: Handle,\n    public position: Position,\n    keyGenerator: ConstraintKeyGenerator\n  ) {\n    super([handle], [], keyGenerator);\n  }\n\n  readonly ownedVariables = {};\n\n  addConstrainedState(constrainedState: StateSet): void {\n    constrainedState.addX(this.handle);\n    constrainedState.addY(this.handle);\n  }\n\n  propagateKnownState(knownState: StateSet): boolean {\n    if (!knownState.hasX(this.handle) || !knownState.hasY(this.handle)) {\n      this.handle.position = this.position;\n      knownState.addX(this.handle);\n      knownState.addY(this.handle);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  getError(_positions: Position[], _values: number[]): number {\n    throw new Error('Pin.getError() should never be called!');\n  }\n\n  onClash(constraint: this): AddConstraintResult<never>;\n  onClash(position: Position): AddConstraintResult<never>;\n  onClash(constraintOrPosition: this | Position): AddConstraintResult<never> {\n    this.position =\n      constraintOrPosition instanceof Pin\n        ? constraintOrPosition.position\n        : constraintOrPosition;\n    return this.toAddConstraintResult();\n  }\n}\n\nexport function horizontal(a: Handle, b: Handle): AddConstraintResult<never> {\n  const ay = property(a, 'y').variables.variable;\n  const by = property(b, 'y').variables.variable;\n  return equals(ay, by);\n}\n\nexport function vertical(a: Handle, b: Handle): AddConstraintResult<never> {\n  const ax = property(a, 'x').variables.variable;\n  const bx = property(b, 'x').variables.variable;\n  return equals(ax, bx);\n}\n\nexport function distance(\n  a: Handle,\n  b: Handle\n): AddConstraintResult<'distance'> {\n  return addConstraint(\n    new ConstraintKeyGenerator('distance', [[a, b]], []),\n    keyGenerator => new Distance(a, b, keyGenerator),\n    existingConstraint => existingConstraint.onClash()\n  );\n}\n\nexport function equalDistance(\n  a1: Handle,\n  a2: Handle,\n  b1: Handle,\n  b2: Handle\n): AddConstraintResult<never> {\n  const { distance: distanceA } = distance(a1, a2).variables;\n  const { distance: distanceB } = distance(b1, b2).variables;\n  return equals(distanceA, distanceB);\n}\n\nclass Distance extends Constraint<'distance'> {\n  constructor(\n    public readonly a: Handle,\n    public readonly b: Handle,\n    keyGenerator: ConstraintKeyGenerator\n  ) {\n    super(\n      [a, b],\n      [new Variable(Vec.dist(a.position, b.position))],\n      keyGenerator\n    );\n  }\n\n  readonly ownedVariables = { distance: this.distance };\n\n  get distance() {\n    return this.variables[0];\n  }\n\n  addConstrainedState(constrainedState: StateSet): void {\n    constrainedState.addX(this.a);\n    constrainedState.addY(this.a);\n    constrainedState.addX(this.b);\n    constrainedState.addY(this.b);\n  }\n\n  getError(\n    [aPos, bPos]: Position[],\n    [length]: number[],\n    _knownState: StateSet,\n    constrainedState: StateSet\n  ): number {\n    const currDist = Vec.dist(aPos, bPos);\n    if (!constrainedState.hasVar(this.distance)) {\n      this.distance.value = currDist;\n      return 0;\n    } else {\n      return currDist - length;\n    }\n  }\n\n  onClash(that: this): AddConstraintResult<'distance'>;\n  onClash(): AddConstraintResult<'distance'>;\n  onClash(that?: this): AddConstraintResult<'distance'> {\n    if (that) {\n      const eq = equals(this.distance, that.distance);\n      return {\n        constraints: [that, ...eq.constraints],\n        variables: that.ownedVariables,\n        remove() {\n          that.remove();\n          eq.remove();\n        },\n      };\n    } else {\n      return this.toAddConstraintResult();\n    }\n  }\n}\n\nexport function angle(a: Handle, b: Handle): AddConstraintResult<'angle'> {\n  return addConstraint(\n    new ConstraintKeyGenerator('angle', [[a, b]], []),\n    keyGenerator => new Angle(a, b, keyGenerator),\n    existingConstraint => existingConstraint.onClash(a, b)\n  );\n}\n\nexport function fixedAngle(\n  a1: Handle,\n  a2: Handle,\n  b1: Handle,\n  b2: Handle,\n  angleValue: number\n): AddConstraintResult<'diff'> {\n  const {\n    constraints: [angleAConstraint],\n    variables: { angle: angleA },\n  } = angle(a1, a2);\n  const {\n    constraints: [angleBConstraint],\n    variables: { angle: angleB },\n  } = angle(b1, b2);\n  const diff = variable(angleValue);\n  const s = sum(angleA, angleB, diff);\n  const k = constant(diff);\n  return {\n    constraints: [\n      angleAConstraint,\n      angleBConstraint,\n      ...s.constraints,\n      ...k.constraints,\n    ],\n    variables: { diff },\n    remove() {\n      s.remove();\n      k.remove();\n    },\n  };\n}\n\nclass Angle extends Constraint<'angle'> {\n  constructor(\n    public readonly a: Handle,\n    public readonly b: Handle,\n    keyGenerator: ConstraintKeyGenerator\n  ) {\n    super(\n      [a, b],\n      [new Variable(Vec.angle(Vec.sub(b.position, a.position)))],\n      keyGenerator\n    );\n  }\n\n  readonly ownedVariables = { angle: this.angle };\n\n  get angle() {\n    return this.variables[0];\n  }\n\n  addConstrainedState(constrainedState: StateSet): void {\n    constrainedState.addX(this.a);\n    constrainedState.addY(this.a);\n    constrainedState.addX(this.b);\n    constrainedState.addY(this.b);\n  }\n\n  getError(\n    [aPos, bPos]: Position[],\n    [angle]: number[],\n    knownState: StateSet,\n    constrainedState: StateSet\n  ): number {\n    // The old way, which has problems b/c errors are in terms of angles.\n    // const currentAngle = Vec.angle(Vec.sub(bPos, aPos));\n    // return (currentAngle - angle) * 100;\n\n    // The new way, implemented in terms of the minimum amount of displacement\n    // required to satisfy the constraint.\n\n    if (!constrainedState.hasVar(this.angle)) {\n      this.angle.value = Vec.angle(Vec.sub(this.b.position, this.a.position));\n      return 0;\n    }\n\n    const r = Vec.dist(bPos, aPos);\n    let error = Infinity;\n\n    if (!knownState.hasX(this.b) && !knownState.hasY(this.b)) {\n      const x = aPos.x + r * Math.cos(angle);\n      const y = aPos.y + r * Math.sin(angle);\n      error = Math.min(error, Vec.dist(bPos, { x, y }));\n    } else if (!knownState.hasX(this.b)) {\n      const x = aPos.x + (bPos.y - aPos.y) / Math.tan(angle);\n      error = Math.min(error, Math.abs(x - bPos.x));\n    } else if (!knownState.hasY(this.b)) {\n      const y = aPos.y + (bPos.x - aPos.x) * Math.tan(angle);\n      error = Math.min(error, Math.abs(y - bPos.y));\n    }\n\n    if (!knownState.hasX(this.a) && !knownState.hasY(this.a)) {\n      const x = bPos.x + r * Math.cos(angle + Math.PI);\n      const y = bPos.y + r * Math.sin(angle + Math.PI);\n      error = Math.min(error, Vec.dist(aPos, { x, y }));\n    } else if (!knownState.hasX(this.a)) {\n      const x = bPos.x + (aPos.y - bPos.y) / Math.tan(angle + Math.PI);\n      error = Math.min(error, Math.abs(x - aPos.x));\n    } else if (!knownState.hasY(this.b)) {\n      const y = bPos.y + (aPos.x - bPos.x) * Math.tan(angle + Math.PI);\n      error = Math.min(error, Math.abs(y - aPos.y));\n    }\n\n    if (!Number.isFinite(error)) {\n      // We can't move anything, but we'll ignore that and return a \"reasonable\" error.\n      // (This gets better results than returning zero.)\n\n      error = Math.min(\n        // error we'd get from moving b to satisfy the constraint\n        Vec.dist(bPos, {\n          x: aPos.x + r * Math.cos(angle),\n          y: aPos.y + r * Math.sin(angle),\n        }),\n        // error we'd get from moving a to satisfy the constraint\n        Vec.dist(aPos, {\n          x: bPos.x + r * Math.cos(angle + Math.PI),\n          y: Math.sin(angle + Math.PI),\n        })\n      );\n    }\n\n    return error;\n  }\n\n  onClash(that: this): AddConstraintResult<'angle'>;\n  onClash(a: Handle, b: Handle): AddConstraintResult<'angle'>;\n  onClash(thatOrA: this | Handle, b?: Handle): AddConstraintResult<'angle'> {\n    if (thatOrA instanceof Angle) {\n      const that = thatOrA;\n      if (this.a === that.a && this.b === that.b) {\n        // exactly the same thing!\n        const eq = equals(this.angle, that.angle);\n        return {\n          constraints: [that, ...eq.constraints],\n          variables: that.ownedVariables,\n          remove() {\n            that!.remove();\n            eq.remove();\n          },\n        };\n      } else {\n        // same points but different order\n        const diff = new Variable(this.angle.value - that.angle.value);\n        const k = constant(diff);\n        const s = sum(this.angle, that.angle, diff);\n        return {\n          constraints: [that, ...k.constraints, ...s.constraints],\n          variables: that.ownedVariables,\n          remove() {\n            that.remove();\n            k.remove();\n            s.remove();\n          },\n        };\n      }\n    } else {\n      const a = thatOrA;\n      b = b!; // help the type checker understand that this is not undefined\n      const angle = new Variable(Vec.angle(Vec.sub(b.position, a.position)));\n      if (this.a === a && this.b === b) {\n        // exactly the same thing!\n        const eq = equals(this.angle, angle);\n        return {\n          constraints: eq.constraints,\n          variables: { angle },\n          remove() {\n            eq.remove();\n          },\n        };\n      } else {\n        // same points but different order\n        const diff = new Variable(this.angle.value - angle.value);\n        const k = constant(diff);\n        const s = sum(this.angle, angle, diff);\n        return {\n          constraints: [...k.constraints, ...s.constraints],\n          variables: { angle },\n          remove() {\n            k.remove();\n            s.remove();\n          },\n        };\n      }\n    }\n  }\n}\n\n// This is a quick hack to get ivan going!\nexport function polarVector(\n  a: Handle,\n  b: Handle\n): AddConstraintResult<'angle' | 'distance'> {\n  const {\n    constraints: [angleConstraint],\n    variables: { angle: angleVariable },\n  } = angle(a, b);\n  const {\n    constraints: [lengthConstraint],\n    variables: { distance: distanceVariable },\n  } = distance(a, b);\n  return {\n    constraints: [angleConstraint, lengthConstraint],\n    variables: { angle: angleVariable, distance: distanceVariable },\n    remove() {\n      angleConstraint.remove();\n      lengthConstraint.remove();\n    },\n  };\n}\n\nexport function property(handle: Handle, property: 'x' | 'y') {\n  return addConstraint(\n    new ConstraintKeyGenerator('property-' + property, [[handle]], []),\n    keyGenerator => new Property(handle, property, keyGenerator),\n    existingConstraint => existingConstraint.onClash()\n  );\n}\n\nclass Property extends Constraint<'variable'> {\n  constructor(\n    public readonly handle: Handle,\n    public property: 'x' | 'y',\n    keyGenerator: ConstraintKeyGenerator\n  ) {\n    super([handle], [new Variable(handle.position[property])], keyGenerator);\n  }\n\n  readonly ownedVariables = { variable: this.variable };\n\n  get variable() {\n    return this.variables[0];\n  }\n\n  addConstrainedState(constrainedState: StateSet): void {\n    if (this.property === 'x') {\n      constrainedState.addX(this.handle);\n    } else {\n      constrainedState.addY(this.handle);\n    }\n  }\n\n  propagateKnownState(knownState: StateSet): boolean {\n    switch (this.property) {\n      case 'x':\n        if (!knownState.hasX(this.handle) && knownState.hasVar(this.variable)) {\n          this.handle.position = {\n            x: this.variable.value,\n            y: this.handle.position.y,\n          };\n          knownState.addX(this.handle);\n          return true;\n        } else if (\n          knownState.hasX(this.handle) &&\n          !knownState.hasVar(this.variable)\n        ) {\n          this.variable.value = this.handle.position.x;\n          knownState.addVar(this.variable);\n          return true;\n        } else {\n          return false;\n        }\n      case 'y':\n        if (!knownState.hasY(this.handle) && knownState.hasVar(this.variable)) {\n          this.handle.position = {\n            x: this.handle.position.x,\n            y: this.variable.value,\n          };\n          knownState.addY(this.handle);\n          return true;\n        } else if (\n          knownState.hasY(this.handle) &&\n          !knownState.hasVar(this.variable)\n        ) {\n          this.variable.value = this.handle.position.y;\n          knownState.addVar(this.variable);\n          return true;\n        } else {\n          return false;\n        }\n      default:\n        throw new Error('unsupported property ' + this.property);\n    }\n  }\n\n  getError(\n    [handlePos]: Position[],\n    [varValue]: number[],\n    _knownState: StateSet,\n    constrainedState: StateSet\n  ) {\n    const currValue = handlePos[this.property];\n    if (!constrainedState.hasVar(this.variable)) {\n      this.variable.value = currValue;\n      return 0;\n    } else {\n      return currValue - varValue;\n    }\n  }\n\n  getManipulationSet(): ManipulationSet {\n    const handles = this.handles.map(h => h.canonicalInstance);\n    return new ManipulationSet({\n      xs: this.property === 'x' ? handles : [],\n      ys: this.property === 'y' ? handles : [],\n      vars: this.variables,\n    });\n  }\n\n  onClash(): AddConstraintResult<'variable'>;\n  onClash(that: this): AddConstraintResult<'variable'>;\n  onClash(that?: this): AddConstraintResult<'variable'> {\n    if (that && this.variable !== that.variable) {\n      const eq = equals(this.variable, that.variable);\n      return {\n        constraints: [that, ...eq.constraints],\n        variables: that.ownedVariables,\n        remove() {\n          that.remove();\n          eq.remove();\n        },\n      };\n    } else {\n      return this.toAddConstraintResult();\n    }\n  }\n}\n\nexport function formula(\n  args: Variable[],\n  fn: (xs: number[]) => number\n): AddConstraintResult<'result'> {\n  const result = new Variable(fn(args.map(arg => arg.value)));\n  return addConstraint(\n    new ConstraintKeyGenerator('formula#' + generateId(), [], []),\n    keyGenerator => new Formula(args, result, fn, keyGenerator),\n    existingConstraint => existingConstraint.onClash()\n  );\n}\n\nclass Formula extends Constraint<'result'> {\n  constructor(\n    public readonly args: Variable[],\n    public readonly result: Variable,\n    private readonly fn: (xs: number[]) => number,\n    keyGenerator: ConstraintKeyGenerator\n  ) {\n    super([], [...args, result], keyGenerator);\n  }\n\n  readonly ownedVariables = { result: this.result };\n\n  addConstrainedState(constrainedState: StateSet): void {\n    for (const arg of this.args) {\n      constrainedState.addVar(arg);\n    }\n  }\n\n  propagateKnownState(knownState: StateSet): boolean {\n    if (\n      !knownState.hasVar(this.result) &&\n      this.args.every(arg => knownState.hasVar(arg))\n    ) {\n      this.result.value = this.computeResult();\n      knownState.addVar(this.result);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  getError(\n    _handlePositions: Position[],\n    variableValues: number[],\n    _knownState: StateSet,\n    constrainedState: StateSet\n  ): number {\n    const currValue = this.computeResult(variableValues);\n    if (!constrainedState.hasVar(this.result)) {\n      this.result.value = currValue;\n      return 0;\n    } else {\n      return currValue - this.result.value;\n    }\n  }\n\n  onClash(): AddConstraintResult<'result'>;\n  onClash(that: this): AddConstraintResult<'result'>;\n  onClash(_that?: this): AddConstraintResult<'result'> {\n    throw new Error('Formula.onClash() should never be called!');\n  }\n\n  private computeResult(\n    xs: number[] = this.args.map(arg => arg.value)\n  ): number {\n    return this.fn(xs);\n  }\n}\n\n// #region temporary constraints\n\nconst tempConstraints = new Set<Constraint>();\n\nexport const now = {\n  clear() {\n    for (const constraint of tempConstraints) {\n      tempConstraints.delete(constraint);\n      constraint.remove();\n    }\n  },\n\n  constant(variable: Variable, value: number = variable.value) {\n    return captureNewConstraints(tempConstraints, () =>\n      constant(variable, value)\n    );\n  },\n\n  equals(a: Variable, b: Variable) {\n    return captureNewConstraints(tempConstraints, () => equals(a, b));\n  },\n\n  sum(a: Variable, b: Variable, c: Variable) {\n    return captureNewConstraints(tempConstraints, () => sum(a, b, c));\n  },\n\n  pin(handle: Handle, pos: Position = handle.position) {\n    return captureNewConstraints(tempConstraints, () => pin(handle, pos));\n  },\n\n  horizontal(a: Handle, b: Handle) {\n    return captureNewConstraints(tempConstraints, () => horizontal(a, b));\n  },\n\n  vertical(a: Handle, b: Handle) {\n    return captureNewConstraints(tempConstraints, () => vertical(a, b));\n  },\n\n  distance(a: Handle, b: Handle) {\n    return captureNewConstraints(tempConstraints, () => distance(a, b));\n  },\n\n  equalDistance(a1: Handle, a2: Handle, b1: Handle, b2: Handle) {\n    return captureNewConstraints(tempConstraints, () =>\n      equalDistance(a1, a2, b1, b2)\n    );\n  },\n\n  angle(a: Handle, b: Handle) {\n    return captureNewConstraints(tempConstraints, () => angle(a, b));\n  },\n\n  fixedAngle(\n    a1: Handle,\n    a2: Handle,\n    b1: Handle,\n    b2: Handle,\n    angleValue: number\n  ) {\n    return captureNewConstraints(tempConstraints, () =>\n      fixedAngle(a1, a2, b1, b2, angleValue)\n    );\n  },\n\n  polarVector(a: Handle, b: Handle) {\n    return captureNewConstraints(tempConstraints, () => polarVector(a, b));\n  },\n\n  property(handle: Handle, p: 'x' | 'y') {\n    return captureNewConstraints(tempConstraints, () => property(handle, p));\n  },\n\n  formula(args: Variable[], fn: (xs: number[]) => number) {\n    return captureNewConstraints(tempConstraints, () => formula(args, fn));\n  },\n};\n\n// #endregion temporary constraints\n\n// #region debugging\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(window as any).allConstraints = Constraint.all;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(window as any).allVariables = Variable.all;\n\n// #endregion debugging\n"],
  "mappings": "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",
  "names": []
}
