{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/Prototypes/OldInputSystem/src/app/FreehandSelection.ts"],
  "sourcesContent": ["import Vec from '../lib/vec';\nimport Events, { Event } from './NativeEvents';\nimport Page from './Page';\nimport FreehandStroke from './strokes/FreehandStroke';\n\nexport default class FreehandSelection {\n  readonly selectedStrokes = new Set<FreehandStroke>();\n  private clusterSelectionIndex = 0;\n\n  // Interaction State\n  private fingerDown: Event | null = null;\n  private fingerMoved: Event | null = null;\n\n  constructor(private readonly page: Page) {}\n\n  update(events: Events) {\n    const fingerDown = events.find('finger', 'began');\n    if (fingerDown) {\n      this.fingerDown = fingerDown;\n      const foundStroke = this.page.findFreehandStrokeNear(fingerDown.position);\n      const foundHandle = this.page.findHandleNear(fingerDown.position);\n\n      // Register longpress\n      window.setTimeout(() => {\n        if (\n          this.fingerDown &&\n          (!this.fingerMoved ||\n            Vec.dist(this.fingerDown.position, this.fingerMoved.position) < 10)\n        ) {\n          this.createGroupFromSelection();\n        }\n      }, 750);\n\n      if (foundStroke && !foundHandle) {\n        this.fingerDownOnStroke(foundStroke);\n      } else {\n        this.fingerDownOnEmptySpace();\n      }\n    }\n\n    if (this.fingerDown) {\n      const fingerMoved = events.find('finger', 'moved', this.fingerDown.id);\n      if (fingerMoved) {\n        this.fingerMoved = fingerMoved;\n      }\n\n      const fingerEnded = events.find('finger', 'ended', this.fingerDown.id);\n      if (fingerEnded) {\n        this.fingerDown = null;\n        this.fingerMoved = null;\n      }\n    }\n  }\n\n  private createGroupFromSelection() {\n    // It doesn't make sense for the same stroke to be in more than one group.\n    // E.g., what transform applies when the user has moved handles associated\n    // with the more than one group that the stroke belongs to? That's why\n    // we only consider strokes that are not already in a group.\n    const ungroupedStrokes = new Set(\n      Array.from(this.selectedStrokes).filter(s => !s.group)\n    );\n    if (ungroupedStrokes.size > 0) {\n      this.page.addStrokeGroup(ungroupedStrokes);\n      for (const stroke of ungroupedStrokes) {\n        stroke.deselect();\n      }\n    }\n  }\n\n  private fingerDownOnStroke(stroke: FreehandStroke) {\n    if (this.selectedStrokes.has(stroke)) {\n      const clusters = this.page.clusters.getClustersForStroke(stroke);\n\n      console.log(clusters);\n\n      if (!clusters) {\n        return;\n      }\n\n      this.clusterSelectionIndex++;\n      const cluster = clusters.get(\n        this.clusterSelectionIndex % clusters.size()\n      );\n\n      this.clearSelection();\n      for (const stroke of cluster) {\n        this.select(stroke);\n      }\n    } else {\n      this.select(stroke);\n      if (this.selectedStrokes.size > 1) {\n        for (const stroke of this.selectedStrokes) {\n          this.page.clusters.addClusterForStroke(stroke, this.selectedStrokes);\n        }\n      }\n\n      this.clusterSelectionIndex = 0;\n    }\n  }\n\n  private fingerDownOnEmptySpace() {\n    this.clearSelection();\n  }\n\n  render() {\n    // if (this.selectedStrokes) {\n    //   this.selectedStrokes.render()\n    // }\n  }\n\n  private select(stroke: FreehandStroke) {\n    stroke.select();\n\n    // if (stroke.group) {\n    //   stroke.group.a.select()\n    //   stroke.group.b.select()\n    // }\n\n    this.selectedStrokes.add(stroke);\n  }\n\n  private clearSelection() {\n    for (const stroke of this.selectedStrokes) {\n      stroke.deselect();\n    }\n\n    this.selectedStrokes.clear();\n  }\n}\n"],
  "mappings": "AAAA;AAKA,uCAAuC;AAAA,EAQrC,YAA6B,MAAY;AAAZ;AAPpB,2BAAkB,IAAI;AACvB,iCAAwB;AAGxB,sBAA2B;AAC3B,uBAA4B;AAAA;AAAA,EAIpC,OAAO,QAAgB;AACrB,UAAM,aAAa,OAAO,KAAK,UAAU;AACzC,QAAI,YAAY;AACd,WAAK,aAAa;AAClB,YAAM,cAAc,KAAK,KAAK,uBAAuB,WAAW;AAChE,YAAM,cAAc,KAAK,KAAK,eAAe,WAAW;AAGxD,aAAO,WAAW,MAAM;AACtB,YACE,KAAK,cACJ,EAAC,KAAK,eACL,IAAI,KAAK,KAAK,WAAW,UAAU,KAAK,YAAY,YAAY,KAClE;AACA,eAAK;AAAA;AAAA,SAEN;AAEH,UAAI,eAAe,CAAC,aAAa;AAC/B,aAAK,mBAAmB;AAAA,aACnB;AACL,aAAK;AAAA;AAAA;AAIT,QAAI,KAAK,YAAY;AACnB,YAAM,cAAc,OAAO,KAAK,UAAU,SAAS,KAAK,WAAW;AACnE,UAAI,aAAa;AACf,aAAK,cAAc;AAAA;AAGrB,YAAM,cAAc,OAAO,KAAK,UAAU,SAAS,KAAK,WAAW;AACnE,UAAI,aAAa;AACf,aAAK,aAAa;AAClB,aAAK,cAAc;AAAA;AAAA;AAAA;AAAA,EAKjB,2BAA2B;AAKjC,UAAM,mBAAmB,IAAI,IAC3B,MAAM,KAAK,KAAK,iBAAiB,OAAO,OAAK,CAAC,EAAE;AAElD,QAAI,iBAAiB,OAAO,GAAG;AAC7B,WAAK,KAAK,eAAe;AACzB,iBAAW,UAAU,kBAAkB;AACrC,eAAO;AAAA;AAAA;AAAA;AAAA,EAKL,mBAAmB,QAAwB;AACjD,QAAI,KAAK,gBAAgB,IAAI,SAAS;AACpC,YAAM,WAAW,KAAK,KAAK,SAAS,qBAAqB;AAEzD,cAAQ,IAAI;AAEZ,UAAI,CAAC,UAAU;AACb;AAAA;AAGF,WAAK;AACL,YAAM,UAAU,SAAS,IACvB,KAAK,wBAAwB,SAAS;AAGxC,WAAK;AACL,iBAAW,WAAU,SAAS;AAC5B,aAAK,OAAO;AAAA;AAAA,WAET;AACL,WAAK,OAAO;AACZ,UAAI,KAAK,gBAAgB,OAAO,GAAG;AACjC,mBAAW,WAAU,KAAK,iBAAiB;AACzC,eAAK,KAAK,SAAS,oBAAoB,SAAQ,KAAK;AAAA;AAAA;AAIxD,WAAK,wBAAwB;AAAA;AAAA;AAAA,EAIzB,yBAAyB;AAC/B,SAAK;AAAA;AAAA,EAGP,SAAS;AAAA;AAAA,EAMD,OAAO,QAAwB;AACrC,WAAO;AAOP,SAAK,gBAAgB,IAAI;AAAA;AAAA,EAGnB,iBAAiB;AACvB,eAAW,UAAU,KAAK,iBAAiB;AACzC,aAAO;AAAA;AAGT,SAAK,gBAAgB;AAAA;AAAA;",
  "names": []
}
