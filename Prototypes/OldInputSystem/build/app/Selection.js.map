{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/Prototypes/OldInputSystem/src/app/Selection.ts"],
  "sourcesContent": ["import TransformationMatrix from '../lib/TransformationMatrix';\nimport { Position } from '../lib/types';\nimport Vec from '../lib/vec';\nimport Events, { Event } from './NativeEvents';\nimport Page from './Page';\nimport Snaps from './Snaps';\nimport Handle from './strokes/Handle';\n\nexport default class Selection {\n  readonly handles = new Set<Handle>();\n  readonly origPosition = new Map<Handle, Position>();\n\n  // gesture state\n  tappedOn?: Handle;\n  firstFinger?: Event;\n  firstFingerMoved?: Event;\n  secondFinger?: Event;\n  secondFingerMoved?: Event;\n\n  touchingGizmo = false;\n\n  constructor(\n    private readonly page: Page,\n    private readonly snaps: Snaps\n  ) {}\n\n  includes(handle: Handle): boolean {\n    return this.handles.has(handle.canonicalInstance);\n  }\n\n  update1(events: Events) {\n    const fingerDown = events.find('finger', 'began');\n    if (fingerDown) {\n      // If we weren't already holding down a finger\n      if (!this.firstFinger) {\n        this.firstFinger = fingerDown;\n        this.firstFingerMoved = fingerDown;\n\n        const handle = this.page.findHandleNear(fingerDown.position);\n        if (handle) {\n          this.selectHandle(handle);\n          this.tappedOn = handle;\n        } else {\n          this.tappedOn = undefined;\n        }\n\n        // Set initial offset transform\n        const pos = fingerDown.position;\n        const transform = TransformationMatrix.identity()\n          .translate(pos.x, pos.y)\n          .inverse();\n        for (const handle of this.handles) {\n          this.origPosition.set(\n            handle,\n            transform.transformPoint(handle.position)\n          );\n        }\n      } else {\n        // Two fingers, go into full transform mode\n        this.secondFinger = fingerDown;\n        this.secondFingerMoved = fingerDown;\n\n        // Set initial offset transform\n        const a = Vec.divS(\n          Vec.add(this.firstFingerMoved!.position, this.secondFinger.position),\n          2\n        );\n        const b = this.secondFinger.position;\n        const transform = TransformationMatrix.fromLineTranslateRotate(\n          a,\n          b\n        ).inverse();\n        for (const handle of this.handles) {\n          this.origPosition.set(\n            handle,\n            transform.transformPoint(handle.position)\n          );\n        }\n      }\n    }\n  }\n\n  update2(events: Events) {\n    // If we're already holding down a finger, switch to pinch gesture\n    if (this.firstFinger) {\n      const fingerMove = events.findLast(\n        'finger',\n        'moved',\n        this.firstFinger.id\n      );\n      if (fingerMove && !this.touchingGizmo) {\n        this.firstFingerMoved = fingerMove;\n        this.transformSelection();\n      }\n\n      const fingerUp = events.find('finger', 'ended', this.firstFinger.id);\n      if (fingerUp) {\n        const shortTap = fingerUp.timestamp - this.firstFinger.timestamp < 0.2;\n        if (shortTap) {\n          const tappedOnEmptySpace = !this.tappedOn && !this.touchingGizmo;\n          if (tappedOnEmptySpace) {\n            this.clearSelection();\n          }\n        } else {\n          if (this.tappedOn && this.handles.size === 1) {\n            this.clearSelection();\n          }\n        }\n\n        for (const handle of this.handles) {\n          handle.absorbNearbyHandles();\n        }\n\n        this.firstFinger = undefined;\n        this.firstFingerMoved = undefined;\n\n        // TODO: this could be done better\n        this.secondFinger = undefined;\n        this.secondFingerMoved = undefined;\n\n        this.snaps.clear();\n      }\n    }\n\n    if (this.secondFinger) {\n      const fingerMove = events.find('finger', 'moved', this.secondFinger.id);\n      if (fingerMove) {\n        this.secondFingerMoved = fingerMove;\n        this.transformSelection();\n      }\n\n      const fingerTwoUp = events.find('finger', 'ended', this.secondFinger.id);\n      if (fingerTwoUp) {\n        this.secondFinger = undefined;\n        this.secondFingerMoved = undefined;\n\n        // TODO: this could be done better\n        this.firstFinger = undefined;\n        this.firstFingerMoved = undefined;\n      }\n    }\n  }\n\n  private selectHandle(handle: Handle) {\n    handle.select();\n    this.handles.add(handle.canonicalInstance);\n    this.updateLineSelections();\n  }\n\n  private deselectHandle(handle: Handle) {\n    handle.deselect();\n    this.handles.delete(handle.canonicalInstance);\n    this.updateLineSelections();\n  }\n\n  private updateLineSelections() {\n    for (const ls of this.page.lineSegments) {\n      if (\n        this.handles.has(ls.a.canonicalInstance) &&\n        this.handles.has(ls.b.canonicalInstance)\n      ) {\n        ls.select();\n      } else {\n        ls.deselect();\n      }\n    }\n  }\n\n  private clearSelection() {\n    for (const handle of this.handles) {\n      handle.deselect();\n    }\n\n    this.handles.clear();\n    this.origPosition.clear();\n\n    for (const ls of this.page.lineSegments) {\n      ls.deselect();\n    }\n  }\n\n  transformSelection() {\n    let transform: TransformationMatrix;\n    if (this.firstFingerMoved && this.secondFingerMoved) {\n      const a = Vec.divS(\n        Vec.add(\n          this.firstFingerMoved.position,\n          this.secondFingerMoved.position\n        ),\n        2\n      );\n      const b = this.secondFingerMoved.position;\n      transform = TransformationMatrix.fromLineTranslateRotate(a, b);\n    } else {\n      const p = this.firstFingerMoved!.position;\n      transform = TransformationMatrix.identity().translate(p.x, p.y);\n    }\n\n    const transformedPositions = new Map<Handle, Position>();\n    for (const handle of this.handles) {\n      const oldPos = this.origPosition.get(handle)!;\n      const newPos = transform.transformPoint(oldPos);\n      transformedPositions.set(handle, newPos);\n    }\n\n    const snappedPositions = this.snaps.snapPositions(transformedPositions);\n\n    const brokenOffHandles = new Set<Handle>();\n    for (const handle of this.handles) {\n      const newPos = snappedPositions.get(handle)!;\n      const handleThatBreaksOff = this.getHandleThatBreaksOff(handle, newPos);\n      if (handleThatBreaksOff) {\n        // console.log('breaking off', handleThatBreaksOff, 'from', handle);\n        handle.breakOff(handleThatBreaksOff);\n        // console.log('broke off handle', handleThatBreaksOff, 'from', handle);\n        handleThatBreaksOff.position = newPos;\n\n        // deselect the original angle and remove it from the set of\n        // selected handles\n        this.deselectHandle(handle);\n\n        // we'll add handleThatBreaksOff to the set of selected handles\n        // (and tell it that it's selected) after this loop is done,\n        // so that we won't see it this time around\n        brokenOffHandles.add(handleThatBreaksOff);\n\n        // update orig position map\n        const origPos = this.origPosition.get(handle)!;\n        this.origPosition.delete(handle);\n        this.origPosition.set(handleThatBreaksOff, origPos);\n      } else {\n        handle.position = newPos;\n      }\n    }\n\n    for (const brokenOffHandle of brokenOffHandles) {\n      this.selectHandle(brokenOffHandle);\n    }\n  }\n\n  getHandleThatBreaksOff(handle: Handle, newPos: Position): Handle | null {\n    if (\n      // TODO: decide based on acceleration?\n      Vec.dist(handle.position, newPos) < 60 ||\n      handle.absorbedHandles.size === 0\n    ) {\n      return null;\n    }\n\n    const v = Vec.sub(newPos, handle.position);\n    let smallestAngle = Infinity;\n    let handleWithSmallestAngle: Handle | null = null;\n\n    for (const h of [handle, ...handle.absorbedHandles]) {\n      for (const ch of this.page.getHandlesImmediatelyConnectedTo(h)) {\n        const angle = Math.abs(\n          Vec.angleBetweenClockwise(v, Vec.sub(ch.position, handle.position))\n        );\n        if (angle < smallestAngle) {\n          smallestAngle = angle;\n          handleWithSmallestAngle = h;\n        }\n      }\n    }\n\n    return handleWithSmallestAngle!;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
