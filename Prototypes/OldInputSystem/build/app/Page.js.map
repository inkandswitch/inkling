{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/Prototypes/OldInputSystem/src/app/Page.ts"],
  "sourcesContent": ["import Vec from '../lib/vec';\nimport ArcSegment from './strokes/ArcSegment';\nimport LineSegment from './strokes/LineSegment';\nimport FreehandStroke from './strokes/FreehandStroke';\nimport StrokeGroup from './strokes/StrokeGroup';\nimport Stroke from './strokes/Stroke';\nimport StrokeClusters from './StrokeClusters';\nimport { Position, PositionWithPressure } from '../lib/types';\nimport Handle from './strokes/Handle';\nimport StrokeAnalyzer from './StrokeAnalyzer';\nimport { makeIterableIterator } from '../lib/helpers';\n\ninterface Options {\n  strokeAnalyzer: boolean;\n}\n\nexport default class Page {\n  // Stroke clusters are possible stroke Groups\n  readonly clusters = new StrokeClusters();\n\n  // Stroke graph looks at the page and tries to be smart about finding structure\n  readonly analyzer: StrokeAnalyzer | null;\n\n  // TODO: figure out a better model for how to store different kinds of strokes\n  // For now just keep them separate, until we have a better idea of what freehand strokes look like\n  readonly lineSegments: Array<LineSegment | ArcSegment> = [];\n  readonly strokeGroups: StrokeGroup[] = [];\n  readonly strokes: Stroke[] = [];\n\n  constructor(options: Options) {\n    this.analyzer = options.strokeAnalyzer ? new StrokeAnalyzer(this) : null;\n  }\n\n  get freehandStrokes() {\n    return makeIterableIterator(\n      [this.strokes],\n      (s: Stroke): s is FreehandStroke => s instanceof FreehandStroke\n    );\n  }\n\n  addLineSegment(aPos: Position, bPos: Position) {\n    const ls = new LineSegment(aPos, bPos);\n    this.lineSegments.push(ls);\n    return ls;\n  }\n\n  addArcSegment(aPos: Position, bPos: Position, cPos: Position) {\n    const as = new ArcSegment(aPos, bPos, cPos);\n    this.lineSegments.push(as);\n    return as;\n  }\n\n  addStrokeGroup(strokes: Set<FreehandStroke>): StrokeGroup {\n    const sg = new StrokeGroup(strokes);\n    this.strokeGroups.push(sg);\n    return sg;\n  }\n\n  addStroke<S extends Stroke>(stroke: S) {\n    this.strokes.push(stroke);\n    return stroke;\n  }\n\n  onstrokeUpdated(stroke: Stroke) {\n    if (stroke instanceof FreehandStroke) {\n      this.analyzer?.addStroke(stroke);\n    }\n  }\n\n  addFreehandStroke(points: Array<PositionWithPressure>) {\n    const s = new FreehandStroke(points);\n    this.addStroke(s);\n    this.analyzer?.addStroke(s);\n    return s;\n  }\n\n  findHandleNear(pos: Position, dist = 20): Handle | null {\n    let closestHandle: Handle | null = null;\n    let closestDistance = dist;\n\n    for (const handle of Handle.all) {\n      const d = Vec.dist(handle.position, pos);\n      if (d < closestDistance) {\n        closestDistance = d;\n        closestHandle = handle;\n      }\n    }\n\n    return closestHandle;\n  }\n\n  handlesReachableFrom(startHandles: Handle[]) {\n    const reachableHandles = new Set(\n      startHandles.map(handle => handle.canonicalInstance)\n    );\n    const things = [...this.lineSegments, ...this.strokeGroups];\n    while (true) {\n      const oldSize = reachableHandles.size;\n\n      for (const thing of things) {\n        if (reachableHandles.has(thing.a.canonicalInstance)) {\n          reachableHandles.add(thing.b.canonicalInstance);\n        }\n        if (reachableHandles.has(thing.b.canonicalInstance)) {\n          reachableHandles.add(thing.a.canonicalInstance);\n        }\n      }\n\n      if (reachableHandles.size === oldSize) {\n        break;\n      }\n    }\n    return reachableHandles;\n  }\n\n  /**\n   * returns a set of handles that are immediately connected to the given handle\n   * (but not to its canonical handle, if it has been absorbed)\n   */\n  getHandlesImmediatelyConnectedTo(handle: Handle) {\n    const connectedHandles = new Set<Handle>();\n\n    for (const thing of [...this.lineSegments, ...this.strokeGroups]) {\n      if (handle === thing.a) {\n        connectedHandles.add(thing.b);\n      }\n      if (handle === thing.b) {\n        connectedHandles.add(thing.a);\n      }\n    }\n\n    return connectedHandles;\n  }\n\n  findFreehandStrokeNear(pos: Position, dist = 20) {\n    let closestStroke = null;\n    let closestDistance = dist;\n\n    for (const stroke of this.freehandStrokes) {\n      const d = stroke.minDistanceFrom(pos);\n      if (d < closestDistance) {\n        closestDistance = d;\n        closestStroke = stroke;\n      }\n    }\n\n    return closestStroke;\n  }\n\n  findStrokeGroupNear(pos: Position, dist = 20) {\n    let closestStrokeGroup = null;\n    let closestDistance = dist;\n\n    for (const strokeGroup of this.strokeGroups) {\n      const d = strokeGroup.minDistanceFrom(pos);\n      if (d < closestDistance) {\n        closestDistance = d;\n        closestStrokeGroup = strokeGroup;\n      }\n    }\n\n    return closestStrokeGroup;\n  }\n\n  render() {\n    this.lineSegments.forEach(render);\n    this.strokes.forEach(render);\n    this.analyzer?.render();\n  }\n}\n\ntype Renderable = { render: Function };\nconst render = (s: Renderable) => s.render();\n"],
  "mappings": "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",
  "names": []
}
