{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/Prototypes/OldInputSystem/src/app/StrokeAnalyzer.ts"],
  "sourcesContent": ["// Work in progress\n// TODO:\n// [] Find shortest (Maximally turning) loops\n// [] Find smooth continuation loops\n// [] Find connectors between shapes\n// [] Find blobbly clusters like text etc.\n\n// [] Update graph when strokes are moved\n\nimport { Position, PositionWithPressure } from '../lib/types';\nimport Page from './Page';\nimport FreehandStroke from './strokes/FreehandStroke';\nimport Vec from '../lib/vec';\nimport Svg from './Svg';\n\n\n// **\n// StrokeGraph, Intermediate representation of the page. Useful for finding loops etc.\n// TODO: Maybe move to a different file, just leave here for now\n// **\n\n// Node in the graph\nclass StrokeGraphNode {\n  averagePosition: Position;\n  positions: Array<Position>;\n\n  constructor(position: Position) {\n    this.averagePosition = position;\n    this.positions = [position];\n  }\n\n  addPosition(position: Position){\n    this.positions.push(position);\n    this.averagePosition = Vec.divS(\n      this.positions.reduce((acc, v)=> Vec.add(acc, v), Vec(0,0)), \n      this.positions.length\n    )\n  }\n}\n\n// A partial stroke is a reference to a slice of a FreehandStroke\n// Equivalent to an actual edge in the graph\ninterface PartialStroke {\n  stroke: FreehandStroke;\n  pointIndexes: Array<number>;\n  nodes: Array<StrokeGraphNode>;\n  distance: number;\n  id: string; //TODO: Maybe there's a better way of identifying uniqueness?\n}\n\n\n// Not quite the same as an edge in the graph, as it represents multiple edges along the length of a stroke\nclass StrokeGraphEdge {\n  stroke: FreehandStroke;\n\n  // A sorted array of nodes positioned along the length of the stroke\n  nodesWithPointIndex: Array<{node: StrokeGraphNode, pointIndex: number}> = [];\n  \n  constructor(stroke: FreehandStroke){\n    this.stroke = stroke;\n  }\n\n  addNode(node: StrokeGraphNode, pointIndex: number) {\n    if(this.nodesWithPointIndex.find(n=>n.node == node)) {\n      return;\n    }\n\n    this.nodesWithPointIndex.push({node, pointIndex});\n    this.nodesWithPointIndex.sort((a, b)=>{\n      return a.pointIndex - b.pointIndex;\n    })\n  }\n\n  // Find nodes that are directly reachable from this node along this edge\n  getAdjacentNodes(node: StrokeGraphNode): Array<StrokeGraphNode>{\n    let index = this.nodesWithPointIndex.findIndex(n=>n.node===node);\n    if(index == -1) return [];\n\n    const adjacentNodes = [\n      this.nodesWithPointIndex[index-1],\n      this.nodesWithPointIndex[index+1]\n    ].filter(n=>n).map(n=>n.node);\n\n    return adjacentNodes;\n  }\n  \n  getPartialStrokeBetween(nodeA: StrokeGraphNode, nodeB: StrokeGraphNode): PartialStroke {\n    const indexA = this.nodesWithPointIndex.find(n=>n.node===nodeA)?.pointIndex;\n    const indexB = this.nodesWithPointIndex.find(n=>n.node===nodeB)?.pointIndex;\n    if(indexA === undefined || indexB === undefined) {\n      throw new Error('nodes not connected to this edge');\n    };\n\n    const pointIndexes = [indexA, indexB].sort((a, b)=>a-b);\n    const distance = this.stroke.distanceBetweenPoints(pointIndexes[0], pointIndexes[1]);\n\n    return {\n      stroke: this.stroke,\n      pointIndexes,\n      nodes: [nodeA, nodeB],\n      distance,\n      id: this.stroke.id+\"_\"+pointIndexes[0]+\"_\"+pointIndexes[1]\n    }\n  }\n\n  getAdjacentPartialStrokes(node: StrokeGraphNode): Array<PartialStroke> {\n    const adjacentNodes = this.getAdjacentNodes(node);\n    return adjacentNodes.map(otherNode=>{\n      return this.getPartialStrokeBetween(node, otherNode);\n    })\n  }\n}\n\nclass StrokeGraph {\n  nodes: Array<StrokeGraphNode> = [];\n  edges: Array<StrokeGraphEdge> = [];\n\n  addNode(position: Position): StrokeGraphNode {\n    // Find node that we can collapse into\n    const found = this.nodes.find(node=>{\n      return node.positions.find(p=>Vec.dist(position, p) < 10)\n    })\n\n    if(found) {\n      found.addPosition(position);\n      return found\n    }\n\n    const newNode = new StrokeGraphNode(position);\n    this.nodes.push(newNode);\n    return newNode;\n  }\n\n  addEdge(stroke: FreehandStroke, node: StrokeGraphNode, index: number){\n    // Find an edge that we can collapse into\n    let edge = this.edges.find(edge=>{\n      return edge.stroke == stroke\n    })\n\n    if(!edge) {\n      edge = new StrokeGraphEdge(stroke);\n      this.edges.push(edge);\n    }\n\n    edge.addNode(node, index);\n  }\n\n  getAdjacentNodes(node: StrokeGraphNode): Set<StrokeGraphNode> {\n    let neighbours: Set<StrokeGraphNode> = new Set();\n    for(const edge of this.edges) {\n      let edgeNeighbours = edge.getAdjacentNodes(node);\n      for(const n of edgeNeighbours) {\n        neighbours.add(n);\n      }\n    }\n\n    return neighbours\n  }\n\n  getAdjacentPartialStrokes(node: StrokeGraphNode): Array<PartialStroke> {\n    return this.edges.flatMap(edge=>edge.getAdjacentPartialStrokes(node));\n  }\n\n  // Find the shortest cycle for this node\n  findShortestCycle(startNode: StrokeGraphNode, visited: Set<string>) {\n    let partialStrokes = this.getAdjacentPartialStrokes(startNode);\n    console.log(\"partialStrokes\", partialStrokes);\n    partialStrokes.sort((a, b)=>a.distance - b.distance);\n\n    // If there are multiple partial strokes that means we can possibly find a loop\n    if(partialStrokes.length > 1) {\n      const startStroke = partialStrokes.pop();\n      const targetNodes = partialStrokes.map(ps=>ps.nodes[1]);\n\n      for(const targetNode of targetNodes) {\n\n      }\n    }\n  }\n  \n  // TODO: Improve search heuristic here\n  shortestFirstSearch(\n    startNode: StrokeGraphNode, \n    targetNode: StrokeGraphNode, \n    visitedEdges: Set<string> = new Set(),\n    path: Array<PartialStroke> = [],\n    paths: Array<Array<PartialStroke>> = []\n  ) {\n\n    console.log(\"sfs\", startNode, targetNode, visitedEdges, path, paths);\n    \n    if(path.length > 0 && startNode === targetNode) {\n      paths.push([...path]);\n    }\n\n    let partialStrokes = this.getAdjacentPartialStrokes(startNode)\n      .filter(ps=>!visitedEdges.has(ps.id)) // Only edges that we haven't visited yet\n      .sort((a, b)=>a.distance - b.distance); // Do shortest edge first\n\n    console.log(\"partialStrokes\", partialStrokes);\n    \n    for(const ps of partialStrokes) {\n      let nextNode = ps.nodes[1];\n      visitedEdges.add(ps.id);\n      path.push(ps);\n      this.shortestFirstSearch(nextNode, targetNode, visitedEdges, path, paths);\n    }\n\n    return paths;\n  }\n\n  // // Dijkstras shortest path between nodes\n  // findShortestPathBetween(startNode: StrokeGraphNode, endNode: StrokeGraphNode) {\n    \n  // }\n\n  render(){\n    this.nodes.forEach(node=>{\n      Svg.now(\"circle\", {\n        cx: node.averagePosition.x,\n        cy: node.averagePosition.y,\n        r: \"5\",\n        fill: \"pink\"\n      });\n    })\n    \n  }\n}\n\n// **\n// Stroke Analyzer: Responsible for running different analysis algorithms\n// ** \n\nexport default class StrokeAnalyzer {\n  page: Page;\n  graph = new StrokeGraph();\n\n  loops = new Array<any>();\n  //partialStrokes: \n  //loops: Loop[] = [];\n\n  constructor(page: Page){\n    this.page = page\n  }\n\n  addStroke(stroke: FreehandStroke) {\n    console.log(stroke);\n    \n    this.generateConnectionsForStroke(stroke);\n    this.generateLoopsForStroke(stroke);\n  }\n  \n\n  generateConnectionsForStroke(stroke: FreehandStroke) {\n    // Generate connections for this stroke\n    \n    for (const otherStroke of this.page.freehandStrokes) {\n      \n      if(stroke === otherStroke) {\n        continue;\n      }\n      \n      const connectionZonesForStroke = findConnectionZonesBetweenStrokes(stroke.points, otherStroke.points);\n      \n\n      for(const connectionZone of connectionZonesForStroke) {\n        // Compute position of connection zone\n        const position = Vec.mulS(\n          Vec.add(\n            stroke.points[connectionZone.mid[0]],\n            otherStroke.points[connectionZone.mid[1]]\n          ),\n          0.5\n        );\n\n        let node = this.graph.addNode(position);\n        this.graph.addEdge(stroke, node, connectionZone.mid[0]);\n        this.graph.addEdge(otherStroke, node, connectionZone.mid[1]);\n        let shortestLoop = this.graph.shortestFirstSearch(node, node);\n        this.loops.push(...shortestLoop);\n      }\n\n      console.log(this.graph);\n    }\n\n    // TODO: Find self intersections & closings\n  }\n\n  generateLoopsForStroke(targetStroke: FreehandStroke){\n    // Do a breadth first search for loops\n\n  }\n\n  generateArrowLikes(){\n\n  }\n\n  render(){\n    this.graph.render()\n\n    this.loops.forEach(loop=>{\n      loop.forEach((ps: any)=>{\n        let points = Svg.points(ps.stroke.points.slice(ps.pointIndexes[0], ps.pointIndexes[1]))\n        Svg.now(\"polyline\", {\n          points,\n          stroke: \"rgba(255,0,0,0.1)\",\n          fill: \"none\",\n          \"stroke-width\": \"5\"\n        })\n      })\n    })\n  }\n}\n\ninterface ConnectionZone {\n  start: [number, number];\n  mid: [number, number];\n  end: [number, number];\n  dist: number;\n}\n\nfunction findConnectionZonesBetweenStrokes(\n  strokeA: PositionWithPressure[],\n  strokeB: PositionWithPressure[]\n): ConnectionZone[] {\n  const connections: ConnectionZone[] = [];\n\n  let currentConnection: ConnectionZone | null = null;\n  for (let i = 0; i < strokeA.length; i++) {\n    const closest = findClosestPointOnStroke(strokeB, strokeA[i]);\n\n    if (closest.dist < 20) {\n      if (!currentConnection) {\n        currentConnection = {\n          start: [i, closest.index],\n          end: [i, closest.index],\n          mid: [i, closest.index],\n          dist: closest.dist,\n        };\n      } else {\n        currentConnection.end = [i, closest.index];\n        if (closest.dist < currentConnection.dist) {\n          currentConnection.mid = [i, closest.index];\n          currentConnection.dist = closest.dist;\n        }\n      }\n    } else {\n      if (currentConnection) {\n        connections.push(currentConnection);\n        currentConnection = null;\n      }\n    }\n  }\n\n  if (currentConnection) {\n    connections.push(currentConnection);\n  }\n\n  return connections;\n}\n\n// TODO: we can speed this up significantly if it becomes a bottleneck.\nfunction findClosestPointOnStroke(\n  stroke: PositionWithPressure[],\n  point: PositionWithPressure\n) {\n  let minDist = Vec.dist(stroke[0], point);\n  let index = 0;\n\n  for (let i = 0; i < stroke.length; i++) {\n    const dist = Vec.dist(stroke[i], point);\n    if (dist < minDist) {\n      minDist = dist;\n      index = i;\n    }\n  }\n\n  return { dist: minDist, index };\n}"],
  "mappings": "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",
  "names": []
}
