{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/Prototypes/OldInputSystem/src/app/strokes/StrokeGroup.ts"],
  "sourcesContent": ["import FreehandStroke from './FreehandStroke';\nimport Handle from './Handle';\n\nimport TransformationMatrix from '../../lib/TransformationMatrix';\nimport { Position, PositionWithPressure } from '../../lib/types';\n\nimport { farthestPair } from '../../lib/helpers';\n\n// import ClipperShape from \"@doodle3d/clipper-js\"\n\n// import simplify from \"simplify-js\";\n// import {SkeletonBuilder} from 'straight-skeleton';\n\n// import Voronoi from \"voronoi\"\n// const voronoi = new Voronoi();\n\nexport default class StrokeGroup {\n  readonly strokes: FreehandStroke[];\n  private pointData: PositionWithPressure[][];\n  readonly a: Handle;\n  readonly b: Handle;\n\n  // outlineShape: ClipperShape;\n  skeleton: Position[] = [];\n  dirty = false;\n\n  svgElements: SVGElement[] = [];\n\n  constructor(strokes: Set<FreehandStroke>) {\n    for (const stroke of strokes) {\n      if (stroke.group) {\n        throw new Error('a freehand stroke cannot be in more than one group');\n      }\n      stroke.group = this;\n    }\n\n    this.strokes = Array.from(strokes);\n\n    // Generate Handles\n    const points = this.strokes.flatMap(stroke => stroke.points);\n    [this.a, this.b] = farthestPair(points).map(pos =>\n      Handle.create('informal', pos, this)\n    );\n\n    // Generate transform data\n    const transform = TransformationMatrix.fromLine(\n      this.a.position,\n      this.b.position\n    ).inverse();\n\n    this.pointData = this.strokes.map(stroke =>\n      stroke.points.map(p => transform.transformPoint(p))\n    );\n  }\n\n  onHandleMoved() {\n    this.updatePaths();\n  }\n\n  private updatePaths() {\n    const transform = TransformationMatrix.fromLine(\n      this.a.position,\n      this.b.position\n    );\n\n    for (const [i, stroke] of this.strokes.entries()) {\n      const newPoints = this.pointData[i].map(p => transform.transformPoint(p));\n      stroke.updatePath(newPoints);\n    }\n  }\n\n  minDistanceFrom(pos: Position) {\n    let minDistance = Infinity;\n    for (const stroke of this.strokes) {\n      minDistance = Math.min(minDistance, stroke.minDistanceFrom(pos));\n    }\n    return minDistance;\n  }\n\n  // addStroke(stroke: FreehandStroke){\n  //   this.strokes.add(stroke);\n  //   this.dirty = true;\n\n  //   // // Generate outline shape\n  //   // //let points = rdp_simplify(stroke.points, 2)\n  //   // let shape = new ClipperShape([rdp_simplify(stroke.points, 5)], false, true, true, true)\n  //   // shape = shape.offset( 10, {\n  //   //   jointType: 'jtSquare',\n  //   //   endType: 'etOpenSquare',\n  //   //   miterLimit: 2.0,\n  //   //   roundPrecision: 0.25\n  //   // })\n\n  //   // if(this.outlineShape == null) {\n  //   //   this.outlineShape = shape\n  //   // } else {\n  //   //   this.outlineShape = this.outlineShape.union(shape);\n  //   // }\n\n  //   // // Simplify outlines\n  //   // this.outlineShape.paths = this.outlineShape.paths.map(path=>{\n  //   //   return simplify(path.map(pt=>({x: pt.X, y: pt.Y})), 10).map(pt=>({X: pt.x, Y: pt.y}))\n  //   // })\n\n  //   // //this.generateSkeleton();\n\n  // }\n\n  //   intersects(shape){\n  //     return this.outlineShape.intersect(shape).paths.length > 0;\n  //   }\n\n  private generateSkeleton() {\n    // //let sb = new SkeletonBuilder()\n    // let info = clipperShapeToArrayPoints(this.outlineShape)\n    // console.log(info);\n    // try {\n    //   const diagram = SkeletonBuilder.BuildFromGeoJSON([info]);\n    //   console.log(diagram);\n    //   this.skeleton = [];\n    //   console.log(this.outlineShape);\n    //   for(const edge of diagram.Edges) {\n    //     for (let i = 0; i < edge.Polygon.length-1; i++) {\n    //       let a = edge.Polygon[i]\n    //       let b = edge.Polygon[(i+1) % (edge.Polygon.length-1)]\n    //       if(!pointInClipperShape(this.outlineShape, a) && !pointInClipperShape(this.outlineShape, b)) {\n    //         this.skeleton.push({\n    //           a: Vec(a.X, a.Y),\n    //           b: Vec(b.X, b.Y),\n    //         })\n    //       }\n    //     }\n    //   }\n    // } catch {\n    // }\n  }\n\n  render() {\n    // if(!this.dirty) {\n    //   return\n    // }\n    // for (const elem of this.svgElements) {\n    //   elem.remove();\n    // }\n    // const outlinePath = clipperShapeToSVGPath(this.outlineShape)\n    // let skeletonPath = \"\";\n    // this.skeleton.forEach(edge=>{\n    //     skeletonPath += `M ${edge.a.x} ${edge.a.y} L ${edge.b.x} ${edge.b.y}`\n    // })\n    // this.svgElements = [\n    //   SVG.add(\"path\", {\n    //     d: outlinePath,\n    //     fill: \"rgba(0,0,0,0.05)\",\n    //     stroke: \"rgba(0,0,0,0.05)\",\n    //   }),\n    //   SVG.add(\"path\", {\n    //     d: skeletonPath,\n    //     fill: \"none\",\n    //     stroke: \"rgba(0,0,255,1)\",\n    //     \"stroke-width\": \"4\"\n    //   })\n    // ];\n    // this.dirty = false;\n  }\n\n  remove() {\n    for (const elem of this.svgElements) {\n      elem.remove();\n    }\n  }\n}\n\n// // Clipper utilities\n// function clipperShapeToPoints(shape){\n//   return shape.paths.map(path=>{\n//     return path.map(pt=>{\n//       return {x: pt.X, y: pt.Y}\n//     })\n//   })\n// }\n\n// function clipperShapeToArrayPoints(shape){\n//   return shape.paths.map(path=>{\n//     return path.map(pt=>{\n//       return [pt.X, pt.Y]\n//     })\n//   })\n// }\n\n// function shapeToSVGPath(shape){\n//   let svgPath = \"\";\n//   for(const path of shape.paths) {\n//     svgPath += `M ${path[0].x} ${path[0].y} `;\n//     for (let i = 1; i < path.length; i++) {\n//       svgPath += `L ${path[i].x} ${path[i].y} `;\n//     }\n//     svgPath += `L ${path[0].x} ${path[0].y} `;\n//   }\n//   return svgPath\n// }\n\n// function pointInClipperShape(shape, point){\n//   return shape.paths.find(path=>{\n//     return path.find(pt=>{\n//       return pt.X == point.X && pt.Y == point.Y\n//     })\n//   })\n// }\n\n// function clipperShapeToSVGPath(shape){\n//   let svgPath = \"\";\n//   for(const path of shape.paths) {\n//     svgPath += `M ${path[0].X} ${path[0].Y} `;\n//     for (let i = 1; i < path.length; i++) {\n//       svgPath += `L ${path[i].X} ${path[i].Y} `;\n//     }\n//     svgPath += `L ${path[0].X} ${path[0].Y} `;\n//   }\n//   return svgPath\n// }\n\n// // Path Simplification\n// function rdp_simplify(line, epsilon = 20) {\n//   if(line.length == 2) {\n//     return line\n//   }\n\n//   let start = line[0]\n//   let end = line[line.length-1]\n\n//   var largestDistance = -1;\n//   var furthestIndex = -1;\n\n//   for (let i = 0; i < line.length; i++) {\n//     let point = line[i]\n//     let dist = point_line_distance(point, start, end)\n//     if(dist > largestDistance) {\n//       largestDistance = dist\n//       furthestIndex = i\n//     }\n//   }\n\n//   if(largestDistance > epsilon) {\n//     let segment_a = rdp_simplify(line.slice(0,furthestIndex), epsilon)\n//     let segment_b = rdp_simplify(line.slice(furthestIndex), epsilon)\n\n//     return segment_a.concat(segment_b.slice(1))\n//   }\n//   return [start, end]\n// }\n\n// function point_line_distance(p, a, b) {\n//   let norm = scalar_projection(p, a, b)\n//   return Vec.len(Vec.sub(p,norm))\n// }\n\n// function scalar_projection(p, a, b) {\n//   let ap = Vec.sub(p, a)\n//   let ab = Vec.normalize(Vec.sub(b, a))\n//   let f = Vec.mulS(ab, Vec.dot(ap, ab))\n\n//   return Vec.add(a, f)\n// }\n\n// // Smoothing\n// function gaussianSmooth(polygon, sigma = 1) {\n//   const kernelSize = Math.ceil(3 * sigma); // Determine kernel size based on sigma\n//   const kernel = generateGaussianKernel(kernelSize, sigma);\n//   const halfKernelSize = Math.floor(kernelSize/2);\n\n//   const smoothedPolygon: any[] = [];\n\n//   for (let i = 0; i < polygon.length; i++) {\n//     let smoothedPoint = { x: 0, y: 0 };\n\n//     for (let j = -halfKernelSize; j <= halfKernelSize; j++) {\n//       const index = (i + j + polygon.length) % polygon.length;\n//       const weight = kernel[j + halfKernelSize];\n\n//       smoothedPoint.x += weight * polygon[index].x;\n//       smoothedPoint.y += weight * polygon[index].y;\n//     }\n\n//     smoothedPolygon.push(smoothedPoint);\n//   }\n\n//   return smoothedPolygon;\n// }\n\n// function generateGaussianKernel(size, sigma) {\n//   const kernel: any[] = [];\n//   const sigmaSquared = sigma * sigma;\n//   const constant = 1 / (2 * Math.PI * sigmaSquared);\n//   let sum = 0;\n\n//   for (let i = 0; i < size; i++) {\n//     const distance = i - Math.floor(size / 2);\n//     const weight = constant * Math.exp(-(distance * distance) / (2 * sigmaSquared));\n//     kernel.push(weight);\n//     sum += weight;\n//   }\n\n//   // Normalize the kernel\n//   for (let i = 0; i < size; i++) {\n//     kernel[i] /= sum;\n//   }\n\n//   return kernel;\n// }\n"],
  "mappings": "AACA;AAEA;AAGA;AAUA,iCAAiC;AAAA,EAY/B,YAAY,SAA8B;AAL1C,oBAAuB;AACvB,iBAAQ;AAER,uBAA4B;AAG1B,eAAW,UAAU,SAAS;AAC5B,UAAI,OAAO,OAAO;AAChB,cAAM,IAAI,MAAM;AAAA;AAElB,aAAO,QAAQ;AAAA;AAGjB,SAAK,UAAU,MAAM,KAAK;AAG1B,UAAM,SAAS,KAAK,QAAQ,QAAQ,YAAU,OAAO;AACrD,KAAC,KAAK,GAAG,KAAK,KAAK,aAAa,QAAQ,IAAI,SAC1C,OAAO,OAAO,YAAY,KAAK;AAIjC,UAAM,YAAY,qBAAqB,SACrC,KAAK,EAAE,UACP,KAAK,EAAE,UACP;AAEF,SAAK,YAAY,KAAK,QAAQ,IAAI,YAChC,OAAO,OAAO,IAAI,OAAK,UAAU,eAAe;AAAA;AAAA,EAIpD,gBAAgB;AACd,SAAK;AAAA;AAAA,EAGC,cAAc;AACpB,UAAM,YAAY,qBAAqB,SACrC,KAAK,EAAE,UACP,KAAK,EAAE;AAGT,eAAW,CAAC,GAAG,WAAW,KAAK,QAAQ,WAAW;AAChD,YAAM,YAAY,KAAK,UAAU,GAAG,IAAI,OAAK,UAAU,eAAe;AACtE,aAAO,WAAW;AAAA;AAAA;AAAA,EAItB,gBAAgB,KAAe;AAC7B,QAAI,cAAc;AAClB,eAAW,UAAU,KAAK,SAAS;AACjC,oBAAc,KAAK,IAAI,aAAa,OAAO,gBAAgB;AAAA;AAE7D,WAAO;AAAA;AAAA,EAoCD,mBAAmB;AAAA;AAAA,EAyB3B,SAAS;AAAA;AAAA,EA4BT,SAAS;AACP,eAAW,QAAQ,KAAK,aAAa;AACnC,WAAK;AAAA;AAAA;AAAA;",
  "names": []
}
