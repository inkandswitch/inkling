{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/Prototypes/OldInputSystem/src/app/strokes/Handle.ts"],
  "sourcesContent": ["import { Position } from '../../lib/types';\nimport { generateId } from '../../lib/helpers';\nimport Vec from '../../lib/vec';\nimport SVG from '../Svg';\nimport * as constraints from '../constraints';\n\nconst SHOW_DEBUG_INFO = false;\n\nexport interface HandleListener {\n  onHandleMoved(moved: Handle): void;\n}\n\nexport type HandleType = 'formal' | 'informal';\n\ninterface CanonicalInstanceState {\n  isCanonical: true;\n  id: number;\n  type: HandleType;\n  absorbedHandles: Set<Handle>;\n  position: Position;\n  elements: { normal: SVGElement; selected: SVGElement; label: SVGTextElement };\n  isSelected: boolean;\n  needsRerender: boolean;\n  wasRemoved: boolean;\n}\n\ninterface AbsorbedInstanceState {\n  isCanonical: false;\n  canonicalInstance: Handle;\n  origId: number;\n}\n\ntype InstanceState = CanonicalInstanceState | AbsorbedInstanceState;\n\nexport default class Handle {\n  // --- static stuff ---\n\n  // only canonical handles\n  static readonly all = new Set<Handle>();\n\n  // contains canonical and absorbed handles\n  private static readonly allInstances = new Set<Handle>();\n\n  static create(\n    type: HandleType,\n    position: Position,\n    listener: HandleListener | null = null\n  ): Handle {\n    const handle = new Handle(this.makeCanonicalInstanceState(type, position));\n    // console.trace('new handle created', handle);\n    if (listener) {\n      handle.addListener(listener);\n    }\n    handle.absorbNearbyHandles();\n    return handle;\n  }\n\n  private static makeCanonicalInstanceState(\n    type: HandleType,\n    position: Position,\n    id = generateId()\n  ): CanonicalInstanceState {\n    return {\n      isCanonical: true,\n      id,\n      type,\n      absorbedHandles: new Set(),\n      position,\n      elements: {\n        normal: SVG.add(\n          'circle',\n          type === 'formal'\n            ? { cx: 0, cy: 0, r: 3, fill: 'black' }\n            : { r: 5, fill: 'rgba(100, 100, 100, .2)' }\n        ),\n        selected: SVG.add('circle', {\n          cx: 0,\n          cy: 0,\n          r: 7,\n          fill: 'none',\n        }),\n        label: SVG.add('text', {\n          x: 0,\n          y: 0,\n          visibility: SHOW_DEBUG_INFO ? 'visible' : 'hidden',\n          content: '?',\n        }) as SVGTextElement,\n      },\n      isSelected: false,\n      needsRerender: true,\n      wasRemoved: false,\n    };\n  }\n\n  // --- instance stuff ---\n\n  private readonly listeners = new Set<HandleListener>();\n\n  private constructor(private instanceState: InstanceState) {\n    if (instanceState.isCanonical) {\n      Handle.all.add(this);\n    }\n\n    Handle.allInstances.add(this);\n  }\n\n  // methods that can be called on any handle\n\n  /**\n   * Returns this handle's id, if it's canonical,\n   * or the id of its canonical instance, if it's been absorbed.\n   */\n  get id(): number {\n    return !this.instanceState.isCanonical\n      ? this.canonicalInstance.id\n      : this.instanceState.id;\n  }\n\n  /** Returns this handle's own id, which doesn't change when the handle is absorbed. */\n  get ownId(): number {\n    return this.instanceState.isCanonical\n      ? this.instanceState.id\n      : this.instanceState.origId;\n  }\n\n  get type(): HandleType {\n    return !this.instanceState.isCanonical\n      ? this.canonicalInstance.type\n      : this.instanceState.type;\n  }\n\n  get canonicalInstance(): Handle {\n    return !this.instanceState.isCanonical\n      ? this.instanceState.canonicalInstance\n      : this;\n  }\n\n  get position(): Position {\n    return !this.instanceState.isCanonical\n      ? this.canonicalInstance.position\n      : this.instanceState.position;\n  }\n\n  set position(pos: Position) {\n    if (!this.instanceState.isCanonical) {\n      this.canonicalInstance.position = pos;\n      return;\n    }\n\n    this.instanceState.position = pos;\n    this.instanceState.needsRerender = true;\n\n    // notify listeners\n    this.notifyListeners(listener => listener.onHandleMoved(this));\n    this.notifyAbsorbedListeners((handle, listener) =>\n      listener.onHandleMoved(handle)\n    );\n  }\n\n  addListener(listener: HandleListener) {\n    this.listeners.add(listener);\n  }\n\n  select() {\n    if (!this.instanceState.isCanonical) {\n      this.canonicalInstance.select();\n      return;\n    }\n\n    this.instanceState.isSelected = true;\n    this.instanceState.needsRerender = true;\n  }\n\n  deselect() {\n    if (!this.instanceState.isCanonical) {\n      this.canonicalInstance.deselect();\n      return;\n    }\n\n    this.instanceState.isSelected = false;\n    this.instanceState.needsRerender = true;\n  }\n\n  get isSelected(): boolean {\n    return this.instanceState.isCanonical\n      ? this.instanceState.isSelected\n      : this.canonicalInstance.isSelected;\n  }\n\n  remove() {\n    if (!this.instanceState.isCanonical) {\n      this.canonicalInstance.remove();\n      return;\n    }\n\n    this.removeFromDOM();\n\n    // remove me and my absorbed handles from the set of all handles\n    Handle.allInstances.delete(this);\n    for (const handle of this.instanceState.absorbedHandles) {\n      Handle.allInstances.delete(handle);\n    }\n\n    // remove me from the set of canonical handles\n    Handle.all.delete(this);\n\n    // record that I've been removed -- this is to make debugging easier,\n    // should we ever find that some code is holding onto a removed handle\n    this.instanceState.wasRemoved = true;\n  }\n\n  absorb(that: Handle) {\n    // the absorb operation needs canonical instances!\n    if (!this.instanceState.isCanonical || !that.instanceState.isCanonical) {\n      this.canonicalInstance.absorb(that.canonicalInstance);\n      return;\n    }\n\n    if (this.instanceState.type !== that.instanceState.type) {\n      throw new Error('handle type mismatch');\n    }\n\n    // remove the absorbed canonical handle from the DOM and canonical instance set\n    that.removeFromDOM();\n    Handle.all.delete(that);\n\n    for (const handle of [that, ...that.instanceState.absorbedHandles]) {\n      // update the instance state of the absorbed handle\n      handle.instanceState = {\n        isCanonical: false,\n        canonicalInstance: this,\n        origId: handle.ownId,\n      };\n\n      // add it to my absorbed set\n      this.instanceState.absorbedHandles.add(handle);\n\n      // notify its listeners\n      handle.notifyListeners(listener => listener.onHandleMoved(that));\n    }\n\n    constraints.onHandlesReconfigured();\n  }\n\n  absorbNearbyHandles() {\n    if (!this.instanceState.isCanonical) {\n      this.canonicalInstance.absorbNearbyHandles();\n      return;\n    }\n\n    for (const that of Handle.all) {\n      if (that === this) {\n        continue;\n      }\n\n      const dist = Vec.dist(this.position, that.position);\n      if (dist < 10) {\n        this.absorb(that);\n      }\n    }\n  }\n\n  // methods that can only be called on canonical handles\n\n  get absorbedHandles(): Set<Handle> {\n    if (!this.instanceState.isCanonical) {\n      throw new Error('accessed absorbedHandles on absorbed handle');\n    }\n\n    return this.instanceState.absorbedHandles;\n  }\n\n  breakOff(handle: Handle, destination: Handle | null = null) {\n    if (!this.instanceState.isCanonical) {\n      throw new Error('called breakOff() on an absorbed handle');\n    } else if (this.instanceState.absorbedHandles.size < 1) {\n      throw new Error('called breakOff() on a singleton handle');\n    }\n\n    if (this === handle) {\n      const absorbedHandles = Array.from(this.absorbedHandles);\n\n      // promote one of my absorbed handles to a canonical handle\n      const newCanonicalInstance = absorbedHandles.pop()!;\n      newCanonicalInstance.promoteToCanonical();\n\n      // move my other absorbed handles to the new canonical handle\n      while (absorbedHandles.length > 0) {\n        const absorbedHandle = absorbedHandles.pop()!;\n        this.breakOff(absorbedHandle, newCanonicalInstance);\n      }\n\n      destination?.absorb(this);\n    } else if (this.absorbedHandles.has(handle)) {\n      handle.promoteToCanonical();\n      destination?.absorb(handle);\n    } else {\n      throw new Error('called breakOff(h) but h is unrelated to receiver');\n    }\n\n    constraints.onHandlesReconfigured();\n  }\n\n  render() {\n    const state = this.instanceState;\n\n    if (!state.isCanonical) {\n      throw new Error('called render() on absorbed handle');\n    }\n\n    if (!state.needsRerender) {\n      return;\n    }\n\n    SVG.update(state.elements.normal, {\n      transform: `translate(${state.position.x} ${state.position.y})`,\n    });\n\n    SVG.update(state.elements.selected, {\n      transform: `translate(${state.position.x} ${state.position.y})`,\n      fill: state.isSelected ? 'rgba(180, 134, 255, 0.42)' : 'none',\n    });\n\n    SVG.update(state.elements.label, {\n      transform: `translate(${\n        state.position.x - state.elements.label.getBBox().width / 2\n      } ${state.position.y - 10})`,\n      content: `${this.id}@(${Math.round(this.position.x)}, ${Math.round(\n        this.position.y\n      )})`,\n    });\n\n    state.needsRerender = false;\n  }\n\n  private removeFromDOM() {\n    if (!this.instanceState.isCanonical) {\n      throw new Error('called removeFromDOM() on absorbed handle');\n    }\n\n    this.instanceState.elements.normal.remove();\n    this.instanceState.elements.selected.remove();\n    this.instanceState.elements.label.remove();\n  }\n\n  private notifyListeners(fn: (listener: HandleListener) => void) {\n    for (const listener of this.listeners) {\n      fn(listener);\n    }\n  }\n\n  private notifyAbsorbedListeners(\n    fn: (handle: Handle, listener: HandleListener) => void\n  ) {\n    if (!this.instanceState.isCanonical) {\n      throw new Error('called  notifyAbsorbedListeners() on absorbed handle');\n    }\n\n    for (const handle of this.absorbedHandles) {\n      for (const listener of handle.listeners) {\n        fn(handle, listener);\n      }\n    }\n  }\n\n  // methods that can only be called on absorbed handles\n\n  private promoteToCanonical() {\n    if (this.instanceState.isCanonical) {\n      throw new Error('called promoteToCanonical() on canonical handle');\n    }\n\n    // remove me from my previous canonical handle\n    this.canonicalInstance.absorbedHandles.delete(this);\n\n    // change my instance state to make me a canonical handle\n    this.instanceState = Handle.makeCanonicalInstanceState(\n      this.type,\n      this.position,\n      this.instanceState.origId\n    );\n\n    // add me to the list of canonical handles\n    Handle.all.add(this);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
