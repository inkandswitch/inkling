{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/Prototypes/OldInputSystem/src/app/Snaps.ts"],
  "sourcesContent": ["import { Position } from '../lib/types';\nimport Vec from '../lib/vec';\nimport Page from './Page';\nimport SVG from './Svg';\nimport Handle from './strokes/Handle';\n\ninterface Options {\n  handleSnaps: boolean;\n  alignmentSnaps: boolean;\n}\n\nexport default class Snaps {\n  private activeSnaps: Snap[] = [];\n\n  // rendering\n  private snapSvgElementById = new Map<string, SVGElement>();\n  private needsRerender = false;\n\n  constructor(\n    private page: Page,\n    private options: Options\n  ) {}\n\n  snapPositions(transformedPositions: Map<Handle, Position>) {\n    const snaps: Snap[] = [];\n    const snapPositions = new Map<Handle, Position>();\n    const snapHandles = Array.from(Handle.all).filter(\n      h => !transformedPositions.has(h)\n    );\n    const selectedHandles = Array.from(transformedPositions.keys());\n    const connectedHandles = this.page.handlesReachableFrom(selectedHandles);\n\n    for (const [handle, transformedPosition] of transformedPositions) {\n      if (snaps.some(s => s.snapHandle === handle)) {\n        // This handle is already being used as a snap.\n        // If we move it (by snapping it to another handle), the UI feels shaky.\n        snapPositions.set(handle, transformedPosition);\n        continue;\n      }\n\n      const snapVectors: Position[] = [];\n\n      if (this.options.handleSnaps) {\n        // snap to handle\n        for (const snapHandle of snapHandles) {\n          const v = Vec.sub(snapHandle.position, transformedPosition);\n          if (Vec.len(v) < 10) {\n            snapVectors.push(v);\n            snaps.push(new HandleSnap(handle, snapHandle));\n            break;\n          }\n        }\n      }\n\n      if (this.options.alignmentSnaps && snapVectors.length === 0) {\n        // vertical alignment\n        for (const snapHandle of connectedHandles) {\n          if (snapHandle === handle) {\n            continue;\n          }\n          const dx = snapHandle.position.x - transformedPosition.x;\n          if (Math.abs(dx) < 10) {\n            const v = Vec(dx, 0);\n            snapVectors.push(v);\n            snaps.push(new AlignmentSnap(handle, snapHandle));\n            break;\n          }\n        }\n\n        // horizontal alignment\n        for (const snapHandle of connectedHandles) {\n          if (snapHandle === handle) {\n            continue;\n          }\n          const dy = snapHandle.position.y - transformedPosition.y;\n          if (Math.abs(dy) < 10) {\n            const v = Vec(0, dy);\n            snapVectors.push(v);\n            snaps.push(new AlignmentSnap(handle, snapHandle));\n            break;\n          }\n        }\n      }\n\n      const snappedPos = snapVectors.reduce(\n        (p, v) => Vec.add(p, v),\n        transformedPosition\n      );\n\n      snapPositions.set(handle, snappedPos);\n    }\n\n    this.setActiveSnaps(snaps);\n\n    return snapPositions;\n  }\n\n  private setActiveSnaps(activeSnaps: Snap[]) {\n    this.activeSnaps = activeSnaps;\n    this.needsRerender = true;\n\n    // Delete the svg elements associated w/ snaps that went away\n    const activeSnapIds = new Set(activeSnaps.map(snap => snap.id));\n    for (const [id, svgElem] of this.snapSvgElementById) {\n      if (!activeSnapIds.has(id)) {\n        svgElem.remove();\n        this.snapSvgElementById.delete(id);\n      }\n    }\n  }\n\n  clear() {\n    this.setActiveSnaps([]);\n  }\n\n  render() {\n    if (!this.needsRerender) {\n      return;\n    }\n\n    for (const snap of this.activeSnaps) {\n      const id = snap.id;\n      const { shapeType, shapeData } = snap.getShape();\n\n      let svgElem = this.snapSvgElementById.get(id);\n      if (!svgElem) {\n        svgElem = SVG.add(shapeType, {\n          ...shapeData,\n          fill: 'none',\n          stroke: 'rgb(180, 134, 255)',\n        });\n        this.snapSvgElementById.set(id, svgElem);\n      } else {\n        SVG.update(svgElem, shapeData);\n      }\n    }\n\n    this.needsRerender = false;\n  }\n}\n\ntype Shape = CircleShape | LineShape;\n\ninterface CircleShape {\n  shapeType: 'circle';\n  shapeData: {\n    cx: number;\n    cy: number;\n    r: number;\n  };\n}\n\ninterface LineShape {\n  shapeType: 'line';\n  shapeData: {\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n  };\n}\n\nabstract class Snap {\n  id: string;\n\n  constructor(\n    public handle: Handle,\n    public snapHandle: Handle\n  ) {\n    this.id = `${handle.id}.${snapHandle.id}.${this.constructor.name}`;\n  }\n\n  abstract getShape(): Shape;\n}\n\nclass HandleSnap extends Snap {\n  constructor(handle: Handle, snapHandle: Handle) {\n    super(handle, snapHandle);\n  }\n\n  getShape(): CircleShape {\n    return {\n      shapeType: 'circle',\n      shapeData: {\n        cx: this.handle.position.x,\n        cy: this.handle.position.y,\n        r: 7,\n      },\n    };\n  }\n}\n\nclass AlignmentSnap extends Snap {\n  constructor(handle: Handle, snapHandle: Handle) {\n    super(handle, snapHandle);\n  }\n\n  getShape(): LineShape {\n    return {\n      shapeType: 'line',\n      shapeData: {\n        x1: this.handle.position.x,\n        y1: this.handle.position.y,\n        x2: this.snapHandle.position.x,\n        y2: this.snapHandle.position.y,\n      },\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
