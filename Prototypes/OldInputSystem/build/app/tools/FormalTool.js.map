{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/Prototypes/OldInputSystem/src/app/tools/FormalTool.ts"],
  "sourcesContent": ["import Arc from '../../lib/arc';\nimport Fit, { ArcFit, CircleFit, LineFit } from '../../lib/fit';\nimport Line from '../../lib/line';\nimport Vec from '../../lib/vec';\nimport Page from '../Page';\nimport Snaps from '../Snaps';\nimport SVG from '../Svg';\nimport Tool from './Tool';\nimport Events from '../NativeEvents';\nimport { Position } from '../../lib/types';\nimport LineSegment from '../strokes/LineSegment';\nimport ArcSegment from '../strokes/ArcSegment';\n\nexport default class FormalTool extends Tool {\n  private readonly element: SVGElement;\n  private needsRerender = false;\n\n  // Data for guessing\n  private inputPoints?: Position[];\n  private idealPoints?: Position[];\n  private renderPoints?: Position[];\n\n  // Speed (not velocity, lol)\n  private speed = 0;\n  private maxSpeed = 0;\n  private previousPosition?: Position;\n\n  // Curve fitting\n  private mode: 'unknown' | 'guess' | 'fixed' = 'unknown'; // unknown, guess (can still change), fixed\n  private fit: LineFit | ArcFit | CircleFit | null = null;\n\n  // Fixed mode\n  private fixedStroke?: LineSegment | ArcSegment;\n\n  constructor(\n    label: string,\n    buttonX: number,\n    buttonY: number,\n    page: Page,\n    private snaps: Snaps\n  ) {\n    super(label, buttonX, buttonY, page);\n\n    this.element = SVG.add('path', {});\n    this.resetElement();\n  }\n\n  resetElement() {\n    SVG.update(this.element, { d: '', stroke: 'black', fill: 'none' });\n  }\n\n  update(events: Events) {\n    // PENCIL DOWN\n    const pencilDown = events.find('pencil', 'began');\n    if (pencilDown) {\n      this.inputPoints = [pencilDown.position];\n      this.renderPoints = [Vec.clone(pencilDown.position)];\n\n      this.speed = 0;\n      this.maxSpeed = 0;\n      this.previousPosition = pencilDown.position;\n\n      this.mode = 'unknown';\n      this.needsRerender = true;\n    }\n\n    // PENCIL MOVE\n    const pencilMoves = events.findAll('pencil', 'moved');\n    pencilMoves.forEach(pencilMove => {\n      // Compute speed\n      const newSpeed = Vec.dist(this.previousPosition!, pencilMove.position);\n      const alpha = 0.05; // Filter speed to get rid of spikes\n      this.speed = alpha * newSpeed + (1 - alpha) * this.speed;\n      this.maxSpeed = Math.max(this.maxSpeed, this.speed);\n      this.previousPosition = pencilMove.position;\n\n      // Guessing system\n      // STATES\n      if (this.mode !== 'fixed') {\n        // Add point to input buffer\n        this.inputPoints!.push(pencilMove.position);\n        this.renderPoints!.push(Vec.clone(pencilMove.position));\n\n        // Make a guess\n        if (this.mode === 'guess') {\n          this.doFit();\n        }\n      } else {\n        const updatedPosition = pencilMove.position;\n\n        const pointPositions = new Map();\n\n        if (!this.fixedStroke) {\n          // TODO(marcel): sometimes there's no fixedStroke.\n          // E.g., if you just tap on the screen so that the start and end points\n          // of a formal stroke are the same. I made a change to Fit.line that\n          // I thought would have solved this problem, but it's still happening\n          // from time to time. What do you think is the best way to fix this?\n          throw new Error('there is no fixed stroke!');\n        }\n\n        pointPositions.set(this.fixedStroke.a, this.fixedStroke.a.position);\n        pointPositions.set(this.fixedStroke.b, updatedPosition);\n\n        const snappedPositions = this.snaps.snapPositions(pointPositions);\n\n        this.fixedStroke.a.position = snappedPositions.get(this.fixedStroke.a)!;\n        this.fixedStroke.b.position = snappedPositions.get(this.fixedStroke.b)!;\n      }\n\n      // STATE TRANSITIONS\n      // If the stroke is long enough, show feedback of inital guess\n      if (this.mode === 'unknown' && this.inputPoints!.length > 100) {\n        this.mode = 'guess';\n      }\n\n      // If the user slows down, and the stroke is long enough, switch to fixed mode\n      if (\n        this.mode !== 'fixed' &&\n        this.inputPoints!.length > 10 &&\n        this.speed < Math.min(1, this.maxSpeed)\n      ) {\n        this.doFit();\n        this.createStroke();\n        this.clearGuess();\n        this.mode = 'fixed';\n      }\n\n      this.needsRerender = true;\n    });\n\n    // PENCIL UP\n    const pencilUp = events.find('pencil', 'ended');\n    if (pencilUp) {\n      if (this.mode !== 'fixed') {\n        this.doFit();\n        this.createStroke();\n        this.clearGuess();\n      }\n\n      if (!this.fixedStroke) {\n        // TODO(marcel): sometimes there's no fixedStroke.\n        // E.g., if you just tap on the screen so that the start and end points\n        // of a formal stroke are the same. I made a change to Fit.line that\n        // I thought would have solved this problem, but it's still happening\n        // from time to time. What do you think is the best way to fix this?\n        throw new Error('there is no fixed stroke!');\n      }\n\n      this.fixedStroke.a.absorbNearbyHandles();\n      this.fixedStroke.b.absorbNearbyHandles();\n\n      this.fixedStroke = undefined;\n      this.mode = 'unknown';\n\n      this.snaps.clear();\n    }\n\n    // Interpolate animation render points\n    if (\n      this.idealPoints &&\n      this.renderPoints!.length === this.idealPoints.length\n    ) {\n      for (let i = 0; i < this.idealPoints.length; i++) {\n        this.renderPoints![i] = Vec.lerp(\n          this.idealPoints[i],\n          this.renderPoints![i],\n          0.8\n        );\n      }\n    }\n  }\n\n  doFit() {\n    const lineFit = Fit.line(this.inputPoints!);\n    const arcFit = Fit.arc(this.inputPoints!);\n    const circleFit = Fit.circle(this.inputPoints!);\n\n    this.fit = lineFit;\n    if (\n      arcFit &&\n      Math.abs(Arc.directedInnerAngle(arcFit.arc)) > 0.4 * Math.PI &&\n      (!lineFit || arcFit.fitness < lineFit.fitness)\n    ) {\n      this.fit = arcFit;\n\n      if (\n        circleFit &&\n        Math.abs(Arc.directedInnerAngle(arcFit.arc)) > 1.5 * Math.PI &&\n        circleFit.circle.radius < 500 &&\n        circleFit.fitness < arcFit.fitness\n      ) {\n        this.fit = circleFit;\n      }\n    }\n\n    if (this.fit) {\n      this.updateIdeal();\n    }\n  }\n\n  // Use fitted shape to create a stroke\n  createStroke() {\n    if (!this.fit) {\n      throw new Error('createStroke() called w/ no fit!');\n    }\n\n    if (this.fit.type === 'line') {\n      const stroke = this.page.addLineSegment(this.fit.line.a, this.fit.line.b);\n      this.fixedStroke = stroke;\n    } else if (this.fit.type === 'arc') {\n      const { start, end } = Arc.points(this.fit.arc);\n      const stroke = this.page.addArcSegment(start, end, this.fit.arc.center);\n      this.fixedStroke = stroke;\n    }\n  }\n\n  clearGuess() {\n    this.inputPoints = undefined;\n    this.idealPoints = undefined;\n    this.renderPoints = undefined;\n    this.resetElement();\n  }\n\n  // Smooth animation\n  updateIdeal() {\n    if (!this.fit) {\n      throw new Error('updateIdeal() called w/ no fit!');\n    }\n\n    switch (this.fit.type) {\n      case 'line':\n        this.idealPoints = Line.spreadPointsAlong(\n          this.fit.line,\n          this.inputPoints!.length\n        );\n        break;\n      case 'arc':\n        this.idealPoints = Arc.spreadPointsAlong(\n          this.fit.arc,\n          this.inputPoints!.length\n        );\n        break;\n      case 'circle':\n        this.idealPoints = Arc.spreadPointsAlong(\n          this.fit.circle,\n          this.inputPoints!.length\n        );\n        break;\n      default:\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        throw new Error('unsupported fit type: ' + (this.fit as any).type);\n    }\n  }\n\n  render() {\n    if (!this.needsRerender) {\n      return;\n    }\n\n    if (this.renderPoints) {\n      SVG.update(this.element, { d: SVG.path(this.renderPoints) });\n    }\n\n    this.needsRerender = false;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
