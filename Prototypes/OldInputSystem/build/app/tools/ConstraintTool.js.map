{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/Prototypes/OldInputSystem/src/app/tools/ConstraintTool.ts"],
  "sourcesContent": ["import Vec from '../../lib/vec';\nimport Events from '../NativeEvents';\nimport Page from '../Page';\nimport * as constraints from '../constraints';\nimport FreehandStroke from '../strokes/FreehandStroke';\nimport StrokeGroup from '../strokes/StrokeGroup';\nimport Tool from './Tool';\nimport SVG from '../Svg';\nimport { toDegrees } from '../../lib/helpers';\nimport { Position } from '../../lib/types';\nimport Handle from '../strokes/Handle';\n\ninterface Options {\n  vertical: boolean;\n  horizontal: boolean;\n  distance: boolean;\n  angle: boolean;\n}\n\ninterface ConstraintCandidate {\n  type: 'horizontal' | 'vertical' | 'distance' | 'angle';\n  strokeGroup: StrokeGroup;\n  refStrokeGroup: StrokeGroup | null;\n}\n\ntype LastTapInfo = {\n  timestampMillis: number;\n  strokeGroup: StrokeGroup | null;\n};\n\nexport default class ConstraintTool extends Tool<FreehandStroke> {\n  private lastTapInfo: LastTapInfo = {\n    timestampMillis: 0,\n    strokeGroup: null,\n  };\n  private refStrokeGroup: StrokeGroup | null = null;\n  private readonly constraintCandidates = new Set<ConstraintCandidate>();\n  private readonly appliedCandidates = new Set<ConstraintCandidate>();\n\n  constructor(\n    label: string,\n    buttonX: number,\n    buttonY: number,\n    page: Page,\n    private options: Options\n  ) {\n    super(label, buttonX, buttonY, page, FreehandStroke);\n  }\n\n  private addStrokeGroup(p1: Position, p2: Position) {\n    const stroke = this.page.addStroke(\n      new FreehandStroke([\n        { ...p1, pressure: 1 },\n        { ...p2, pressure: 1 },\n      ])\n    );\n    return this.page.addStrokeGroup(new Set([stroke]));\n  }\n\n  onActionState: { result: constraints.Variable } | undefined = undefined;\n\n  onAction() {\n    if (!this.onActionState) {\n      const a = Handle.create('informal', { x: 100, y: 100 });\n      const { variable: ay } = constraints.property(a, 'y').variables;\n      const b = Handle.create('informal', { x: 200, y: 100 });\n      const { variable: by } = constraints.property(b, 'y').variables;\n      const { result } = (this.onActionState = constraints.formula(\n        [ay, by],\n        ([ay, by]) => ay + by\n      ).variables);\n      setInterval(() => {\n        SVG.showStatus(\n          `ay=${ay.value}, by=${by.value}, result=${result.value}`\n        );\n      }, 10);\n    } else {\n      const { result } = this.onActionState;\n      result.value = 450;\n      console.log('set result value to', result.value);\n      constraints.now.constant(result);\n      console.log('added temp constant constraint on result');\n    }\n\n    // --- formula example ---\n    // const { a, b } = this.addStrokeGroup(\n    //   { x: 100, y: 500 },\n    //   { x: 400, y: 400 }\n    // );\n    // const { variable: ax } = constraints.property(a, 'x').variables;\n    // const { result: ax2 } = constraints.formula(\n    //   [ax],\n    //   ([ax]) => ax * 2\n    // ).variables;\n    // const { variable: by } = constraints.property(b, 'y').variables;\n    // constraints.equals(by, ax2);\n\n    // --- polar vector example ---\n    // const { a: a1, b: b1 } = this.addStrokeGroup(\n    //   { x: 100, y: 500 },\n    //   { x: 400, y: 400 }\n    // );\n    // const { a: a2, b: b2 } = this.addStrokeGroup(\n    //   { x: 400, y: 400 },\n    //   { x: 500, y: 200 }\n    // );\n    // const { angle: angle1, distance: distance1 } = constraints.polarVector(\n    //   a1,\n    //   b1\n    // ).variables;\n    // const { angle: angle2, distance: distance2 } = constraints.polarVector(\n    //   a2,\n    //   b2\n    // ).variables;\n    // constraints.constant(angle1);\n    // constraints.constant(angle2);\n    // constraints.equals(distance1, distance2);\n\n    // --- length example ---\n    // let prevPos = { x: 50, y: 500 };\n    // for (let idx = 0; idx < 10; idx++) {\n    //   const nextPos = Vec.add(prevPos, {\n    //     x: 50,\n    //     y: idx % 2 === 0 ? 100 : -100,\n    //   });\n    //   const { a, b } = this.addStrokeGroup(prevPos, nextPos);\n    //   const { distance } = constraints.distance(a, b).variables;\n    //   constraints.constant(distance);\n    //   prevPos = nextPos;\n    // }\n  }\n\n  update(events: Events) {\n    super.update(events);\n\n    const fingerDown = events.find('finger', 'began');\n    if (fingerDown) {\n      this.updateLastTap(\n        this.page.findStrokeGroupNear(fingerDown.position, 40)\n      );\n    }\n\n    if (events.find('finger', 'moved')) {\n      this.onFingerMoved();\n\n      // TODO: it would be nice if a Tool could just override methods like\n      // onHandleMoved() to react to higher-level events.\n    }\n\n    if (events.find('finger', 'ended')) {\n      this.applyConstraintCandidates();\n    }\n  }\n\n  private updateLastTap(strokeGroup: StrokeGroup | null) {\n    const timestampMillis = Date.now();\n    const isDoubleTap =\n      timestampMillis - this.lastTapInfo.timestampMillis <= 150;\n    const oldStrokeGroup = this.lastTapInfo.strokeGroup;\n\n    if (isDoubleTap && strokeGroup === oldStrokeGroup) {\n      if (strokeGroup) {\n        for (const stroke of strokeGroup.strokes) {\n          stroke.deselect();\n        }\n      }\n      this.refStrokeGroup = strokeGroup;\n    }\n\n    this.lastTapInfo = { timestampMillis, strokeGroup };\n  }\n\n  private onFingerMoved() {\n    this.constraintCandidates.clear();\n    for (const strokeGroup of this.page.strokeGroups) {\n      if (strokeGroup.a.isSelected || strokeGroup.b.isSelected) {\n        this.addConstraintCandidates(strokeGroup);\n      }\n    }\n  }\n\n  private addConstraintCandidates(strokeGroup: StrokeGroup) {\n    // add constraints based on this stroke group alone\n\n    const { a, b } = strokeGroup;\n\n    const vertical =\n      this.options.vertical && Math.abs(a.position.x - b.position.x) < 5;\n    if (vertical) {\n      this.addConstraintCandidate('vertical', strokeGroup);\n    }\n\n    const horizontal =\n      this.options.horizontal && Math.abs(a.position.y - b.position.y) < 5;\n    if (horizontal) {\n      this.addConstraintCandidate('horizontal', strokeGroup);\n    }\n\n    if (strokeGroup === this.refStrokeGroup || !this.refStrokeGroup) {\n      return;\n    }\n\n    // add constraints relative to the reference stroke group\n\n    const { a: ra, b: rb } = this.refStrokeGroup;\n\n    const refDist = Vec.dist(ra.position, rb.position);\n    const dist = Vec.dist(a.position, b.position);\n    const diff = Math.abs(refDist - dist);\n    if (this.options.distance && diff < 10) {\n      this.addConstraintCandidate('distance', strokeGroup, this.refStrokeGroup);\n    }\n\n    if (this.options.angle && !vertical && !horizontal) {\n      const refAngle = toDegrees(Vec.angle(Vec.sub(rb.position, ra.position)));\n      const angle = toDegrees(Vec.angle(Vec.sub(b.position, a.position)));\n      const diff = refAngle - angle;\n      if (\n        Math.abs(diff - nearestMultiple(diff, 90)) < 1 &&\n        // ... but don't sugest nearly vertical or horizontal angles,\n        // since there are better constraints for that.\n        Math.abs(refAngle - nearestMultiple(refAngle, 90)) > 5\n      ) {\n        this.addConstraintCandidate('angle', strokeGroup, this.refStrokeGroup);\n      }\n    }\n  }\n\n  private addConstraintCandidate(\n    type: ConstraintCandidate['type'],\n    strokeGroup: StrokeGroup,\n    refStrokeGroup: StrokeGroup | null = null\n  ) {\n    for (const applied of this.appliedCandidates) {\n      if (\n        applied.type === type &&\n        applied.strokeGroup === strokeGroup &&\n        applied.refStrokeGroup === refStrokeGroup\n      ) {\n        return;\n      }\n    }\n    this.constraintCandidates.add({ type, strokeGroup, refStrokeGroup });\n  }\n\n  endStroke() {\n    const stroke = this.stroke;\n    super.endStroke();\n    this.page.addStrokeGroup(new Set([stroke!]));\n  }\n\n  render() {\n    super.render();\n\n    for (const { type, strokeGroup } of this.constraintCandidates) {\n      const { a, b } = strokeGroup;\n      switch (type) {\n        case 'vertical':\n          SVG.now('polyline', {\n            points: SVG.points([\n              { x: a.position.x, y: 0 },\n              { x: a.position.x, y: 10_000 },\n            ]),\n            stroke: 'rgba(0, 0, 255, 0.2)',\n          });\n          break;\n        case 'horizontal':\n          SVG.now('polyline', {\n            points: SVG.points([\n              { x: 0, y: a.position.y },\n              { x: 10_000, y: a.position.y },\n            ]),\n            stroke: 'rgba(0, 0, 255, 0.2)',\n          });\n          break;\n        case 'distance':\n          SVG.now('polyline', {\n            points: SVG.points([a.position, b.position]),\n            stroke: 'cornflowerblue',\n            'stroke-width': 12,\n          });\n          break;\n        case 'angle': {\n          SVG.now('polyline', {\n            points: SVG.points([\n              Vec.lerp(a.position, b.position, 10_000),\n              Vec.lerp(a.position, b.position, -10_000),\n            ]),\n            stroke: 'rgba(255, 0, 0, 0.2)',\n          });\n          const { a: ra, b: rb } = this.refStrokeGroup!;\n          SVG.now('polyline', {\n            points: SVG.points([\n              Vec.lerp(ra.position, rb.position, 10_000),\n              Vec.lerp(ra.position, rb.position, -10_000),\n            ]),\n            stroke: 'rgba(255, 0, 0, 0.2)',\n          });\n          break;\n        }\n      }\n    }\n\n    if (this.refStrokeGroup) {\n      const { a, b } = this.refStrokeGroup;\n      SVG.now('polyline', {\n        points: SVG.points([a.position, b.position]),\n        stroke: 'rgba(243, 149, 57, 0.5)',\n        'stroke-width': 12,\n      });\n    }\n  }\n\n  private applyConstraintCandidates() {\n    const ra = this.refStrokeGroup?.a;\n    const rb = this.refStrokeGroup?.b;\n\n    for (const candidate of this.constraintCandidates) {\n      // console.log('applying constraint candidate', candidate);\n      const {\n        type,\n        strokeGroup: { a, b },\n      } = candidate;\n      switch (type) {\n        case 'vertical':\n          constraints.vertical(a, b);\n          break;\n        case 'horizontal':\n          constraints.horizontal(a, b);\n          break;\n        case 'distance': {\n          constraints.equalDistance(ra!, rb!, a, b);\n          break;\n        }\n        case 'angle': {\n          constraints.fixedAngle(\n            ra!,\n            rb!,\n            a,\n            b,\n            nearestMultiple(\n              Vec.angle(Vec.sub(rb!.position, ra!.position)) -\n                Vec.angle(Vec.sub(b.position, a.position)),\n              Math.PI / 2\n            )\n          );\n          break;\n        }\n      }\n      this.appliedCandidates.add(candidate);\n    }\n    this.constraintCandidates.clear();\n  }\n}\n\nfunction nearestMultiple(n: number, m: number) {\n  return Math.round(n / m) * m;\n}\n"],
  "mappings": "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",
  "names": []
}
