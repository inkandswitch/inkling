{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/Prototypes/OldInputSystem/src/app/StrokeGraph_old.ts"],
  "sourcesContent": ["import { Position, PositionWithPressure } from '../lib/types';\nimport Vec from '../lib/vec';\nimport SVG from './Svg';\nimport FreehandStroke from './strokes/FreehandStroke';\n\n\n// A connection between two strokes\ninterface Connection {\n  strokes: FreehandStroke[];\n  indexes: number[];\n  position: Position;\n}\n\ntype Cluster = Set<FreehandStroke>;\n\n// Stroke Graph is the datastructure responsible for holding information about groupings of strokes\nexport default class StrokeGraph {\n  strokes: FreehandStroke[] = [];\n  connections: Connection[] = [];\n  elements: SVGElement[] = [];\n\n  clustersForStroke: Map<FreehandStroke, Set<Cluster>> = new Map();\n\n  private needsRerender = false;\n\n  addStroke(stroke: FreehandStroke) {\n    this.addConnectionsForStroke(stroke);\n    this.strokes.push(stroke);\n    this.needsRerender = true;\n\n    const clusters: Set<Cluster> = new Set();\n    this.clustersForStroke.set(stroke, clusters);\n  }\n\n  addClusterForStroke(stroke: FreehandStroke, cluster: Cluster) {\n    const clusters = this.clustersForStroke.get(stroke);\n    clusters?.add(cluster);\n  }\n\n  getClustersForStroke(stroke: FreehandStroke) {\n    return Array.from(this.clustersForStroke.get(stroke)!);\n  }\n\n  // Automatic clustering detection\n  addConnectionsForStroke(stroke: FreehandStroke) {\n    // Generate connections for this stroke\n    for (const otherStroke of this.strokes) {\n      const connections = findConnectionsBetweenStrokes(\n        stroke.points,\n        otherStroke.points\n      );\n\n      for (const connection of connections) {\n        this.connections.push({\n          strokes: [stroke, otherStroke],\n          indexes: connection.mid,\n          position: Vec.mulS(\n            Vec.add(\n              stroke.points[connection.mid[0]],\n              otherStroke.points[connection.mid[1]]\n            ),\n            0.5\n          ),\n        });\n      }\n    }\n\n    // Merge Close Connections\n\n    // // Compute loops for stroke\n    // let loops = this.computeLoopsForStroke(stroke);\n    // loops = loops.map(l=>new Set(l));\n    // this.clustersForStroke.get()\n  }\n  // Automatic\n  // TODO: Filter out small loops\n  computeLoopsForStroke(targetStroke: FreehandStroke) {\n    type StackEntry = { stroke: FreehandStroke; connection: Connection | null };\n    type Stack = StackEntry[];\n\n    const loops: Stack[] = [];\n\n    // Do a DFS for loops in the connections\n    const stack: Stack = [{ stroke: targetStroke, connection: null }];\n    const trace: Stack = [];\n\n    // Make sure we backtrack connections multiple times\n    const tracedConnections = new Set<Connection>();\n\n    while (stack.length > 0) {\n      console.log(\n        'stack',\n        stack.map(s => s.stroke.id)\n      );\n\n      const s = stack.pop()!;\n      trace.push(s);\n\n      const currentStroke = s.stroke;\n      if (s.connection) {\n        tracedConnections.add(s.connection);\n      }\n\n      const connections = this.connections.filter(connection => {\n        return (\n          !tracedConnections.has(connection) &&\n          connection.strokes.includes(currentStroke)\n        );\n      });\n\n      if (connections.length === 0) {\n        trace.pop();\n      }\n\n      for (const connection of connections) {\n        const other = connection.strokes.find(s => s !== currentStroke)!;\n        stack.push({ stroke: other, connection });\n\n        // reached goal\n        if (stack.length > 0 && other === targetStroke) {\n          loops.push([...trace]);\n          trace.pop();\n        }\n      }\n    }\n\n    console.log(loops);\n    return loops;\n  }\n\n  findClusterForStroke(stroke: FreehandStroke) {\n    const results = new Set();\n    results.add(stroke);\n\n    const stack = [stroke];\n\n    while (stack.length > 0) {\n      const currentStroke = stack.pop()!;\n\n      const connectedStrokes = this.connections\n        .filter(connection => connection.strokes.find(s => s === currentStroke))\n        .map(connection => connection.strokes.find(s => s !== currentStroke)!);\n\n      for (const s of connectedStrokes) {\n        if (!results.has(s)) {\n          results.add(s);\n          stack.push(s);\n        }\n      }\n    }\n\n    return Array.from(results);\n  }\n\n  findStrokeConnections(stroke: FreehandStroke) {\n    return this.connections.filter(connection =>\n      connection.strokes.find(s => s === stroke)\n    );\n  }\n\n  findConnectedStrokes(stroke: FreehandStroke) {\n    return this.connections\n      .filter(connection => connection.strokes.find(s => s === stroke))\n      .map(connection => connection.strokes.find(s => s !== stroke));\n  }\n\n  render() {\n    if (!this.needsRerender) {\n      return;\n    }\n\n    for (const elem of this.elements) {\n      elem.remove();\n    }\n\n    this.elements = this.connections.map(c => {\n      return SVG.add('circle', {\n        cx: c.position.x,\n        cy: c.position.y,\n        r: 3,\n        fill: 'pink', //c.aligned ? 'pink' : 'green',\n      });\n    });\n\n    this.needsRerender = false;\n  }\n}\n\n// TODO(marcel): come up with a better name for this.\ninterface Connection2 {\n  start: [number, number];\n  mid: [number, number];\n  end: [number, number];\n  dist: number;\n}\n\nfunction findConnectionsBetweenStrokes(\n  strokeA: PositionWithPressure[],\n  strokeB: PositionWithPressure[]\n): Connection2[] {\n  const connections: Connection2[] = [];\n\n  let currentConnection: Connection2 | null = null;\n  for (let i = 0; i < strokeA.length; i++) {\n    const closest = findClosestPointOnStroke(strokeB, strokeA[i]);\n\n    if (closest.dist < 20) {\n      if (!currentConnection) {\n        currentConnection = {\n          start: [i, closest.index],\n          end: [i, closest.index],\n          mid: [i, closest.index],\n          dist: closest.dist,\n        };\n      } else {\n        currentConnection.end = [i, closest.index];\n        if (closest.dist < currentConnection.dist) {\n          currentConnection.mid = [i, closest.index];\n          currentConnection.dist = closest.dist;\n        }\n      }\n    } else {\n      if (currentConnection) {\n        connections.push(currentConnection);\n        currentConnection = null;\n      }\n    }\n    //   const dist = Vec.dist(strokeA[i], strokeB[j]);\n    //   if (dist < minDist) {\n    //     minDist = dist;\n    //     indexA = i;\n    //     indexB = j;\n    //   }\n    // }\n  }\n\n  if (currentConnection) {\n    connections.push(currentConnection);\n  }\n\n  return connections;\n}\n\n// TODO: we can speed this up significantly if it becomes a bottleneck.\nfunction findClosestPointOnStroke(\n  stroke: PositionWithPressure[],\n  point: PositionWithPressure\n) {\n  let minDist = Vec.dist(stroke[0], point);\n  let index = 0;\n\n  for (let i = 0; i < stroke.length; i++) {\n    const dist = Vec.dist(stroke[i], point);\n    if (dist < minDist) {\n      minDist = dist;\n      index = i;\n    }\n  }\n\n  return { dist: minDist, index };\n}\n\n// --- Alex commented out these functions b/c they weren't used ---\n\n// function closestPointsBetweenStrokes(\n//   strokeA: PositionWithPressure[],\n//   strokeB: PositionWithPressure[]\n// ) {\n//   let minDist = Vec.dist(strokeA[0], strokeB[0]);\n//   let indexA = 0;\n//   let indexB = 0;\n\n//   for (let i = 0; i < strokeA.length; i++) {\n//     for (let j = 0; j < strokeB.length; j++) {\n//       const pa = strokeA[i];\n//       const pb = strokeB[j];\n//       const dist = Vec.dist(pa, pb);\n//       if (dist < minDist) {\n//         minDist = dist;\n//         indexA = i;\n//         indexB = j;\n//       }\n//     }\n//   }\n\n//   return { dist: minDist, indexA, indexB };\n// }\n\n// function getDirectionAtStrokePoint(\n//   stroke: PositionWithPressure[],\n//   index: number\n// ) {\n//   const backwardIndex = Math.max(index - 10, 0);\n//   const forwardIndex = Math.min(index + 10, stroke.length - 1);\n//   return Vec.normalize(Vec.sub(stroke[backwardIndex]!, stroke[forwardIndex]!));\n// }\n"],
  "mappings": "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",
  "names": []
}
