{
  "version": 3,
  "sources": ["../build/engine.js", "../build/lib/math.js", "../build/lib/vec.js", "../build/app/generateId.js", "../build/app/strokes/ArcSegment.js", "../build/app/strokes/LineSegment.js", "../build/app/Svg.js", "../build/app/strokes/FreehandStroke.js", "../build/app/strokes/Point.js", "../build/app/strokes/MorphPoint.js", "../build/app/strokes/StrokeGraph.js", "../build/app/Page.js", "../build/lib/transform_matrix.js", "../build/app/Snaps.js", "../build/app/ToolPicker.js", "../build/lib/arc.js", "../build/lib/line.js", "../build/lib/fit.js", "../build/app/tools/FormalTool.js", "../build/app/tools/FreehandTool.js", "../build/app/tools/TextTool.js", "../build/lib/polygon.js", "../build/app/FreehandSelection.js", "../build/app/App.js", "../build/main.js"],
  "sourcesContent": ["class Events {\n    constructor() {\n        this.events = [];\n        this.activePencil = null;\n        this.activeFingers = {};\n    }\n\n    did(type, state, id) {\n        return this.events.find(e =>\n            e.type === type && e.state === state && (id == null || e.id === id)\n        );\n    }\n    \n    didAll(type, state, id) {\n        return this.events.filter(e =>\n            e.type === type && e.state === state && (id == null || e.id === id)\n        );\n    }\n\n    didLast(type, state, id) {\n        return this.events.findLast(e =>\n            e.type === type && e.state === state && (id == null || e.id === id)\n        );\n    }\n}\n\nconst events = new Events();\n\n// Attach event listeners\nwindow.nativeEvent = (eventState, touches) => {\n    Object.entries(touches).forEach(([touchId, points]) => {\n        points.forEach(point => {\n            events.events.push({\n                type: point.type === 'pencil' ? 'pencil': 'finger',\n                state: eventState,\n                id: touchId,\n                position: { x: point.x, y: point.y },\n                timestamp: point.timestamp,\n            });\n    \n            if (point.type === 'pencil') {\n                events.activePencil =\n                    eventState !== 'ended' ?\n                        { x: point.x, y: point.y } :\n                        null;\n            } else {\n                if (eventState !== 'ended') {\n                    events.activeFingers[touchId] = { x: point.x, y: point.y };\n                } else {\n                    delete events.activeFingers[touchId];\n                }\n            }\n        });\n    });\n};\n\nlet callback = null;\n\nfunction frame() {\n    callback(events);\n    events.events = [];\n    window.requestAnimationFrame(frame);\n}\n\nexport default function engine(cb) {\n    callback = cb;\n    window.requestAnimationFrame(frame);\n}", "// Math\n// The JS Math APIs aren't great. Here's a few extras that are nice to have.\n\nexport const TAU = Math.PI * 2;\n\nexport const isZero = v => Number.EPSILON > Math.abs(v);\n\nexport const isNonZero = (v) => !isZero(v);\n\nexport const avg = (a, b) => (a + b) / 2;\n\nexport const clip = (v, min = 0, max = 1) => Math.max(min, Math.min(v, max));\n\nexport const lerpN = (input, outputMin = 0, outputMax = 1, doClip = false) => {\n  let output = input * (outputMax - outputMin) + outputMin;\n  if (doClip) {\n    output = clip(output, outputMin, outputMax);\n  }\n  return output;\n};\n\n// Prettier really screwed this one up, alas.\n// The args should be: input, inputMin, inputMax, outputMin, outputMax, doClip\nexport const lerp = (i, im = 0, iM = 1, om = 0, oM = 1, doClip = true) => {\n  if (im === iM) {\n    return om; // Avoids a divide by zero\n  }\n  if (im > iM) {\n    [im, iM, om, oM] = [iM, im, oM, om];\n  }\n  if (doClip) {\n    i = clip(i, im, iM);\n  }\n  i -= im;\n  i /= iM - im;\n  return lerpN(i, om, oM, false);\n};\n\nexport const rand = (min = -1, max = 1) => lerpN(Math.random(), min, max);\n\nexport const randInt = (min, max) => Math.round(rand(min, max));\n\nexport const roundTo = (input, precision) => {\n  // Using the reciprocal avoids floating point errors. Eg: 3/10 is fine, but 3*0.1 is wrong.\n  p = 1 / precision;\n  return Math.round(input * p) / p;\n};\n\nexport const easeInOut = (t) => {\n  const ease = t => Math.pow(t, 3);\n  return t < 0.5 ?\n    lerp(ease(t * 2), 0, 1, 0, 0.5) :\n    lerp(ease((1 - t) * 2), 1, 0, 0.5, 1);\n};", "// Vec\n// This is a port of (part of) Ivan's homemade CoffeeScript vector library.\n\nimport { isZero, roundTo } from \"./math.js\";\n\n// Constructors ///////////////////////////////////////////////////////////////\n\nconst Vec = (x = 0, y = 0) => ({ x, y });\nexport default Vec;\n\nVec.clone = v => Vec(v.x, v.y);\n\nVec.fromRectXY = r => Vec(r.x, r.y);\n\nVec.fromRectWH = r => Vec(r.w, r.h);\n\nVec.fromRectRB = r => Vec(r.x + r.w, r.y + r.h);\n\nVec.of = s => Vec(s, s);\n\nVec.random = (scale = 1) =>\n  Vec.Smul(\n    scale,\n    Vec.complement(Vec.Smul(2, Vec(Math.random(), Math.random())))\n  );\n\nVec.toA = v => [v.x, v.y];\n\nVec.polar = (angle, length) =>\n  Vec(\n    length * Math.cos(angle),\n    length * Math.sin(angle)\n  );\n\n// Static Vectors /////////////////////////////////////////////////////////////\n\nVec.x = Object.freeze(Vec(1));\nVec.y = Object.freeze(Vec(0, 1));\nVec.zero = Object.freeze(Vec());\n\n// FP /////////////////////////////////////////////////////////////////////////\n\nVec.map = (f, v) => Vec(f(v.x), f(v.y));\n\nVec.map2 = (f, a, b) =>\n  Vec(f(a.x, b.x), f(a.y, b.y));\n\nVec.reduce = (f, v) => f(v.x, v.y);\n\n// Vector Algebra /////////////////////////////////////////////////////////////\n\n// Not really cross product, but close enough\nVec.cross = (a, b) => a.x * b.y - a.y * b.x;\n\nVec.project = (a, b) =>\n  Vec.mulS(b, Vec.dot(a, b) / Vec.len2(b));\n\nVec.reject = (a, b) =>\n  Vec.sub(a, Vec.project(a, b));\n\nVec.scalarProjection = (p, a, b) => {\n  const ap = Vec.sub(p, a);\n  const ab = Vec.normalize(Vec.sub(b, a));\n  const f = Vec.mulS(ab,  Vec.dot(ap, ab));\n  return Vec.add(a, f);\n};\n\n// Piecewise Vector Arithmetic ////////////////////////////////////////////////\n\nVec.add = (a, b) => Vec(a.x + b.x, a.y + b.y);\nVec.div = (a, b) => Vec(a.x / b.x, a.y / b.y);\nVec.mul = (a, b) => Vec(a.x * b.x, a.y * b.y);\nVec.sub = (a, b) => Vec(a.x - b.x, a.y - b.y);\n\n// Vector-Scalar Arithmetic ///////////////////////////////////////////////////\n\nVec.addS = (v, s) => Vec.add(v, Vec.of(s));\nVec.divS = (v, s) => Vec.div(v, Vec.of(s));\nVec.mulS = (v, s) => Vec.mul(v, Vec.of(s));\nVec.subS = (v, s) => Vec.sub(v, Vec.of(s));\n\n// Scalar-Vector Arithmetic ///////////////////////////////////////////////////\n\nVec.Sadd = (s, v) => Vec.add(Vec.of(s), v);\nVec.Sdiv = (s, v) => Vec.div(Vec.of(s), v);\nVec.Smul = (s, v) => Vec.mul(Vec.of(s), v);\nVec.Ssub = (s, v) => Vec.sub(Vec.of(s), v);\n\n// Measurement ////////////////////////////////////////////////////////////////\n\nVec.dist = (a, b) => Vec.len(Vec.sub(a, b));\n\n// Strongly recommend using Vec.dist instead of Vec.dist2 (distance-squared)\nVec.dist2 = (a, b) => Vec.len2(Vec.sub(a, b));\n\nVec.dot = (a, b) => a.x * b.x + a.y * b.y;\n\nVec.equal = (a, b) => isZero(Vec.dist2(a, b));\n\n// Strongly recommend using Vec.len instead of Vec.len2 (length-squared)\nVec.len2 = (v) => Vec.dot(v, v);\n\nVec.len = (v) => Math.sqrt(Vec.dot(v, v));\n\n// Rounding ///////////////////////////////////////////////////////////////////\n\nVec.ceil = (v) => Vec.map(Math.ceil, v);\nVec.floor = (v) => Vec.map(Math.floor, v);\nVec.round = (v) => Vec.map(Math.round, v);\nVec.roundTo = (v, s) => Vec.map2(roundTo, v, Vec.of(s));\n\n// Variations ///////////////////////////////////////////////////////////////////\n\nVec.complement = (v) => Vec.Ssub(1, v);\nVec.half = (v) => Vec.divS(v, 2);\nVec.normalize = (v) => Vec.divS(v, Vec.len(v));\nVec.recip = (v) => Vec.Sdiv(1, v);\n\n// Prettier really screwed this one up, alas.\n// The args should be: input, inputMin, inputMax, outputMin, outputMax\nVec.renormalize = (v, im, iM, om, oM) =>\n  Vec.add(\n    Vec.mul(\n      Vec.div(\n        Vec.sub(v, im),\n        Vec.sub(iM, im)\n      ),\n      Vec.sub(oM, om)),\n    om\n  );\n\n// Combinations ///////////////////////////////////////////////////////////////////\n\nVec.avg = (a, b) => Vec.half(Vec.add(a, b));\nVec.lerp = (a, b, t) => Vec.add(a, Vec.Smul(t, Vec.sub(b, a)));\nVec.max = (a, b) => Vec.map2(Math.max, a, b);\nVec.min = (a, b) => Vec.map2(Math.min, a, b);\n\n// Reflections ///////////////////////////////////////////////////////////////////\n\nVec.abs = v => Vec.map(Math.abs, v);\nVec.invert = (v) => Vec(-v.x, -v.y);\nVec.invertX = (v) => Vec(-v.x, v.y);\nVec.invertY = (v) => Vec(v.x, -v.y);\n\n// Rotation & angles ///////////////////////////////////////////////////////////\n\n// 90 degrees clockwise\nVec.rotate90CW = (v) => Vec(v.y, -v.x);\n\n// 90 degrees counter clockwise\nVec.rotate90CCW = (v) => Vec(-v.y, v.x);\n\n// TODO(marcel): right now this module is inconsistent in the way it expects angles to work.\n// e.g., this function takes an angle in radians, whereas angleBetween uses degrees.\n// (this will help avoid confusion...)\nVec.rotate = (v, angle) =>\n  Vec(\n    v.x * Math.cos(angle) - v.y * Math.sin(angle),\n    v.x * Math.sin(angle) + v.y * Math.cos(angle)\n  );\n\n// Rotate around\nVec.rotateAround = (vector, point, angle) => {\n\n  // Translate vector to the origin\n  const translatedVector = Vec.sub(vector, point);\n  \n  const rotatedVector = Vec.rotate(translatedVector, angle);\n\n  // Translate vector back to its original position\n  return Vec.add(rotatedVector, point);\n};\n\nVec.angle = v => Math.atan2(v.y, v.x);\n\nVec.angleBetween = (a, b) => {\n  // Calculate the dot product of the two vectors\n  const dotProduct = Vec.dot(a, b);\n\n  // Calculate the magnitudes of the two vectors\n  const magnitudeA = Vec.len(a);\n  const magnitudeB = Vec.len(b);\n\n  // Calculate the angle between the vectors using the dot product and magnitudes\n  const angleInRadians = Math.acos(dotProduct / (magnitudeA * magnitudeB));\n\n  // Convert the angle from radians to degrees\n  const angleInDegrees = (angleInRadians * 180) / Math.PI;\n\n  return angleInDegrees;\n};\n\nVec.angleBetweenClockwise = (a, b) => {\n  const dP = Vec.dot(a, b);\n  const cP = Vec.cross(a, b);\n\n  const angle = Math.atan2(dP, cP);\n\n  // Convert the angle from radians to degrees\n  let angleInDegrees = angle * (180 / Math.PI);\n  if (angleInDegrees < 0) {\n    angleInDegrees = 360 + angleInDegrees;\n  }\n\n  return angleInDegrees;\n};\n\nVec.update = (a, b) => {\n  a.x = b.x;\n  a.y = b.y;\n};", "let nextId = 0;\n\nexport default function generateId() {\n    return nextId++;\n}", "import generateId from \"../generateId.js\";\nimport Vec from \"../../lib/vec.js\";\n\nexport default class ArcSegment {\n    constructor(svg, a, b, c) {\n        this.id = generateId();\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.dirty = true;\n        this.selected = false;\n\n        this.radius = Vec.dist(this.a.position, this.c.position);\n        this.isLargeArc = 0; // more than 180\n        this.clockwise = 1; // clockwise or counterclockwise\n        this.xAxisRotation = 0;\n        \n        this.updatePath();\n\n        const normalAttributes = {\n            d: this.path,\n            'stroke-width': 1,\n            stroke: 'black',\n            fill: 'none',\n        };\n        this.elements = {\n            normal: svg.addElement('path', normalAttributes),\n            selected:\n                svg.addElement(\n                    'path',\n                    {\n                        ...normalAttributes,\n                        'stroke-width': 7,\n                        stroke: 'none',\n                    }\n                ),\n        };\n    }\n\n    updatePath() {\n        //           M   start_x              start_y            A   radius_x        radius_y       x-axis-rotation,      more-than-180      clockwise         end_x                end_y\n        this.path = `M ${this.a.position.x} ${this.a.position.y} A ${this.radius}  ${this.radius} ${this.xAxisRotation} ${this.isLargeArc} ${this.clockwise} ${this.b.position.x} ${this.b.position.y}`;\n    }\n\n    select() {\n        this.dirty = true;\n        this.selected = true;\n    }\n\n    deselect() {\n        this.dirty = true;\n        this.selected = false;\n    }\n\n    render(svg) {\n        if (this.dirty || this.a.dirty || this.b.dirty || this.c.dirty) {\n            this.radius = Vec.dist(this.a.position, this.c.position);\n            this.isLargeArc = 0; // more than 180\n            this.clockwise = 1; // clockwise or counterclockwise\n            this.xAxisRotation = 0;\n\n            this.updatePath();\n            const normalAttributes = { d: this.path };\n            svg.updateElement(this.elements.normal, normalAttributes);\n            svg.updateElement(\n                this.elements.selected,\n                {\n                    ...normalAttributes,\n                    stroke: this.selected ? 'rgba(180, 134, 255, 0.42)' : 'none',\n                }\n            );\n\n            this.dirty = false;\n        }\n    }\n}", "import generateId from \"../generateId.js\";\n\nexport default class LineSegment {\n    constructor(svg, a, b) {\n        this.id = generateId();\n        this.a = a;\n        this.b = b;\n        this.dirty = true;\n        this.selected = false;\n        const normalAttributes = {\n            x1: this.a.position.x,\n            y1: this.a.position.y,\n            x2: this.b.position.x,\n            y2: this.b.position.y,\n            'stroke-width': 1,\n            stroke: 'black',\n        };\n        this.elements = {\n            normal: svg.addElement('line', normalAttributes),\n            selected:\n                svg.addElement(\n                    'line',\n                    {\n                        ...normalAttributes,\n                        'stroke-width': 7,\n                        stroke: 'none',\n                    }\n                ),\n        };\n\n    }\n\n    select() {\n        this.dirty = true;\n        this.selected = true;\n    }\n\n    deselect() {\n        this.dirty = true;\n        this.selected = false;\n    }\n\n    render(svg) {\n        if (this.dirty || this.a.dirty || this.b.dirty) {\n            const normalAttributes = {\n                x1: this.a.position.x,\n                y1: this.a.position.y,\n                x2: this.b.position.x,\n                y2: this.b.position.y,\n            };\n            svg.updateElement(this.elements.normal, normalAttributes);\n            svg.updateElement(\n                this.elements.selected,\n                {\n                    ...normalAttributes,\n                    stroke: this.selected ? 'rgba(180, 134, 255, 0.42)' : 'none',\n                }\n            );\n\n            this.dirty = false;\n        }\n    }\n}", "export default class SVG {\n    constructor(dom = document.body) {\n        this.root = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        this.updateElement(\n            this.root,\n            {\n                xmlns: 'http://www.w3.org/2000/svg',\n                width: window.innerWidth,\n                height: window.innerHeight,\n            }\n        );\n        dom.appendChild(this.root);\n    }\n\n    addElement(type, attributes) {\n        const elem = document.createElementNS('http://www.w3.org/2000/svg', type);\n        this.updateElement(elem, attributes);\n        this.root.appendChild(elem);\n        return elem;\n    }\n\n    updateElement(elem, attributes) {\n        Object.entries(attributes).forEach(\n            ([key, value]) => elem.setAttribute(key, value)\n        );\n    }\n}\n\n// TODO: maybe this should live somewhere else, tbd\nexport function generatePathFromPoints(points) {\n    const parts = points.map(\n        (p, idx) => `${idx === 0 ? 'M' : 'L'} ${p.x} ${p.y}`\n    );\n    return parts.join(' ');\n}", "import { generatePathFromPoints } from \"../Svg.js\";\nimport generateId from \"../generateId.js\";\n\nexport default class FreehandStroke {\n    constructor(svg, points) {\n        this.id = generateId();\n        this.points = points;\n        this.dirty = true;\n        this.selected = false;\n\n        const path = generatePathFromPoints(this.points);\n        this.elements = {\n            normal:\n                svg.addElement(\n                    'path',\n                    {\n                        d: path,\n                        stroke: 'darkgrey',\n                        'stroke-width': 2,\n                        fill: 'none',\n                    }\n                ),\n            selected:\n                svg.addElement(\n                    'path',\n                    {\n                        d: path,\n                        'stroke-width': 7,\n                        stroke: 'none',\n                        fill: 'none',\n                    }\n                )\n        };\n    }\n\n    getFirstPoint(){\n        return this.points[0];\n    }\n\n    getLastPoint(){\n        return this.points[this.points.length - 1];\n    }\n\n    move(position) {\n        this.dirty = true;\n        this.position = position;\n    }\n\n    select() {\n        this.dirty = true;\n        this.selected = true;\n    }\n\n    deselect() {\n        this.dirty = true;\n        this.selected = false;\n    }\n\n    render(svg) {\n        if (!this.dirty) {\n            return\n        }\n\n        const path = generatePathFromPoints(this.points);\n        svg.updateElement(\n            this.elements.normal,\n            {\n                d: path\n            }\n        );\n\n        svg.updateElement(\n            this.elements.selected,\n            {\n                d: path,\n                stroke: this.selected ? 'rgba(180, 134, 255, 0.42)' : 'none'\n            }\n        );\n\n        this.dirty = false;\n    }\n}", "import generateId from \"../generateId.js\";\n\nexport default class Point {\n    constructor(svg, position) {\n        this.id = generateId();\n        this.position = position;\n        this.dirty = true;\n        this.selected = false;\n        this.elements = {\n            normal: svg.addElement('circle', { cx: 0, cy: 0, r: 3, fill: 'black' }),\n            selected: svg.addElement('circle', { cx: 0, cy: 0, r: 7, fill: 'none' }),\n        };\n    }\n\n    setPosition(position) {\n        this.dirty = true;\n        this.position = position;\n    }\n\n    select() {\n        this.dirty = true;\n        this.selected = true;\n    }\n\n    deselect() {\n        this.dirty = true;\n        this.selected = false;\n    }\n\n    remove() {\n        this.elements.normal.remove();\n        this.elements.selected.remove();\n    }\n\n    render(svg) {\n        if (this.dirty) {\n            svg.updateElement(\n                this.elements.normal,\n                {\n                    transform: `translate(${this.position.x} ${this.position.y})`,\n                }\n            );\n\n            svg.updateElement(\n                this.elements.selected,\n                {\n                    transform: `translate(${this.position.x} ${this.position.y})`,\n                    fill: this.selected ? 'rgba(180, 134, 255, 0.42)' : 'none',\n                }\n            );\n\n            this.dirty = false;\n        }\n    }\n}", "import Vec from \"../../lib/vec.js\";\nimport generateId from \"../generateId.js\";\n\nexport default class MorphPoint {\n    constructor(svg, position) {\n        this.id = generateId();\n        this.firstPosition = position;\n        this.position = position;\n        this.morphVector = Vec(0,0);\n        this.angle = 0;\n\n        this.dirty = true;\n        this.selected = false;\n        this.elements = {\n            normal: svg.addElement('circle', { cx: 0, cy: 0, r: 30, fill: 'none', stroke: 'grey' }),\n            //ghost: svg.addElement('circle', { cx: 0, cy: 0, r: 30, fill: 'none', stroke: 'lightgrey' }),\n            //line: svg.addElement('line', { x1: 0, y1: 0, x2: 0, y2: 0, stroke: 'lightgrey' }),\n            rotationLine: svg.addElement('line', { x1: 0, y1: 0, x2: 0, y2: 0, stroke: 'grey' }),\n        };\n    }\n\n    setPosition(position) {\n        this.dirty = true;\n        this.position = position;\n        this.morphVector = Vec.sub(this.position, this.firstPosition);\n    }\n\n    select() {\n        this.dirty = true;\n        this.selected = true;\n    }\n\n    deselect() {\n        this.dirty = true;\n        this.selected = false;\n    }\n\n    remove() {\n        this.elements.normal.remove();\n        //this.elements.selected.remove();\n    }\n\n    render(svg) {\n        if (!this.dirty) {\n            return;\n        }\n\n        svg.updateElement(\n            this.elements.normal,\n            {\n                transform: `translate(${this.position.x} ${this.position.y})`,\n            }\n        );\n\n        // let rotation offset\n        const rotationOffset = Vec.add(this.position, Vec.polar(this.angle, 60));\n        svg.updateElement(\n            this.elements.rotationLine,\n            {\n                x1: this.position.x,\n                y1: this.position.y,\n                x2: rotationOffset.x,\n                y2: rotationOffset.y,\n            }\n        )\n\n        // svg.updateElement(\n        //     this.elements.ghost,\n        //     {\n        //         transform: `translate(${this.firstPosition.x} ${this.firstPosition.y})`,\n        //     }\n        // );\n\n        // svg.updateElement(\n        //     this.elements.line,\n        //     {\n        //         x1: this.position.x,\n        //         y1: this.position.y,\n        //         x2: this.firstPosition.x,\n        //         y2: this.firstPosition.y,\n        //     }\n        // );\n\n        this.dirty = false;\n    }\n}", "import Vec from \"../../lib/vec.js\";\nimport { generatePathFromPoints } from \"../Svg.js\";\n\nexport default class StrokeGraph {\n    constructor (){\n        this.strokes = [];\n        this.connections = [];\n        this.loops = [];\n        this.elements = [];\n        this.loop_elements = [];\n    }\n\n    addStroke(stroke){\n        let endPoints = [stroke.getFirstPoint(), stroke.getLastPoint()];\n\n        // Find connections with other strokes\n        for(const otherStroke of this.strokes) {\n            for(const pt of endPoints) {\n                const closestPoint = findClosestPointTo(pt, otherStroke.points);\n                if(closestPoint.dist < 20) {\n                    this.connections.push({type: \"point\", position: pt, a: stroke, b: otherStroke, ...closestPoint});\n                }\n            }\n\n            // Inverse\n            let otherEndPoints = [otherStroke.getFirstPoint(), otherStroke.getLastPoint()];\n            for(const pt of otherEndPoints) {\n                const closestPoint = findClosestPointTo(pt, stroke.points);\n                if(closestPoint.dist < 20) {\n                    this.connections.push({type: \"point\", position: pt, a: otherStroke, b: stroke, ...closestPoint});\n                }\n            }\n        }\n\n\n\n        // Do a breadth first search to find loops\n\n        console.log(\"-- search\");\n        const queue = [stroke];\n\n        const visited = new Set();\n        visited.add(stroke);\n\n        const backtrack = new Map();\n\n        let found = null\n        let otherDirection = null;\n\n        outerloop: while(queue.length > 0) {\n            let currentStroke = queue.shift();\n\n            // Find connected strokes\n            let connectedStrokes = this.connections.filter(c=>{\n                return c.a === currentStroke && backtrack.get(currentStroke) !== c.b;\n            }).map(c=>c.b);\n    \n            for(const otherStroke of connectedStrokes) {\n                if(visited.has(otherStroke)) {\n                    console.log(\"found loop by meeting in the middle\");\n                    found = otherStroke;\n                    otherDirection = currentStroke;\n                    break outerloop;\n                }\n                visited.add(otherStroke);\n                backtrack.set(otherStroke, currentStroke);\n                queue.push(otherStroke);\n            }\n        }\n        \n        if(found !== null) {\n            let currentStroke = found\n            let trace = [found]\n            while(currentStroke != stroke) {\n                currentStroke = backtrack.get(currentStroke)\n                trace.push(currentStroke)\n            }\n\n            currentStroke = otherDirection\n            trace.unshift(otherDirection)\n            while(currentStroke != stroke) {\n                currentStroke = backtrack.get(currentStroke)\n                trace.unshift(currentStroke)\n            }\n\n            //trace.pop();\n\n            let loop = [];\n            for (let i = 0; i < trace.length-1; i++) {\n                const a = trace[i];\n                const b = trace[i+1];\n                const connection = this.connections.find(c=>c.a == a && c.b == b);\n                loop.push(connection.position);\n            }\n\n            this.loops.push({\n                strokes: trace,\n                points: loop\n            });\n        }\n\n\n\n        this.strokes.push(stroke);\n        this.dirty = true;\n    }\n\n    render(svg) {\n        if(!this.dirty) {\n            return\n        }\n\n        // this.elements.forEach(elem=>elem.remove());\n\n        // this.elements = this.connections.map(c=>{\n        //     // let start = this.strokes[c.a].points[c.indexA]\n        //     // let end = this.strokes[c.b].points[c.indexB]\n        //     return svg.addElement('circle', { cx: c.position.x, cy: c.position.y, r: 3, fill: 'pink' })\n        // })\n\n        // this.loop_elements.forEach(elem=>elem.remove());\n        // this.loop_elements = this.loops.map(loop=>{\n        //     return svg.addElement('path', {d: generatePathFromPoints(loop), fill: 'rgba(255, 0, 0, 0.1)'})\n        // })\n        \n\n        this.dirty = false;\n    }\n\n}\n\nfunction findClosestPointTo(point, stroke) {\n    let minDist = Vec.dist(point, stroke[0]);\n    let index = 0;\n\n    for (let i = 0; i < stroke.length; i++) {\n        let dist = Vec.dist(point, stroke[i]);\n        if(dist < minDist) {\n            minDist = dist;\n            index = i;\n        }\n    }\n\n    return {dist: minDist, index}\n}", "import Vec from \"../lib/vec.js\";\nimport ArcSegment from \"./strokes/ArcSegment.js\";\nimport LineSegment from \"./strokes/LineSegment.js\";\nimport FreehandStroke from \"./strokes/FreehandStroke.js\";\n\nimport Point from \"./strokes/Point.js\";\nimport MorphPoint from \"./strokes/MorphPoint.js\";\nimport StrokeGraph from \"./strokes/StrokeGraph.js\";\n\nexport default class Page {\n    constructor(svg) {\n        this.svg = svg;\n        this.points = [];\n        this.morphPoints = [];\n\n        // TODO: figure out a better model for how to store different kinds of strokes\n        // For now just keep them separate, until we have a better idea of what freehand strokes look like\n        this.lineSegments = [];\n        this.freehandStrokes = [];\n\n        this.strokeGraph = new StrokeGraph();\n    }\n\n    addPoint(position) {\n        const p = new Point(this.svg, position);\n        this.points.push(p);\n        return p;\n    }\n\n    addLineSegment(a, b) {\n        const ls = new LineSegment(this.svg, a, b);\n        this.lineSegments.push(ls);\n        return ls;\n    }\n\n    addArcSegment(a, b, c) {\n        const as = new ArcSegment(this.svg, a, b, c);\n        this.lineSegments.push(as);\n        return as;\n    }\n\n    addMorphPoint(position) {\n        const p = new MorphPoint(this.svg, position);\n        this.morphPoints.push(p);\n        return p;\n    }\n\n    addFreehandStroke(points) {\n        const s = new FreehandStroke(this.svg, points);\n        this.freehandStrokes.push(s)\n        this.strokeGraph.addStroke(s);\n        return s;\n    }\n\n    findPointNear(position, dist = 20) {\n        let closestPoint = null;\n        let closestDistance = dist;\n\n        for (const point of this.points) {\n            const d = Vec.dist(point.position, position);\n            if (d < closestDistance) {\n                closestDistance = d;\n                closestPoint = point;\n            }\n        }\n        \n        return closestPoint;\n    }\n\n    findMorphPointNear(position, dist = 20) {\n        let closestPoint = null;\n        let closestDistance = dist;\n\n        for (const point of this.morphPoints) {\n            const d = Vec.dist(point.position, position);\n            if (d < closestDistance) {\n                closestDistance = d;\n                closestPoint = point;\n            }\n        }\n        \n        return closestPoint;\n    }\n\n    findFreehandStrokeNear(position, dist = 20) {\n        let closestStroke = null;\n        let closestDistance = dist;\n        for(const stroke of this.freehandStrokes) {\n            for(const point of stroke.points) {\n                const d = Vec.dist(point, position);\n                if (d < closestDistance) {\n                    closestDistance = d;\n                    closestStroke = stroke;\n                }\n            }\n        }\n\n        return closestStroke\n    }\n\n    mergePoint(point) {\n        const pointsToMerge =\n            new Set(\n                this.points.filter(\n                    p => p !== point && Vec.dist(p.position, point.position) === 0\n                )\n            );\n\n        if (pointsToMerge.size === 0) {\n            return; // avoid iterating over lines\n        }\n\n        for (const ls of this.lineSegments) {\n            if (pointsToMerge.has(ls.a)) {\n                ls.a = point;\n            }\n            if (pointsToMerge.has(ls.b)) {\n                ls.b = point;\n            }\n            if (pointsToMerge.has(ls.c)) {\n                ls.c = point;\n            }\n        }\n\n        for (const mergedPoint of pointsToMerge) {\n            mergedPoint.remove();\n        }\n        this.points = this.points.filter(p => !pointsToMerge.has(p));\n    }\n\n    pointsReachableFrom(startPoints) {\n        const reachablePoints = new Set(startPoints);\n        while (true) {\n            const oldSize = reachablePoints.size;\n            for (const ls of this.lineSegments) {\n                if (reachablePoints.has(ls.a)) {\n                    reachablePoints.add(ls.b);\n                }\n                if (reachablePoints.has(ls.b)) {\n                    reachablePoints.add(ls.a);\n                }\n            }\n            if (reachablePoints.size === oldSize) {\n                break;\n            }\n        }\n        return reachablePoints;\n    }\n\n    updateMorphs(){\n        //update rotations\n        if(this.morphPoints.length < 2) return \n        for (let i = 0; i < this.morphPoints.length; i++) {\n            const point = this.morphPoints[i];\n\n            let delta = 0;\n            let factor = 0;\n            if(i < this.morphPoints.length-1) {\n                let oldAngle = Vec.angle(Vec.sub(this.morphPoints[i+1].firstPosition, this.morphPoints[i].firstPosition))\n                let newAngle = Vec.angle(Vec.sub(this.morphPoints[i+1].position, this.morphPoints[i].position))\n                delta += newAngle - oldAngle;\n                factor +=1;\n            }\n\n            if(i > 0) {\n                let oldAngle = Vec.angle(Vec.sub(this.morphPoints[i-1].firstPosition, this.morphPoints[i].firstPosition))\n                let newAngle = Vec.angle(Vec.sub(this.morphPoints[i-1].position, this.morphPoints[i].position))\n                delta += newAngle - oldAngle\n                factor +=1;\n            }\n\n            if(factor == 2) {\n                delta = delta / 2\n            }\n\n            this.morphPoints[i].angle = delta\n            this.morphPoints[i].dirty = true\n        }\n\n        this.freehandStrokes.forEach(stroke => stroke.applyMorphs(this.morphPoints));\n    }\n\n    render(svg) {\n        const renderIt = it => it.render(svg);\n        this.lineSegments.forEach(renderIt);\n        this.freehandStrokes.forEach(renderIt);\n        this.points.forEach(renderIt);\n        this.morphPoints.forEach(renderIt);\n        this.strokeGraph.render(svg);\n    }\n}", "// Marcel's carefully written Transformation Matrix Library\n// There are three types of method:\n// Statefull transforms: that change the matrix\n// Getters: that return a value\n// Transform other things: For transforming points etc.\n\n\nimport Vec from \"./vec.js\";\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nconst RADIANS_TO_DEGREES = 180 / Math.PI;\n\nexport default class TransformationMatrix {\n  constructor() {\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.e = 0;\n    this.f = 0;\n  }\n\n  reset() {\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.e = 0;\n    this.f = 0;\n  }\n\n  // STATEFULL TRANSFORMS\n\n  transform(a2,b2,c2,d2,e2,f2) {\n    const { a: a1, b: b1, c: c1, d: d1, e: e1, f: f1 } = this;\n\n    this.a = a1 * a2 + c1 * b2;\n    this.b = b1 * a2 + d1 * b2;\n    this.c = a1 * c2 + c1 * d2;\n    this.d = b1 * c2 + d1 * d2;\n    this.e = a1 * e2 + c1 * f2 + e1;\n    this.f = b1 * e2 + d1 * f2 + f1;\n\n    return this;\n  }\n\n  rotate(angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    this.transform(cos, sin, -sin, cos, 0, 0);\n    return this;\n  }\n\n  rotateDegrees(angle) {\n\t\tthis.rotate(angle * DEGREES_TO_RADIANS);\n\t\treturn this;\n\t}\n\n  scale(sx, sy) {\n    this.transform(sx, 0, 0, sy, 0, 0);\n    return this;\n  }\n\n  skew(sx, sy) {\n\t\tthis.transform(1, sy, sx, 1, 0, 0);\n\t\treturn this;\n\t}\n\n  translate(tx, ty) {\n    this.transform(1, 0, 0, 1, tx, ty);\n    return this;\n  }\n\n  flipX() {\n    this.transform(-1, 0, 0, 1, 0, 0);\n\t\treturn this;\n  }\n\n  flipY() {\n    this.transform(1, 0, 0, -1, 0, 0);\n\t\treturn this;\n  }\n\n  inverse() {\n    const { a, b, c, d, e, f } = this;\n\n    const dt = (a * d - b * c);\n\n    this.a = d / dt;\n    this.b = -b / dt;\n    this.c = -c / dt;\n    this.d = a / dt;\n    this.e = (c * f - d * e) / dt;\n    this.f = -(a * f - b * e) / dt;\n\n    return this;\n  }\n\n\n  // GETTERS\n\n  getInverse() {\n    const { a, b, c, d, e, f } = this;\n\n    const m = new TransformationMatrix();\n    const dt = (a * d - b * c);\n\n    m.a = d / dt;\n    m.b = -b / dt;\n    m.c = -c / dt;\n    m.d = a / dt;\n    m.e = (c * f - d * e) / dt;\n    m.f = -(a * f - b * e) / dt;\n\n    return m;\n  }\n\n  getPosition() {\n    return { x: this.e, y: this.f };\n  }\n\n  getRotation() {\n    const E = (this.a + this.d) / 2;\n    const F = (this.a - this.d) / 2;\n    const G = (this.c + this.b) / 2;\n    const H = (this.c - this.b) / 2;\n\n    const a1 = Math.atan2(G, F);\n    const a2 = Math.atan2(H, E);\n\n    const phi = (a2 + a1) / 2;\n    return -phi * RADIANS_TO_DEGREES;\n  }\n\n  getScale() {\n    const E = (this.a + this.d) / 2;\n    const F = (this.a - this.d) / 2;\n    const G = (this.c + this.b) / 2;\n    const H = (this.c - this.b) / 2;\n\n    const Q = Math.sqrt(E * E + H * H);\n    const R = Math.sqrt(F * F + G * G);\n\n    return {\n      scaleX: Q + R,\n      scaleY: Q - R,\n    };\n  }\n\n  // TRANSFORM OTHER THINGS\n\n  transformMatrix(m2) {\n    const { a: a1, b: b1, c: c1, d: d1, e: e1, f: f1 } = this;\n\n    const a2 = m2.a;\n    const b2 = m2.b;\n    const c2 = m2.c;\n    const d2 = m2.d;\n    const e2 = m2.e;\n    const f2 = m2.f;\n\n    const m = new TransformationMatrix();\n    m.a = a1 * a2 + c1 * b2;\n    m.b = b1 * a2 + d1 * b2;\n    m.c = a1 * c2 + c1 * d2;\n    m.d = b1 * c2 + d1 * d2;\n    m.e = a1 * e2 + c1 * f2 + e1;\n    m.f = b1 * e2 + d1 * f2 + f1;\n\n    return m;\n  }\n\n  transformPoint(p) {\n    const { x, y } = p;\n    const { a, b, c, d, e, f } = this;\n\n    return Vec(\n      x * a + y * c + e,\n      x * b + y * d + f\n    );\n  }\n\n  transformLine(l2) {\n    return {\n      a: this.transformPoint(l2.a),\n      b: this.transformPoint(l2.b),\n    };\n  }\n\n  fromLine(a, b) {\n    const line = Vec.sub(b, a);\n\n    this.translate(a.x, a.y);\n    this.rotate(Vec.angle(line));\n\n    return this;\n  }\n}\n", "import Vec from \"../lib/vec.js\";\n\nexport default class Snaps {\n    constructor(page) {\n        this.page = page;\n        this.activeSnaps = [];\n\n        // rendering\n        this.snapSvgElementById = new Map();\n        this.dirty = false;\n    }\n\n    // returns Map<Point, snap position>\n    snapPositions(transformedPositions) {\n        const snaps = [];\n        const snapPositions = new Map();\n        const snapPoints = this.page.points.filter(p => !transformedPositions.has(p));\n        const selectedPoints = Array.from(transformedPositions.keys());\n        const connectedPoints = this.page.pointsReachableFrom(selectedPoints);\n\n        for (const [point, transformedPosition] of transformedPositions) {\n            if (snaps.some(s => s.snapPoint === point)) {\n                // This point is already being used as a snap.\n                // If we move it (by snapping it to another point), the UI feels shaky.\n                snapPositions.set(point, transformedPosition);\n                continue;\n            }\n\n            const snapVectors = [];\n\n            // snap to point\n            for (const snapPoint of snapPoints) {\n                const v = Vec.sub(snapPoint.position, transformedPosition);\n                if (Vec.len(v) < 10) {\n                    snapVectors.push(v);\n                    snaps.push(new PointSnap(point, snapPoint));\n                    break;\n                }\n            }\n\n            if (snapVectors.length === 0) {\n                // vertical alignment\n                for (const snapPoint of connectedPoints) {\n                    if (snapPoint === point) {\n                        continue;\n                    }\n                    const dx = snapPoint.position.x - transformedPosition.x;\n                    if (Math.abs(dx) < 10) {\n                        const v = Vec(dx, 0);\n                        snapVectors.push(v);\n                        snaps.push(new AlignmentSnap(point, snapPoint));\n                        break;\n                    }\n                }\n\n                // horizontal alignment\n                for (const snapPoint of connectedPoints) {\n                    if (snapPoint === point) {\n                        continue;\n                    }\n                    const dy = snapPoint.position.y - transformedPosition.y;\n                    if (Math.abs(dy) < 10) {\n                        const v = Vec(0, dy);\n                        snapVectors.push(v);\n                        snaps.push(new AlignmentSnap(point, snapPoint));\n                        break;\n                    }\n                }\n            }\n\n            const snappedPos = snapVectors.reduce(\n                (p, v) => Vec.add(p, v),\n                transformedPosition\n            );\n\n            snapPositions.set(point, snappedPos);\n        }\n\n        this.setActiveSnaps(snaps);\n\n        return snapPositions;\n    }\n\n    setActiveSnaps(activeSnaps) {\n        this.activeSnaps = activeSnaps;\n        this.dirty = true;\n\n        // Delete the svg elements associated w/ snaps that went away\n        const activeSnapIds = new Set(activeSnaps.map(snap => snap.id));\n        for (const [id, svgElem] of this.snapSvgElementById) {\n            if (!activeSnapIds.has(id)) {\n                svgElem.remove();\n                this.snapSvgElementById.delete(id);\n            }\n        }\n    }\n\n    clear() {\n        this.setActiveSnaps([]);\n    }\n\n    render(svg) {\n        if (!this.dirty) {\n            return;\n        }\n\n        for (const snap of this.activeSnaps) {\n            const id = snap.id;\n            const { shapeType, shapeData } = snap.getShape();\n            \n            let svgElem = this.snapSvgElementById.get(id);\n            if (svgElem == null) {\n                svgElem =\n                    svg.addElement(\n                        shapeType,\n                        {\n                            ...shapeData,\n                            fill: 'none',\n                            stroke: 'rgb(180, 134, 255)',\n                        }\n                    );\n                this.snapSvgElementById.set(id, svgElem);\n            } else {\n                svg.updateElement(svgElem, shapeData);\n            }\n        }\n\n        this.dirty = false;\n    }\n}\n\nclass Snap {\n    constructor(point, snapPoint) {\n        this.point = point;\n        this.snapPoint = snapPoint;\n        this.id = `${point.id}.${snapPoint.id}.${this.constructor.name}`;\n    }\n\n    getShape() {\n        throw new Error('subclass responsibility!');\n    }\n}\n\nclass PointSnap extends Snap {\n    constructor(point, snapPoint) {\n        super(point, snapPoint);\n    }\n\n    getShape() {\n        return {\n            shapeType: 'circle',\n            shapeData: {\n                cx: this.point.position.x,\n                cy: this.point.position.y,\n                r: 7,\n            },\n        };\n    }\n}\n\nclass AlignmentSnap extends Snap {\n    constructor(point, snapPoint) {\n        super(point, snapPoint);\n    }\n\n    getShape() {\n        return {\n            shapeType: 'line',\n            shapeData: {\n                x1: this.point.position.x,\n                y1: this.point.position.y,\n                x2: this.snapPoint.position.x,\n                y2: this.snapPoint.position.y,\n            },\n        };\n    }\n}", "import Vec from \"../lib/vec.js\";\n\nexport default class ToolPicker {\n    constructor(svg) {\n        this.selected = 0;\n        this.dirty = false;\n\n        this.buttons = [\n            svg.addElement('circle', { cx: 30, cy: 30, r: 20, fill: 'black' }),\n            svg.addElement('circle', { cx: 30, cy: 80, r: 20, fill: 'lightgrey' }),\n            svg.addElement('circle', { cx: 30, cy: 130, r: 20, fill: 'lightgrey' }),\n        ];\n    }\n\n    update(events) {\n        const fingerDown = events.did('finger', 'began');\n        if (!fingerDown) {\n            return;\n        }\n\n        const selected = ([30, 80, 130]).findIndex(y => Vec.dist(Vec(30, y), fingerDown.position) < 20);\n        if (selected !== -1) {\n            this.selected = selected;\n            this.dirty = true;\n        }\n    }\n\n   \n    render(svg) {\n        if (this.dirty) {\n            console.log('update');\n            this.buttons.forEach((button, i) =>\n                svg.updateElement(\n                    button,\n                    {\n                        fill: this.selected === i ? 'black' : 'lightgrey',\n                    }\n                )\n            );\n\n            this.dirty = false;\n        }\n    }\n}", "// Arc, defined by angles in radians\n\nimport Vec from \"./vec.js\";\n\nfunction Arc(center, radius, startAngle, endAngle, clockwise=true) {\n    return { center, radius, startAngle, endAngle, clockwise };\n}\n\nexport default Arc;\n\nArc.len = arc => {\n    const { radius, startAngle, endAngle } = arc;\n    \n    // Calculate the arc length using the formula: arc length = radius * angle\n    const length = radius * Math.abs(endAngle - startAngle);\n    \n    // Return the arc length\n    return length;\n};\n\nArc.distToPointCircle = (circle, point) => {\n    const distance = Vec.dist(circle.center, point);\n    return Math.abs(distance - circle.radius);\n};\n\nArc.spreadPointsAlong = (arc, n) => {\n    const points = [];\n\n    const innerAngle = Arc.directedInnerAngle(arc);\n    const angleStep = innerAngle / (n-1);\n\n    for (let i = 0; i < n; i++) {\n        const angle = arc.startAngle + angleStep * i;\n        const offset = Vec(\n            arc.radius * Math.cos(angle),\n            arc.radius * Math.sin(angle)\n        );\n        points.push(Vec.add(arc.center, offset));\n    }\n\n    return points;\n};\n\n// Computes the inner angle moving in correct direction (positive if clockwise, negative if counter clockwise)\nArc.directedInnerAngle = arc => {\n    const difference = arc.endAngle - arc.startAngle;\n    if (arc.clockwise && difference < 0) {\n        return 2 * Math.PI - Math.abs(difference);\n    } else if (!arc.clockwise && difference > 0) {\n        return -2 * Math.PI + Math.abs(difference);\n    } else {\n        return difference;\n    }\n};\n\nArc.points = arc => {\n    console.log(arc);\n\n    const start = Vec.add(arc.center, Vec.polar(arc.startAngle, arc.radius));\n    const end = Vec.add(arc.center, Vec.polar(arc.endAngle, arc.radius));\n\n    return { start, end };\n};", "// Line\n// This is a collection of functions related to line segments written by Marcel with help of ChatGPT\n\nimport Vec from \"./vec.js\";\n\nconst Line = (a, b) => {\n    return { a, b };\n};\nexport default Line;\n\nLine.len = l => Vec.dist(l.a, l.b);\n\nLine.directionVec = l => Vec.normalize(Vec.sub(l.b, l.a));\n\n// Returns intersection if the line segments overlap, or null if they don't\nLine.intersect = (l1, l2) => {\n    const { a: p1, b: p2 } = l1;\n    const { a: q1, b: q2 } = l2;\n\n    const dx1 = p2.x - p1.x;\n    const dy1 = p2.y - p1.y;\n    const dx2 = q2.x - q1.x;\n    const dy2 = q2.y - q1.y;\n\n    const determinant = dx1 * dy2 - dy1 * dx2;\n    if (determinant === 0) {\n        // The lines are parallel or coincident\n        return null;\n    }\n\n    const dx3 = p1.x - q1.x;\n    const dy3 = p1.y - q1.y;\n\n    const t = (dx3 * dy2 - dy3 * dx2) / determinant;\n    const u = (dx1 * dy3 - dy1 * dx3) / determinant;\n\n    if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n        // The segments intersect at a point\n        const intersectionX = p1.x + t * dx1;\n        const intersectionY = p1.y + t * dy1;\n        return { x: intersectionX, y: intersectionY };\n    }\n\n    // The segments do not intersect\n    return null;\n};\n\n// Always returns intersection point even if the line segments don't overlap\nLine.intersectAnywhere = (l1, l2) => {\n    const { a: p1, b: p2 } = l1;\n    const { a: q1, b: q2 } = l2;\n  \n    const dx1 = p2.x - p1.x;\n    const dy1 = p2.y - p1.y;\n    const dx2 = q2.x - q1.x;\n    const dy2 = q2.y - q1.y;\n  \n    const determinant = dx1 * dy2 - dy1 * dx2;\n  \n    if (determinant === 0) {\n      // The lines are parallel or coincident\n      return null;\n    }\n  \n    const dx3 = p1.x - q1.x;\n    const dy3 = p1.y - q1.y;\n  \n    const t = (dx3 * dy2 - dy3 * dx2) / determinant;\n    const u = (dx1 * dy3 - dy1 * dx3) / determinant;\n  \n    const intersectionX = p1.x + t * dx1;\n    const intersectionY = p1.y + t * dy1;\n  \n    return { x: intersectionX, y: intersectionY };\n};\n\n// Get point along slope\n// TODO: make this work for vertical lines, too\nLine.getYforX = (line, x) => {\n    // Extract the coordinates of points a and b\n    const { a, b } = line;\n    const { x: x1, y: y1 } = a;\n    const { x: x2, y: y2 } = b;\n    \n    // Calculate the slope of the line\n    const slope = (y2 - y1) / (x2 - x1);\n    \n    // Calculate the y-coordinate for the given x-coordinate\n    const y = slope * (x - x1) + y1;\n    \n    return y;\n};\n\n// Get point along slope\n// TODO: make this work for vertical lines, too\nLine.getXforY = (line, y) => {\n    // Extract the coordinates of points a and b\n    const { a, b } = line;\n    const { x: x1, y: y1 } = a;\n    const { x: x2, y: y2 } = b;\n\n    // Calculate the slope of the line\n    const slope = (y2 - y1) / (x2 - x1);\n\n    // Calculate the x-coordinate for the given y-coordinate\n    const x = (y - y1) / slope + x1;\n\n    return x;\n};\n\nLine.distToPoint = (line, point) => Vec.dist(point, Line.closestPoint(line, point));\n\nLine.closestPoint = (line, point, strict = true) => {\n    const { a, b } = line;\n\n    // Calculate vector AB and AP\n    const AB = Vec.sub(b, a);\n    const AP = Vec.sub(point, a);\n  \n    // Calculate the projection of AP onto AB\n    const projection = Vec.dot(AP, AB) / Vec.dot(AB, AB);\n\n    // Check if the projection is outside the line segment\n    if (strict && projection <= 0) {\n        return a;\n    } else if (strict && projection >= 1) {\n        return b;\n    } else {\n        return Vec.add(a, Vec.mulS(AB, projection));\n    }\n};\n\nLine.spreadPointsAlong = (line, n) => {\n    const segLength = Line.len(line) / n;\n    const offsetSeg = Vec.mulS(Line.directionVec(line), segLength);\n    const points = [];\n    for (let i = 0; i < n; i++) {\n        points.push(Vec.add(line.a, Vec.mulS(offsetSeg, i)))\n    }\n    return points;\n};", "import Arc from \"./arc.js\";\nimport Line from \"./line.js\";\nimport Vec from \"./vec.js\";\n\nconst Fit = {};\nexport default Fit;\n\nFit.line = stroke => {\n    if (stroke.length === 0) {\n        return null;\n    }\n\n    const line = Line(Vec.clone(stroke[0]), Vec.clone(stroke[stroke.length - 1]));\n\n    let totalDist = 0;\n    for (let i = 1; i < stroke.length - 1; i++) {\n        totalDist += Line.distToPoint(line, stroke[i]);\n    }\n\n    const lineLen = Line.len(line);\n    \n    return {\n        type: 'line',\n        line,\n        fitness: lineLen === 0 ? 1 : totalDist / lineLen,\n        length: lineLen,\n    };\n};\n\nFit.arc = points => {\n    if (points.length < 3) {\n        return null;\n    }\n\n    const simplified = Fit.innerTriangle(points);\n    const [a, b, c] = simplified;\n\n    if (!b) {\n        return null;\n    }\n\n    const { x: x1, y: y1 } = a;\n    const { x: x2, y: y2 } = b;\n    const { x: x3, y: y3 } = c;\n\n    const D = 2 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));\n    const centerX = ((x1 * x1 + y1 * y1) * (y2 - y3) + (x2 * x2 + y2 * y2) * (y3 - y1) + (x3 * x3 + y3 * y3) * (y1 - y2)) / D;\n    const centerY = ((x1 * x1 + y1 * y1) * (x3 - x2) + (x2 * x2 + y2 * y2) * (x1 - x3) + (x3 * x3 + y3 * y3) * (x2 - x1)) / D;\n    const radius = Math.sqrt((x1 - centerX) * (x1 - centerX) + (y1 - centerY) * (y1 - centerY));\n    \n    const startAngle = Math.atan2(y1 - centerY, x1 - centerX);\n    const endAngle = Math.atan2(y3 - centerY, x3 - centerX);\n\n    // Compute winding order\n    const ab = Vec.sub(a, b);\n    const bc = Vec.sub(b, c);\n    const clockwise = Vec.cross(ab, bc) > 0;\n\n    const arc = Arc(Vec(centerX, centerY), radius, startAngle, endAngle, clockwise);\n\n    // Compute fitness\n    const arcDist = Arc.len(arc);\n    \n    let totalDist = 0;\n    for (const p of points) {\n        totalDist += Arc.distToPointCircle(arc, p);\n    }\n\n    return {\n        type: 'arc',\n        arc,\n        fitness: totalDist / arcDist,\n        length: arcDist,\n    };\n}\n\nFit.innerTriangle = points => {\n    const start = points[0];\n    const end = points[points.length - 1];\n\n    let largestDistance = -1;\n    let farthestIndex = -1;\n    \n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      const dist = Line.distToPoint(Line(start, end), point);\n      if (dist > largestDistance) {\n        largestDistance = dist;\n        farthestIndex = i;\n      }\n    }\n\n    return [start, points[farthestIndex], end];\n};\n\nFit.circle = points => {\n    if (points.length < 3) {\n        return null;\n    }\n\n    // Do a basic circular regression\n    const n = points.length;\n    let sumX = 0;\n    let sumY = 0;\n    let sumX2 = 0;\n    let sumY2 = 0;\n    let sumXY = 0;\n    let sumX3 = 0;\n    let sumY3 = 0;\n    let sumXY2 = 0;\n    let sumX2Y = 0;\n\n    for (const point of points) {\n        const { x, y } = point;\n        sumX += x;\n        sumY += y;\n        sumX2 += x * x;\n        sumY2 += y * y;\n        sumXY += x * y;\n        sumX3 += x * x * x;\n        sumY3 += y * y * y;\n        sumXY2 += x * y * y;\n        sumX2Y += x * x * y;\n    }\n\n    const C = n * sumX2 - sumX * sumX;\n    const D = n * sumXY - sumX * sumY;\n    const E = n * sumX3 + n * sumXY2 - (sumX2 + sumY2) * sumX;\n    const G = n * sumY2 - sumY * sumY;\n    const H = n * sumX2Y + n * sumY3 - (sumX2 + sumY2) * sumY;\n\n    const a = (H * D - E * G) / (C * G - D * D);\n    const b = (H * C - E * D) / (D * D - G * C);\n    const c = -(a * sumX + b * sumY + sumX2 + sumY2) / n;\n\n    // Construct circle\n    const center = Vec(-a / 2, -b / 2);\n    const radius = Math.sqrt(center.x * center.x + center.y * center.y - c);\n\n    // Compute angles\n    const startAngle = Math.atan2(points[0].y - center.y, points[0].x - center.x);\n    const endAngle = Math.atan2(points[points.length - 1].y - center.y, points[points.length - 1].x - center.x);\n\n    // Determine winding order\n    // Compute winding order\n    const ab = Vec.sub(points[0], points[1]);\n    const bc = Vec.sub(points[1], points[2]);\n    const clockwise = Vec.cross(ab, bc) > 0;\n\n    const circle  = { center, radius, startAngle, endAngle, clockwise };\n\n    // check fitness\n    let totalDist = 0\n    for (const p of points) {\n        totalDist += Arc.distToPointCircle(circle, p);\n    }\n\n    const circumference = 2 * Math.PI * radius;\n\n    return { \n        type: 'circle',\n        circle,\n        fitness: totalDist / circumference,\n    };\n};", "import Arc from \"../../lib/arc.js\";\nimport Fit from \"../../lib/fit.js\";\nimport Line from \"../../lib/line.js\";\nimport Vec from \"../../lib/vec.js\";\nimport { generatePathFromPoints } from \"../Svg.js\";\n\nexport default class FormalTool {\n    constructor(page, snaps) {\n        this.page = page;\n        this.snaps = snaps;\n\n        // Svg rendering\n        this.element = null;\n\n        // Data for guessing\n        this.inputPoints = null;\n        this.idealPoints = null;\n        this.renderPoints = null;\n\n        // Speed (not velocity, lol)\n        this.speed = 0;\n        this.maxSpeed = 0;\n        this.previousPosition = null;\n\n        // Curve fitting\n        this.mode = 'unknown'; // unknown, guess, can still change, fixed\n        this.fit = null;\n\n        // Fixed mode\n        this.fixedStroke = null;\n    }\n\n    update(events) {\n        // PENCIL DOWN\n        const pencilDown = events.did('pencil', 'began');\n        if (pencilDown) {\n            this.inputPoints = [pencilDown.position];\n            this.renderPoints = [Vec.clone(pencilDown.position)];\n\n            this.speed = 0;\n            this.maxSpeed = 0;\n            this.previousPosition = pencilDown.position;\n\n            this.mode = 'unknown';\n            this.dirty = true;\n        }\n\n        // PENCIL MOVE\n        const pencilMoves = events.didAll('pencil', 'moved');\n        pencilMoves.forEach(pencilMove => {\n            // Compute speed\n            const newSpeed = Vec.dist(this.previousPosition, pencilMove.position);\n            const alpha = 0.05; // Filter speed to get rid of spikes\n            this.speed = alpha * newSpeed + (1 - alpha) * this.speed;\n            this.maxSpeed = Math.max(this.maxSpeed, this.speed);\n            this.previousPosition = pencilMove.position;\n\n            // Guessing system\n            // STATES\n            if (this.mode !== 'fixed') {\n                // Add point to input buffer\n                this.inputPoints.push(pencilMove.position);\n                this.renderPoints.push(Vec.clone(pencilMove.position));\n\n                // Make a guess\n                if (this.mode === 'guess') {\n                    this.doFit();\n                }\n            } else {\n                let updatedPosition = pencilMove.position;\n                \n                let pointPositions = new Map();\n\n                // TODO(marcel): sometimes there's no fixedStroke.\n                // E.g., if you just tap on the screen so that the start and end points\n                // of a formal stroke are the same. I made a change to Fit.line that\n                // I thought would have solved this problem, but it's still happening\n                // from time to time. What do you think is the best way to fix this?\n                pointPositions.set(this.fixedStroke.a, this.fixedStroke.a.position);\n                pointPositions.set(this.fixedStroke.b, updatedPosition);\n                \n                let snappedPositions = this.snaps.snapPositions(pointPositions);\n\n                this.fixedStroke.a.setPosition(snappedPositions.get(this.fixedStroke.a));\n                this.fixedStroke.b.setPosition(snappedPositions.get(this.fixedStroke.b));\n            }\n\n            // STATE TRANSITIONS\n            // If the stroke is long enough, show feedback of inital guess\n            if (this.mode === 'unknown' && this.inputPoints.length > 100) {\n                this.mode = 'guess';\n            }\n\n            // If the user slows down, and the stroke is long enough, switch to fixed mode\n            if (\n                this.mode !== 'fixed' &&\n                this.inputPoints.length > 10 &&\n                this.speed < Math.min(1, this.maxSpeed)\n            ) {\n                this.doFit();\n                this.createStroke();\n                this.clearGuess();\n                this.mode = 'fixed';\n            }\n\n            this.dirty = true;\n        })\n\n        // PENCIL UP\n        const pencilUp = events.did('pencil', 'ended');\n        if (pencilUp) {\n            if (this.mode !== 'fixed') {\n                this.doFit();\n                this.createStroke();\n                this.clearGuess();\n            }\n\n            this.page.mergePoint(this.fixedStroke.a);\n            this.page.mergePoint(this.fixedStroke.b);\n            \n            this.fixedStroke = null;\n            this.mode = 'unknown';\n\n            this.snaps.clear();\n        }\n\n        // Interpolate animation render points\n        if (this.idealPoints && this.renderPoints.length === this.idealPoints.length) {\n            for (let i = 0; i < this.idealPoints.length; i++) {\n                this.renderPoints[i] = Vec.lerp(this.idealPoints[i], this.renderPoints[i], 0.8);\n            }\n        }\n    }\n\n    doFit() {\n        const lineFit = Fit.line(this.inputPoints);\n        const arcFit = Fit.arc(this.inputPoints);\n        const circleFit = Fit.circle(this.inputPoints);\n\n        this.fit = lineFit;\n        if (\n            arcFit != null &&\n            Math.abs(Arc.directedInnerAngle(arcFit.arc)) > 0.4 * Math.PI &&\n            (lineFit == null || arcFit.fitness < lineFit.fitness)\n        ) {\n            this.fit = arcFit;\n\n            if (\n                circleFit != null &&\n                Math.abs(Arc.directedInnerAngle(arcFit.arc)) > 1.5 * Math.PI &&\n                circleFit.circle.radius < 500 &&\n                circleFit.fitness < arcFit.fitness\n            ) {\n                this.fit = circleFit;\n            }\n        }\n        \n        if (this.fit != null) {\n            this.updateIdeal();\n        }\n    }\n\n    // Use fitted shape to create a stroke\n    createStroke() {\n        if (this.fit.type === 'line') {\n            const a = this.page.addPoint(this.fit.line.a);\n            const b = this.page.addPoint(this.fit.line.b);\n            const stroke = this.page.addLineSegment(a, b);\n            this.fixedStroke = stroke;\n        } else if (this.fit.type === 'arc') {\n            const {start, end} = Arc.points(this.fit.arc)\n            const a = this.page.addPoint(start);\n            const b = this.page.addPoint(end);\n            const c = this.page.addPoint(this.fit.arc.center);\n            const stroke = this.page.addArcSegment(a, b, c);\n            this.fixedStroke = stroke;\n        }\n    }\n\n    clearGuess() {\n        this.inputPoints = null;\n        this.idealPoints = null;\n        this.renderPoints = null;\n        this.element.remove();\n        this.element = null;\n    }\n\n    // Smooth animation\n    updateIdeal() {\n        if (this.fit.type === 'line') {\n            this.idealPoints = Line.spreadPointsAlong(this.fit.line, this.inputPoints.length);\n        } else if (this.fit.type === 'arc') {\n            this.idealPoints = Arc.spreadPointsAlong(this.fit.arc, this.inputPoints.length);\n        } else if (this.fit.type === 'circle') {\n            this.idealPoints = Arc.spreadPointsAlong(this.fit.circle, this.inputPoints.length);\n        }\n    }\n\n    render(svg) {\n        if (!this.dirty) {\n            return;\n        }\n\n        if (this.renderPoints) {\n            if (!this.element) {\n                this.element =\n                    svg.addElement(\n                        'path',\n                        {\n                            d: '',\n                            stroke: 'black',\n                            fill: 'none'\n                        }\n                    );\n            }\n\n            const path = generatePathFromPoints(this.renderPoints);\n            svg.updateElement(this.element, { d: path });\n        }\n\n        this.dirty = false;\n    }\n}", "import { generatePathFromPoints } from \"../Svg.js\";\n\nexport default class FreehandTool {\n    constructor(page, svg) {\n        this.page = page;\n        this.points = null;\n        this.element =\n            svg.addElement(\n                'path',\n                {\n                    d: '',\n                    stroke: 'darkgrey',\n                    'stroke-width': 2,\n                    fill: 'none',\n                }\n            );\n        this.dirty = false;\n    }\n\n    update(events) {\n        const pencilDown = events.did('pencil', 'began');\n        if (pencilDown != null) {\n            this.startStroke(pencilDown.position);\n        }\n\n        if (this.points == null) {\n            return;\n        }\n\n        const pencilMoves = events.didAll('pencil', 'moved');\n        pencilMoves.forEach(pencilMove => this.extendStroke(pencilMove.position));\n\n        const pencilUp = events.did('pencil', 'ended');\n        if (pencilUp != null) {\n            this.endStroke();\n        }\n    }\n\n    startStroke(position) {\n        this.points = [position];\n        this.dirty = true;\n    }\n\n    extendStroke(position) {\n        this.points.push(position);\n        this.dirty = true;\n    }\n\n    endStroke() {\n        this.page.addFreehandStroke(this.points);\n        this.points = null;\n        this.dirty = true;\n    }\n\n    render(svg) {\n        if (!this.dirty) {\n            return;\n        }\n\n        const path = this.points == null ? '' : generatePathFromPoints(this.points);\n        svg.updateElement(this.element, { d: path });\n\n        this.dirty = false;\n    }\n}", "export default class TextTool {\n    constructor(page, svg) {\n        this.page = page;\n        this.svg = svg;\n        this.points = [];\n        this.element = null;\n    }\n\n    update(events) {\n        const pencilDown = events.did('pencil', 'began');\n        if (pencilDown) {\n            this.points = [pencilDown.position];\n        }\n\n        const pencilMove = events.did('pencil', 'moved');\n        if (pencilMove) {\n            this.points.push(pencilMove.position);\n        }\n\n        const pencilUp = events.did('pencil', 'ended');\n        if (pencilUp) {\n \n        }\n    }\n\n    render(svg) {\n\n    }\n}", "export default function Polygon(points){\n    return points\n}\n\n// Ray intersection algorithm\nPolygon.isPointInside = (polygon, point)=>{\n    const x = point.x;\n    const y = point.y;\n    let isInside = false;\n  \n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n      const xi = polygon[i].x;\n      const yi = polygon[i].y;\n      const xj = polygon[j].x;\n      const yj = polygon[j].y;\n  \n      const intersect = ((yi > y) !== (yj > y)) &&\n                        (x < ((xj - xi) * (y - yi)) / (yj - yi) + xi);\n  \n      if (intersect) {\n        isInside = !isInside;\n      }\n    }\n  \n    return isInside;\n}", "import Polygon from \"../lib/polygon.js\"\nimport Vec from \"../lib/vec.js\"\nimport { generatePathFromPoints } from \"./Svg.js\"\n\nexport default class FreehandSelection {\n    constructor(page) {\n        this.page = page\n        this.strokes = new Set()\n\n        this.finger = null\n        this.fingerMoved = null\n        this.holding = null\n\n        this.lastFingerDown = 0\n\n        this.downPositions = new Map()\n\n        this.selectPolygon = null;\n        this.dirty = false;\n        this.polygon = null;\n    }\n\n    update(events) {\n        const fingerDown = events.did('finger', 'began');\n        if (fingerDown) {\n            setTimeout(_=>{\n                if(this.finger && !this.holding && (!this.fingerMoved || Vec.dist(this.finger.position, this.fingerMoved.position) < 20)) {\n                    console.log(\"hold\");\n                    this.selectPolygon = [this.finger.position];\n                    this.dirty = true;\n                }\n            }, 500)\n\n            this.lastFingerDown = fingerDown.timestamp;\n            this.finger = fingerDown\n            let found = this.page.findFreehandStrokeNear(fingerDown.position)\n            if(found) {\n                if(found == this.holding) {\n                    \n                    // Check if connected to any loops\n                    let loop = this.page.strokeGraph.loops.find(loop=>{\n                        return loop.strokes.find(s=>s==found)\n                    })\n                    if(loop) {\n                        loop.strokes.forEach(l=>this.select(l))\n                    }\n                } else {\n                    this.holding = found\n                    this.select(found)\n                }\n                \n            } else {\n                this.holding = null\n                // Check if tapped inside enclosed region\n                let loop = this.page.strokeGraph.loops.find(loop=>{\n                    return Polygon.isPointInside(loop.points, fingerDown.position)\n                })\n                if(loop) {\n                    loop.strokes.forEach(l=>this.select(l))\n                    this.holding = loop.strokes[0]\n\n                    // Find strokes inside polygon\n                    for(const stroke of this.page.freehandStrokes) {\n                        for(const point of stroke.points) {\n                            if(Polygon.isPointInside(loop.points, point)) {\n                                this.select(stroke);\n                                continue;\n                            }\n                        }\n                    }    \n                }\n            }\n        }\n\n        if(this.finger) {\n            const fingerMove = events.did('finger', 'moved', this.finger.id)\n            if(fingerMove) {\n                this.fingerMoved = fingerMove\n\n                if(this.selectPolygon) {\n                    let lastPoint = this.selectPolygon[this.selectPolygon.length-1];\n                    if(Vec.dist(lastPoint, fingerMove.position) > 5) {\n                        this.selectPolygon.push(fingerMove.position);\n                        this.dirty = true;\n\n                        // update selection\n                        this.clearSelection();\n                        // Find strokes inside polygon\n                        for(const stroke of this.page.freehandStrokes) {\n                            for(const point of stroke.points) {\n                                if(Polygon.isPointInside(this.selectPolygon, point)) {\n                                    this.select(stroke);\n                                    this.holding = stroke;\n                                    continue;\n                                }\n                            }\n                        }\n\n                    }\n                } else {\n                    let delta = Vec.sub(fingerMove.position, this.finger.position)\n                    for(const stroke of this.strokes) {\n                        const downPositions = this.downPositions.get(stroke)\n                        for (let i = 0; i < stroke.points.length; i++) {\n                            stroke.points[i] = Vec.add(downPositions[i], delta);\n                            stroke.dirty = true;\n                        }\n                    }\n                }\n            }\n\n            const fingerUp = events.did('finger', 'ended', this.finger.id)\n            if(fingerUp && !this.holding) {\n                this.clearSelection()\n                this.finger = null\n                this.fingerMoved = null\n            }\n\n            if(fingerUp){\n                this.selectPolygon = null\n                this.dirty = true\n            }\n        }\n\n\n    }\n\n    select(stroke){\n        this.strokes.add(stroke);\n        stroke.select();\n        this.downPositions.set(stroke, stroke.points.map(p=>({...p})));\n    }\n\n    clearSelection(){\n        for(const stroke of this.strokes) {\n            stroke.deselect();\n        }\n\n        this.strokes = new Set();\n        this.downPositions = new Map();\n    }\n\n    render(svg) {\n        if(!this.dirty) {\n            return;\n        }\n\n        if(!this.selectPolygon && this.polygon) {\n            this.polygon.remove();\n            this.polygon = null;\n        } \n        \n        if(this.selectPolygon){\n            let path = generatePathFromPoints(this.selectPolygon);\n            if(!this.polygon) {\n                this.polygon = svg.addElement(\n                    'path',\n                    {\n                        d: path,\n                        stroke: 'pink',\n                        'stroke-width': 2,\n                        fill: 'rgba(255, 0, 0, 0.05)',\n                    }\n                )\n            } else {\n                svg.updateElement(\n                    this.polygon, {d: path}\n                )\n            }\n        }\n\n        \n\n        this.dirty = false;\n    }\n\n}", "//import Canvas from \"./Canvas\";\nimport Morphing from \"./Morphing.js\";\nimport Page from \"./Page.js\";\nimport Selection from \"./Selection.js\";\nimport Snaps from \"./Snaps.js\";\nimport SVG from \"./Svg.js\";\nimport ToolPicker from \"./ToolPicker.js\";\nimport FormalTool from \"./tools/FormalTool.js\";\nimport FreehandTool from \"./tools/FreehandTool.js\";\nimport TextTool from \"./tools/TextTool.js\";\n\nimport MorphPhysics from \"./MorphPhysics.js\";\nimport FreehandSelection from \"./FreehandSelection.js\";\n\nexport default class App {\n    constructor() {\n        this.svg = new SVG();\n        this.page = new Page(this.svg);\n                \n        this.snaps = new Snaps(this.page);\n\n\n        // this.selection = new Selection(this.page, this.snaps);\n        this.selection = new FreehandSelection(this.page);\n\n        //this.morphing = new Morphing(this.page);\n\n        this.toolPicker = new ToolPicker(this.svg);\n\n        this.tools = [\n            new FreehandTool(this.page, this.svg),\n            new FormalTool(this.page, this.snaps),\n            new TextTool(this.page),\n        ];\n\n        //this.morphPhysics = new MorphPhysics(this.svg);\n\n        // Setup text canvas\n        // let a = this.page.addPoint({x: 100, y: 100});\n        // let b = this.page.addPoint({x: 200, y: 200});\n        // let c = this.page.addPoint({x: 200, y: 100});\n        // this.page.addPoint({x: 300, y: 300});\n        // this.page.addPoint({x: 400, y: 400});\n\n        // this.page.addLineSegment(a, b);\n        // this.page.addLineSegment(b, c);\n        // this.page.addLineSegment(c, a);\n\n        \n        // let ca = this.page.addPoint({x: 600, y: 100});\n        // let cb = this.page.addPoint({x: 500, y: 200});\n        // let cc = this.page.addPoint({x: 500, y: 100});\n\n        // this.page.addArcSegment(ca, cb, cc);\n    }\n\n    update(events) {\n        this.toolPicker.update(events);\n        this.tools[this.toolPicker.selected].update(events);\n\n        //this.morphing.update(events);\n        this.selection.update(events);\n        //this.morphPhysics.update(events);\n    }\n\n    render() {\n        this.toolPicker.render(this.svg);\n        this.tools[this.toolPicker.selected].render(this.svg);\n        this.snaps.render(this.svg);\n        this.page.render(this.svg);\n\n        this.selection.render(this.svg);\n\n        //this.morphPhysics.render(this.svg);\n    }\n}", "import engine from \"./engine.js\";\nimport App from \"./app/App.js\";\n\nconst app = new App();\n\nengine(events => {\n  app.update(events);\n  app.render();\n});"],
  "mappings": "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",
  "names": []
}
