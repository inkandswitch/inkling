{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/InkbaseV2/src/app/Input.ts"],
  "sourcesContent": ["import {\n  closeFormulaEditor,\n  pencilFormulaEditor,\n  tapFormulaLabel,\n} from './gestures/FormulaEditor';\nimport Events, { Event, TouchId, wasRecentlyUpdated } from './NativeEvents';\nimport { EventContext, Gesture } from './gestures/Gesture';\nimport { touchHandle } from './gestures/Handle';\nimport { touchMetaToggle } from './gestures/MetaToggle';\nimport { touchToken, scrubNumberToken } from './gestures/Token';\nimport { drawInk } from './gestures/DrawInk';\nimport { createWire } from './gestures/CreateWire';\nimport { tapPropertyPicker } from './gestures/PropertyPicker';\nimport SVG from './Svg';\nimport { createGizmo } from './gestures/CreateGizmo';\nimport { touchGizmo } from './gestures/Gizmo';\nimport Config from './Config';\nimport { erase } from './gestures/Erase';\nimport { toggleHandles } from './gestures/ToggleHandles';\nimport { toggleWire } from './gestures/ToggleWire';\nimport { createFormula } from './gestures/CreateFormula';\n\nconst gestureCreators = {\n  finger: [\n    closeFormulaEditor,\n    scrubNumberToken,\n    tapPropertyPicker,\n    touchToken,\n    touchHandle,\n    touchMetaToggle,\n    touchGizmo,\n    toggleWire,\n    toggleHandles,\n  ],\n  pencil: [\n    erase,\n    createGizmo,\n    tapPropertyPicker,\n    tapFormulaLabel,\n    pencilFormulaEditor,\n    createWire,\n    createFormula,\n    drawInk,\n  ],\n};\n\nconst pseudoTouches: Record<TouchId, Event> = {};\nconst gesturesByTouchId: Record<TouchId, Gesture> = {};\n\n// This function is called by NativeEvent (via App) once for every event sent from Swift.\nexport function applyEvent(ctx: EventContext) {\n  // Before we begin, we need to reap any touches that haven't been updated in a while,\n  // because we don't always receive the \"ended\".\n  if (Config.gesture.reapTouches) {\n    for (const id in pseudoTouches) {\n      if (!wasRecentlyUpdated(pseudoTouches[id])) {\n        delete pseudoTouches[id];\n      }\n    }\n    for (const id in gesturesByTouchId) {\n      if (!wasRecentlyUpdated(gesturesByTouchId[id])) {\n        delete gesturesByTouchId[id];\n      }\n    }\n  }\n\n  // Terminology:\n  // Event \u2014 a single finger or pencil event sent to us from Swift, either \"began\", \"moved\", or \"ended\".\n  // Touch \u2014 a series of finger or pencil events (from \"began\" to \"ended) with a consistent TouchId.\n  // Gesture \u2014 a class instance that \"claims\" one or more touches and then receives all their events.\n  // Gesture Creator \u2014 a function that looks at a \"began\" event to decide whether to create a new Gesture for it.\n  // Pseudo \u2014 a finger touch that's not claimed by any gesture\n  // Pseudo Gesture \u2014 a gesture that's only created when some pseudo touches exist.\n\n  // Key Assumption #1: The pencil will always match a gesture.\n  // Key Assumption #2: A finger will always match a gesture or become a pseudo.\n\n  // STEP ZERO \u2014 Update existing pseudo touches, or prepare pseudo-related state.\n  if (pseudoTouches[ctx.event.id]) {\n    if (ctx.event.state === 'ended') {\n      delete pseudoTouches[ctx.event.id];\n    } else {\n      pseudoTouches[ctx.event.id] = ctx.event;\n    }\n    return;\n  }\n  ctx.pseudoTouches = pseudoTouches;\n  ctx.pseudoCount = Object.keys(pseudoTouches).length + ctx.events.forcePseudo;\n  ctx.pseudo = ctx.pseudoCount > 0;\n\n  // STEP ONE \u2014 Try to match this event to a gesture that previously claimed this touch.\n  const gestureForTouch = gesturesByTouchId[ctx.event.id];\n  if (gestureForTouch) {\n    runGesture(gestureForTouch, ctx);\n    if (ctx.event.state === 'ended') {\n      delete gesturesByTouchId[ctx.event.id];\n    }\n    return;\n  }\n\n  // Key Assumption #3: every touch is claimed by a gesture or pseudo right from the \"began\".\n  // So if we didn't match an existing gesture/pseudo above, and the event isn't a \"began\", we're done.\n  if (ctx.event.state !== 'began') {\n    return;\n  }\n\n  // STEP TWO \u2014 see if any existing gestures want to claim this new touch.\n  // (There's no sense of priority here; gestures are checked in creation order. Might need to revise this.)\n  for (const id in gesturesByTouchId) {\n    const gesture = gesturesByTouchId[id];\n    if (gesture.claimsTouch(ctx)) {\n      gesturesByTouchId[ctx.event.id] = gesture;\n      runGesture(gesture, ctx);\n      return;\n    }\n  }\n\n  // STEP THREE \u2014 try to create a new gesture for this touch.\n  for (const gestureCreator of gestureCreators[ctx.event.type]) {\n    const gesture = gestureCreator(ctx);\n    if (gesture) {\n      gesturesByTouchId[ctx.event.id] = gesture;\n      runGesture(gesture, ctx);\n      return;\n    }\n  }\n\n  // STEP FOUR \u2014 track this touch as a candidate for a pseudo-mode.\n  if (ctx.event.type === 'finger') {\n    pseudoTouches[ctx.event.id] = ctx.event;\n    return;\n  }\n\n  // If we made it here and the touch hasn't been handled\u2026 so be it.\n}\n\nfunction runGesture(gesture: Gesture, ctx: EventContext) {\n  const result = gesture.applyEvent(ctx);\n\n  if (result instanceof Gesture) {\n    // Replace the old gesture with the new gesture\n    for (const id in gesturesByTouchId) {\n      if (gesturesByTouchId[id] === gesture) {\n        gesturesByTouchId[id] = result;\n      }\n    }\n    // Run the new gesture immediately\n    runGesture(result, ctx);\n  }\n}\n\nexport function render() {\n  for (const id in gesturesByTouchId) {\n    gesturesByTouchId[id].render();\n  }\n\n  if (Config.gesture.debugVisualization) {\n    for (const id in gesturesByTouchId) {\n      gesturesByTouchId[id].debugRender();\n    }\n\n    for (const id in pseudoTouches) {\n      const event = pseudoTouches[id];\n      SVG.now('circle', {\n        class: 'pseudo-touch',\n        cx: event.position.x,\n        cy: event.position.y,\n        r: 8,\n      });\n    }\n  }\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAM,kBAAkB;AAAA,EACtB,QAAQ;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA,EAEF,QAAQ;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIJ,MAAM,gBAAwC;AAC9C,MAAM,oBAA8C;AAG7C,2BAAoB,KAAmB;AAG5C,MAAI,OAAO,QAAQ,aAAa;AAC9B,eAAW,MAAM,eAAe;AAC9B,UAAI,CAAC,mBAAmB,cAAc,MAAM;AAC1C,eAAO,cAAc;AAAA;AAAA;AAGzB,eAAW,MAAM,mBAAmB;AAClC,UAAI,CAAC,mBAAmB,kBAAkB,MAAM;AAC9C,eAAO,kBAAkB;AAAA;AAAA;AAAA;AAiB/B,MAAI,cAAc,IAAI,MAAM,KAAK;AAC/B,QAAI,IAAI,MAAM,UAAU,SAAS;AAC/B,aAAO,cAAc,IAAI,MAAM;AAAA,WAC1B;AACL,oBAAc,IAAI,MAAM,MAAM,IAAI;AAAA;AAEpC;AAAA;AAEF,MAAI,gBAAgB;AACpB,MAAI,cAAc,OAAO,KAAK,eAAe,SAAS,IAAI,OAAO;AACjE,MAAI,SAAS,IAAI,cAAc;AAG/B,QAAM,kBAAkB,kBAAkB,IAAI,MAAM;AACpD,MAAI,iBAAiB;AACnB,eAAW,iBAAiB;AAC5B,QAAI,IAAI,MAAM,UAAU,SAAS;AAC/B,aAAO,kBAAkB,IAAI,MAAM;AAAA;AAErC;AAAA;AAKF,MAAI,IAAI,MAAM,UAAU,SAAS;AAC/B;AAAA;AAKF,aAAW,MAAM,mBAAmB;AAClC,UAAM,UAAU,kBAAkB;AAClC,QAAI,QAAQ,YAAY,MAAM;AAC5B,wBAAkB,IAAI,MAAM,MAAM;AAClC,iBAAW,SAAS;AACpB;AAAA;AAAA;AAKJ,aAAW,kBAAkB,gBAAgB,IAAI,MAAM,OAAO;AAC5D,UAAM,UAAU,eAAe;AAC/B,QAAI,SAAS;AACX,wBAAkB,IAAI,MAAM,MAAM;AAClC,iBAAW,SAAS;AACpB;AAAA;AAAA;AAKJ,MAAI,IAAI,MAAM,SAAS,UAAU;AAC/B,kBAAc,IAAI,MAAM,MAAM,IAAI;AAClC;AAAA;AAAA;AAMJ,oBAAoB,SAAkB,KAAmB;AACvD,QAAM,SAAS,QAAQ,WAAW;AAElC,MAAI,kBAAkB,SAAS;AAE7B,eAAW,MAAM,mBAAmB;AAClC,UAAI,kBAAkB,QAAQ,SAAS;AACrC,0BAAkB,MAAM;AAAA;AAAA;AAI5B,eAAW,QAAQ;AAAA;AAAA;AAIhB,yBAAkB;AACvB,aAAW,MAAM,mBAAmB;AAClC,sBAAkB,IAAI;AAAA;AAGxB,MAAI,OAAO,QAAQ,oBAAoB;AACrC,eAAW,MAAM,mBAAmB;AAClC,wBAAkB,IAAI;AAAA;AAGxB,eAAW,MAAM,eAAe;AAC9B,YAAM,QAAQ,cAAc;AAC5B,UAAI,IAAI,UAAU;AAAA,QAChB,OAAO;AAAA,QACP,IAAI,MAAM,SAAS;AAAA,QACnB,IAAI,MAAM,SAAS;AAAA,QACnB,GAAG;AAAA;AAAA;AAAA;AAAA;",
  "names": []
}
