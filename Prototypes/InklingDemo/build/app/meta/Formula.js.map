{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/InkbaseV2/src/app/meta/Formula.ts"],
  "sourcesContent": ["import Token, { aToken } from './Token';\nimport SVG from '../Svg';\nimport Vec from '../../lib/vec';\nimport NumberToken, { aNumberToken } from './NumberToken';\nimport OpToken from './OpToken';\nimport EmptyToken, { anEmptyToken } from './EmptyToken';\nimport WritingCell, { aWritingCell } from './WritingCell';\nimport { GameObject } from '../GameObject';\nimport FormulaCompiler from './FormulaCompiler';\nimport LabelToken from './LabelToken';\nimport PropertyPicker from './PropertyPicker';\nimport { Position, Removable } from '../../lib/types';\nimport { EventContext } from '../gestures/Gesture';\nimport { clip } from '../../lib/math';\n\nconst PADDING = 3;\n\n// TODO:\n// We're computing the amount of writing cell super ad-hoc right now\n// Can be improved significiantly if we have a better interface\n\nexport default class Formula extends Token {\n  maxHp = 120;\n  hp = this.maxHp;\n\n  static createFromContext(ctx: EventContext, token?: Token) {\n    const formula = new Formula();\n    ctx.page.adopt(formula);\n    if (token) {\n      formula.adopt(token);\n    }\n\n    formula.edit();\n    formula.position = ctx.event.position;\n    return formula;\n  }\n\n  readonly height = 30 + PADDING * 2;\n\n  protected readonly boxElement = SVG.add('rect', SVG.metaElm, {\n    x: this.position.x,\n    y: this.position.y,\n    width: this.width,\n    height: this.height,\n    rx: 3,\n    class: 'parsed-formula',\n  });\n\n  private constraint: Removable | null = null;\n\n  isPrimary() {\n    return false;\n  }\n\n  edit() {\n    // remove existing constraint\n    if (this.constraint) {\n      this.constraint.remove();\n      this.constraint = null;\n    }\n\n    // create new empty spaces\n    this.adopt(new EmptyToken());\n    this.adopt(new EmptyToken());\n    this.adopt(new EmptyToken());\n    this.adopt(new EmptyToken());\n\n    // Toggle embedded numbers\n    for (const numberToken of this.findAll({ what: aNumberToken })) {\n      numberToken.refreshEditValue();\n    }\n\n    // Toggle mode\n    this.editing = true;\n    this.updateCells();\n  }\n\n  close() {\n    if (!this.editing) {\n      return;\n    }\n\n    const tokens = this.findAll({ what: aToken });\n    const filteredTokens = tokens.filter(t => !(t instanceof EmptyToken));\n\n    if (filteredTokens.length === 0) {\n      this.editing = false;\n      this.remove();\n      return;\n    }\n\n    // Detach single token formulas\n    if (filteredTokens.length === 1) {\n      const firstToken = tokens[0];\n      firstToken.embedded = false;\n      firstToken.editing = false;\n      if (firstToken instanceof NumberToken) {\n        firstToken.refreshValue();\n      }\n      this.page.adopt(firstToken);\n      this.editing = false;\n      this.remove();\n      return;\n    }\n\n    // Find if there is an =\n    const equalsIndex = filteredTokens.findIndex(\n      token => token instanceof OpToken && token.stringValue === '='\n    );\n    if (equalsIndex < 0) {\n      this.adopt(new OpToken('='));\n      this.adopt(new NumberToken());\n    } else if (equalsIndex === filteredTokens.length - 1) {\n      this.adopt(new NumberToken());\n    }\n\n    for (const numberToken of this.findAll({ what: aNumberToken })) {\n      numberToken.refreshValue();\n    }\n\n    // Compile the formula\n    const compiler = new FormulaCompiler(this.page);\n    const newFormulaConstraint = compiler.compile(this.getFormulaAsText());\n    if (!newFormulaConstraint) {\n      // Don't close the editor\n      return;\n    }\n\n    this.constraint = newFormulaConstraint;\n    this.discardEmptyTokens();\n\n    this.editing = false;\n    this.updateCells();\n  }\n\n  discardEmptyTokens() {\n    const emptyTokens = this.findAll({ what: anEmptyToken });\n    for (const token of emptyTokens) {\n      token.remove();\n    }\n  }\n\n  updateCells() {\n    if (!this.editing) {\n      for (const cell of this.findAll({ what: aWritingCell })) {\n        cell.remove();\n      }\n      return;\n    }\n\n    let totalCellCount = 0;\n    for (const token of this.findAll({ what: aToken })) {\n      totalCellCount +=\n        token instanceof NumberToken ? token.editValue.length : 1;\n    }\n\n    const currentCells = this.findAll({ what: aWritingCell });\n\n    console.log(currentCells.length, totalCellCount);\n    console.log(currentCells);\n\n    if (currentCells.length < totalCellCount) {\n      const diff = totalCellCount - currentCells.length;\n      for (let i = 0; i < diff; i++) {\n        this.adopt(new WritingCell());\n      }\n    } else if (currentCells.length > totalCellCount) {\n      const diff = currentCells.length - totalCellCount;\n      for (let i = 0; i < diff; i++) {\n        const cell = currentCells.pop();\n        cell?.remove();\n      }\n    }\n  }\n\n  layoutCells() {\n    if (!this.editing) {\n      return;\n    }\n\n    const cells = this.findAll({ what: aWritingCell });\n    for (const token of this.findAll({ what: aToken })) {\n      if (token instanceof NumberToken) {\n        for (let i = 0; i < token.editValue.length; i++) {\n          const cell = cells.shift();\n          if (cell) {\n            cell.position = Vec.add(token.position, {\n              x: (24 + PADDING) * i,\n              y: 0,\n            });\n          }\n        }\n      } else {\n        const cell = cells.shift();\n        if (cell) {\n          cell.position = token.position;\n          cell.width = token.width;\n        }\n      }\n    }\n  }\n\n  getFormulaAsText() {\n    const formula = [];\n    for (const token of this.findAll({ what: aToken })) {\n      if (token instanceof OpToken) {\n        formula.push(token.stringValue);\n      } else if (token instanceof NumberToken) {\n        formula.push('@' + token.id);\n      } else if (token instanceof LabelToken) {\n        formula.push('#' + token.id);\n      } else if (token instanceof PropertyPicker) {\n        formula.push('!' + token.id);\n      } else if (token instanceof EmptyToken) {\n        // NO-OP\n      } else {\n        throw new Error(\n          'unexpected token type in formula: ' + token.constructor.name\n        );\n      }\n    }\n    return formula.join(' ');\n  }\n\n  updateWritingCells() {\n    const tokens = this.findAll({ what: aToken });\n    let tokenIndex = 0;\n    let token = tokens[tokenIndex];\n    let offsetInsideToken = -1;\n\n    const cells = this.findAll({ what: aWritingCell });\n\n    for (const cell of cells) {\n      // Step forward through tokens\n      offsetInsideToken += 1;\n\n      const tokenSize =\n        token instanceof NumberToken ? token.editValue.length : 1;\n\n      if (offsetInsideToken === tokenSize) {\n        offsetInsideToken = 0;\n        tokenIndex += 1;\n        token = tokens[tokenIndex];\n      }\n\n      if (cell.stringValue !== '') {\n        // Handle all tokenizations\n        // If it's a number token and\n        if (token instanceof NumberToken) {\n          if (isNumeric(cell.stringValue)) {\n            token.updateCharAt(offsetInsideToken, cell.stringValue);\n          } else {\n            // Split this number token\n            const start = token.editValue.slice(0, offsetInsideToken);\n            const end = token.editValue.slice(offsetInsideToken + 1);\n            token.editValue = start;\n            tokens.splice(tokenIndex + 1, 0, new OpToken(cell.stringValue));\n            if (end !== '') {\n              const numToken = new NumberToken();\n              numToken.editValue = end;\n              tokens.splice(tokenIndex + 2, 0, numToken);\n            }\n          }\n        } else if (token instanceof EmptyToken || token instanceof OpToken) {\n          if (isNumeric(cell.stringValue)) {\n            const prev = tokens[tokenIndex - 1];\n            const next = tokens[tokenIndex + 1];\n            if (prev instanceof NumberToken) {\n              prev.addChar(cell.stringValue);\n              // Merge two number tokens\n              if (next instanceof NumberToken) {\n                prev.editValue += next.editValue;\n                tokens[tokenIndex].remove();\n                tokens[tokenIndex + 1].remove();\n                tokens.splice(tokenIndex, 2);\n              } else {\n                tokens[tokenIndex].remove();\n                tokens.splice(tokenIndex, 1);\n                tokens.push(new EmptyToken());\n              }\n            } else {\n              const numToken = new NumberToken();\n              numToken.addChar(cell.stringValue);\n              tokens[tokenIndex].remove();\n              tokens[tokenIndex] = numToken;\n              tokens.push(new EmptyToken());\n            }\n          } else {\n            const opToken = new OpToken(cell.stringValue);\n            tokens[tokenIndex].remove();\n            tokens[tokenIndex] = opToken;\n            tokens.push(new EmptyToken());\n          }\n        }\n\n        cell.stringValue = '';\n\n        for (const t of tokens) {\n          this.adopt(t);\n        }\n\n        this.updateCells();\n      }\n    }\n  }\n\n  insertInto(emptyToken: EmptyToken, newToken: Token) {\n    const tokens = this.findAll({ what: aToken });\n    const idx = tokens.indexOf(emptyToken);\n    if (idx < 0) {\n      throw new Error('bad call to Formula.insertInto()');\n    }\n    tokens.splice(idx, 0, newToken);\n    newToken.editing = true;\n\n    // update the order of the children in this game object\n    for (const t of tokens) {\n      this.adopt(t);\n    }\n\n    this.updateCells();\n  }\n\n  render(dt: number, t: number): void {\n    // Heal\n    this.hp = clip(this.hp + 1, 0, this.maxHp);\n    SVG.update(this.boxElement, {\n      opacity: this.hp / this.maxHp,\n    });\n\n    // Process input\n    if (this.editing) {\n      this.updateWritingCells();\n    }\n\n    // Layout child tokens in horizontal sequence\n    let nextTokenPosition = Vec.add(this.position, Vec(PADDING, PADDING));\n    for (const token of this.findAll({ what: aToken })) {\n      token.position = nextTokenPosition;\n\n      token.embedded = true;\n      token.editing = this.editing;\n\n      nextTokenPosition = Vec.add(\n        nextTokenPosition,\n        Vec(token.width + PADDING, 0)\n      );\n    }\n\n    this.width = nextTokenPosition.x - this.position.x;\n\n    // Update box wrapper\n    if (this.children.size === 0) {\n      SVG.update(this.boxElement, {\n        x: this.position.x,\n        y: this.position.y,\n        width: 0,\n      });\n      this.width -= PADDING * 2;\n    } else {\n      SVG.update(this.boxElement, {\n        x: this.position.x,\n        y: this.position.y,\n        width: this.width,\n      });\n    }\n\n    // Move cells\n    this.layoutCells();\n\n    // render children\n    for (const child of this.children) {\n      child.render(dt, t);\n    }\n  }\n\n  erase(position: Position) {\n    // TODO: erase cell at position\n  }\n\n  remove() {\n    this.boxElement.remove();\n    for (const child of this.children) {\n      child.remove();\n    }\n    super.remove();\n  }\n}\n\nfunction isNumeric(v: string) {\n  return '0' <= v && v <= '9';\n}\n\nexport const aFormula = (gameObj: GameObject) =>\n  gameObj instanceof Formula ? gameObj : null;\n"],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA,MAAM,UAAU;AAMhB,qCAAqC,MAAM;AAAA,EAA3C,cArBA;AAqBA;AACE,iBAAQ;AACR,cAAK,KAAK;AAcD,kBAAS,KAAK,UAAU;AAEd,sBAAa,IAAI,IAAI,QAAQ,IAAI,SAAS;AAAA,MAC3D,GAAG,KAAK,SAAS;AAAA,MACjB,GAAG,KAAK,SAAS;AAAA,MACjB,OAAO,KAAK;AAAA,MACZ,QAAQ,KAAK;AAAA,MACb,IAAI;AAAA,MACJ,OAAO;AAAA;AAGD,sBAA+B;AAAA;AAAA,SAvBhC,kBAAkB,KAAmB,OAAe;AACzD,UAAM,UAAU,IAAI;AACpB,QAAI,KAAK,MAAM;AACf,QAAI,OAAO;AACT,cAAQ,MAAM;AAAA;AAGhB,YAAQ;AACR,YAAQ,WAAW,IAAI,MAAM;AAC7B,WAAO;AAAA;AAAA,EAgBT,YAAY;AACV,WAAO;AAAA;AAAA,EAGT,OAAO;AAEL,QAAI,KAAK,YAAY;AACnB,WAAK,WAAW;AAChB,WAAK,aAAa;AAAA;AAIpB,SAAK,MAAM,IAAI;AACf,SAAK,MAAM,IAAI;AACf,SAAK,MAAM,IAAI;AACf,SAAK,MAAM,IAAI;AAGf,eAAW,eAAe,KAAK,QAAQ,CAAE,MAAM,gBAAiB;AAC9D,kBAAY;AAAA;AAId,SAAK,UAAU;AACf,SAAK;AAAA;AAAA,EAGP,QAAQ;AACN,QAAI,CAAC,KAAK,SAAS;AACjB;AAAA;AAGF,UAAM,SAAS,KAAK,QAAQ,CAAE,MAAM;AACpC,UAAM,iBAAiB,OAAO,OAAO,OAAK,CAAE,cAAa;AAEzD,QAAI,eAAe,WAAW,GAAG;AAC/B,WAAK,UAAU;AACf,WAAK;AACL;AAAA;AAIF,QAAI,eAAe,WAAW,GAAG;AAC/B,YAAM,aAAa,OAAO;AAC1B,iBAAW,WAAW;AACtB,iBAAW,UAAU;AACrB,UAAI,sBAAsB,aAAa;AACrC,mBAAW;AAAA;AAEb,WAAK,KAAK,MAAM;AAChB,WAAK,UAAU;AACf,WAAK;AACL;AAAA;AAIF,UAAM,cAAc,eAAe,UACjC,WAAS,iBAAiB,WAAW,MAAM,gBAAgB;AAE7D,QAAI,cAAc,GAAG;AACnB,WAAK,MAAM,IAAI,QAAQ;AACvB,WAAK,MAAM,IAAI;AAAA,eACN,gBAAgB,eAAe,SAAS,GAAG;AACpD,WAAK,MAAM,IAAI;AAAA;AAGjB,eAAW,eAAe,KAAK,QAAQ,CAAE,MAAM,gBAAiB;AAC9D,kBAAY;AAAA;AAId,UAAM,WAAW,IAAI,gBAAgB,KAAK;AAC1C,UAAM,uBAAuB,SAAS,QAAQ,KAAK;AACnD,QAAI,CAAC,sBAAsB;AAEzB;AAAA;AAGF,SAAK,aAAa;AAClB,SAAK;AAEL,SAAK,UAAU;AACf,SAAK;AAAA;AAAA,EAGP,qBAAqB;AACnB,UAAM,cAAc,KAAK,QAAQ,CAAE,MAAM;AACzC,eAAW,SAAS,aAAa;AAC/B,YAAM;AAAA;AAAA;AAAA,EAIV,cAAc;AACZ,QAAI,CAAC,KAAK,SAAS;AACjB,iBAAW,QAAQ,KAAK,QAAQ,CAAE,MAAM,gBAAiB;AACvD,aAAK;AAAA;AAEP;AAAA;AAGF,QAAI,iBAAiB;AACrB,eAAW,SAAS,KAAK,QAAQ,CAAE,MAAM,UAAW;AAClD,wBACE,iBAAiB,cAAc,MAAM,UAAU,SAAS;AAAA;AAG5D,UAAM,eAAe,KAAK,QAAQ,CAAE,MAAM;AAE1C,YAAQ,IAAI,aAAa,QAAQ;AACjC,YAAQ,IAAI;AAEZ,QAAI,aAAa,SAAS,gBAAgB;AACxC,YAAM,OAAO,iBAAiB,aAAa;AAC3C,eAAS,IAAI,GAAG,IAAI,MAAM,KAAK;AAC7B,aAAK,MAAM,IAAI;AAAA;AAAA,eAER,aAAa,SAAS,gBAAgB;AAC/C,YAAM,OAAO,aAAa,SAAS;AACnC,eAAS,IAAI,GAAG,IAAI,MAAM,KAAK;AAC7B,cAAM,OAAO,aAAa;AAC1B,cAAM;AAAA;AAAA;AAAA;AAAA,EAKZ,cAAc;AACZ,QAAI,CAAC,KAAK,SAAS;AACjB;AAAA;AAGF,UAAM,QAAQ,KAAK,QAAQ,CAAE,MAAM;AACnC,eAAW,SAAS,KAAK,QAAQ,CAAE,MAAM,UAAW;AAClD,UAAI,iBAAiB,aAAa;AAChC,iBAAS,IAAI,GAAG,IAAI,MAAM,UAAU,QAAQ,KAAK;AAC/C,gBAAM,OAAO,MAAM;AACnB,cAAI,MAAM;AACR,iBAAK,WAAW,IAAI,IAAI,MAAM,UAAU;AAAA,cACtC,GAAI,MAAK,WAAW;AAAA,cACpB,GAAG;AAAA;AAAA;AAAA;AAAA,aAIJ;AACL,cAAM,OAAO,MAAM;AACnB,YAAI,MAAM;AACR,eAAK,WAAW,MAAM;AACtB,eAAK,QAAQ,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA,EAM3B,mBAAmB;AACjB,UAAM,UAAU;AAChB,eAAW,SAAS,KAAK,QAAQ,CAAE,MAAM,UAAW;AAClD,UAAI,iBAAiB,SAAS;AAC5B,gBAAQ,KAAK,MAAM;AAAA,iBACV,iBAAiB,aAAa;AACvC,gBAAQ,KAAK,MAAM,MAAM;AAAA,iBAChB,iBAAiB,YAAY;AACtC,gBAAQ,KAAK,MAAM,MAAM;AAAA,iBAChB,iBAAiB,gBAAgB;AAC1C,gBAAQ,KAAK,MAAM,MAAM;AAAA,iBAChB,iBAAiB,YAAY;AAAA,aAEjC;AACL,cAAM,IAAI,MACR,uCAAuC,MAAM,YAAY;AAAA;AAAA;AAI/D,WAAO,QAAQ,KAAK;AAAA;AAAA,EAGtB,qBAAqB;AACnB,UAAM,SAAS,KAAK,QAAQ,CAAE,MAAM;AACpC,QAAI,aAAa;AACjB,QAAI,QAAQ,OAAO;AACnB,QAAI,oBAAoB;AAExB,UAAM,QAAQ,KAAK,QAAQ,CAAE,MAAM;AAEnC,eAAW,QAAQ,OAAO;AAExB,2BAAqB;AAErB,YAAM,YACJ,iBAAiB,cAAc,MAAM,UAAU,SAAS;AAE1D,UAAI,sBAAsB,WAAW;AACnC,4BAAoB;AACpB,sBAAc;AACd,gBAAQ,OAAO;AAAA;AAGjB,UAAI,KAAK,gBAAgB,IAAI;AAG3B,YAAI,iBAAiB,aAAa;AAChC,cAAI,UAAU,KAAK,cAAc;AAC/B,kBAAM,aAAa,mBAAmB,KAAK;AAAA,iBACtC;AAEL,kBAAM,QAAQ,MAAM,UAAU,MAAM,GAAG;AACvC,kBAAM,MAAM,MAAM,UAAU,MAAM,oBAAoB;AACtD,kBAAM,YAAY;AAClB,mBAAO,OAAO,aAAa,GAAG,GAAG,IAAI,QAAQ,KAAK;AAClD,gBAAI,QAAQ,IAAI;AACd,oBAAM,WAAW,IAAI;AACrB,uBAAS,YAAY;AACrB,qBAAO,OAAO,aAAa,GAAG,GAAG;AAAA;AAAA;AAAA,mBAG5B,iBAAiB,cAAc,iBAAiB,SAAS;AAClE,cAAI,UAAU,KAAK,cAAc;AAC/B,kBAAM,OAAO,OAAO,aAAa;AACjC,kBAAM,OAAO,OAAO,aAAa;AACjC,gBAAI,gBAAgB,aAAa;AAC/B,mBAAK,QAAQ,KAAK;AAElB,kBAAI,gBAAgB,aAAa;AAC/B,qBAAK,aAAa,KAAK;AACvB,uBAAO,YAAY;AACnB,uBAAO,aAAa,GAAG;AACvB,uBAAO,OAAO,YAAY;AAAA,qBACrB;AACL,uBAAO,YAAY;AACnB,uBAAO,OAAO,YAAY;AAC1B,uBAAO,KAAK,IAAI;AAAA;AAAA,mBAEb;AACL,oBAAM,WAAW,IAAI;AACrB,uBAAS,QAAQ,KAAK;AACtB,qBAAO,YAAY;AACnB,qBAAO,cAAc;AACrB,qBAAO,KAAK,IAAI;AAAA;AAAA,iBAEb;AACL,kBAAM,UAAU,IAAI,QAAQ,KAAK;AACjC,mBAAO,YAAY;AACnB,mBAAO,cAAc;AACrB,mBAAO,KAAK,IAAI;AAAA;AAAA;AAIpB,aAAK,cAAc;AAEnB,mBAAW,KAAK,QAAQ;AACtB,eAAK,MAAM;AAAA;AAGb,aAAK;AAAA;AAAA;AAAA;AAAA,EAKX,WAAW,YAAwB,UAAiB;AAClD,UAAM,SAAS,KAAK,QAAQ,CAAE,MAAM;AACpC,UAAM,MAAM,OAAO,QAAQ;AAC3B,QAAI,MAAM,GAAG;AACX,YAAM,IAAI,MAAM;AAAA;AAElB,WAAO,OAAO,KAAK,GAAG;AACtB,aAAS,UAAU;AAGnB,eAAW,KAAK,QAAQ;AACtB,WAAK,MAAM;AAAA;AAGb,SAAK;AAAA;AAAA,EAGP,OAAO,IAAY,GAAiB;AAElC,SAAK,KAAK,KAAK,KAAK,KAAK,GAAG,GAAG,KAAK;AACpC,QAAI,OAAO,KAAK,YAAY;AAAA,MAC1B,SAAS,KAAK,KAAK,KAAK;AAAA;AAI1B,QAAI,KAAK,SAAS;AAChB,WAAK;AAAA;AAIP,QAAI,oBAAoB,IAAI,IAAI,KAAK,UAAU,IAAI,SAAS;AAC5D,eAAW,SAAS,KAAK,QAAQ,CAAE,MAAM,UAAW;AAClD,YAAM,WAAW;AAEjB,YAAM,WAAW;AACjB,YAAM,UAAU,KAAK;AAErB,0BAAoB,IAAI,IACtB,mBACA,IAAI,MAAM,QAAQ,SAAS;AAAA;AAI/B,SAAK,QAAQ,kBAAkB,IAAI,KAAK,SAAS;AAGjD,QAAI,KAAK,SAAS,SAAS,GAAG;AAC5B,UAAI,OAAO,KAAK,YAAY;AAAA,QAC1B,GAAG,KAAK,SAAS;AAAA,QACjB,GAAG,KAAK,SAAS;AAAA,QACjB,OAAO;AAAA;AAET,WAAK,SAAS,UAAU;AAAA,WACnB;AACL,UAAI,OAAO,KAAK,YAAY;AAAA,QAC1B,GAAG,KAAK,SAAS;AAAA,QACjB,GAAG,KAAK,SAAS;AAAA,QACjB,OAAO,KAAK;AAAA;AAAA;AAKhB,SAAK;AAGL,eAAW,SAAS,KAAK,UAAU;AACjC,YAAM,OAAO,IAAI;AAAA;AAAA;AAAA,EAIrB,MAAM,UAAoB;AAAA;AAAA,EAI1B,SAAS;AACP,SAAK,WAAW;AAChB,eAAW,SAAS,KAAK,UAAU;AACjC,YAAM;AAAA;AAER,UAAM;AAAA;AAAA;AAIV,mBAAmB,GAAW;AAC5B,SAAO,OAAO,KAAK,KAAK;AAAA;AAGnB,aAAM,WAAW,CAAC,YACvB,mBAAmB,UAAU,UAAU;",
  "names": []
}
