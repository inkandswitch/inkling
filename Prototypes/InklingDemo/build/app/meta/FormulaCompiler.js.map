{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/InkbaseV2/src/app/meta/FormulaCompiler.ts"],
  "sourcesContent": ["import { aLabelToken } from './LabelToken';\nimport { aNumberToken } from './NumberToken';\nimport { aPropertyPicker } from './PropertyPicker';\nimport { TokenWithVariable } from './token-helpers';\nimport Page from '../Page';\nimport SVG from '../Svg';\nimport { Formula, Variable } from '../constraints';\nimport * as constraints from '../constraints';\nimport { GameObject } from '../GameObject';\nimport * as ohm from 'ohm-js';\nimport { Removable } from '../../lib/types';\n\nconst formulaGrammar = ohm.grammar(String.raw`\n\nFormula {\n  Formula\n    = Exp \"=\" ref end  -- oneExp\n    | Exp \"=\" Exp  -- twoExps\n\n  Exp\n    = AddExp\n\n  AddExp\n    = AddExp (\"+\" | \"-\") MulExp  -- add\n    | MulExp\n\n  MulExp\n    = MulExp \"\u00D7\" UnExp  -- mul\n    | UnExp\n\n  UnExp\n    = \"-\" PriExp  -- neg\n    | PriExp\n\n  PriExp\n    = \"(\" Exp \")\"  -- paren\n    | ref\n\n  ref\n    = numberRef\n    | labelRef\n    | propRef\n\n  // lexical rules\n\n  numberRef  (a number reference)\n    = \"@\" digit+\n\n  labelRef (a label reference)\n    = \"#\" digit+\n\n  propRef (a property picker reference)\n    = \"!\" digit+\n}\n`);\n\nexport default class FormulaCompiler {\n  private readonly semantics: ohm.Semantics;\n\n  constructor(page: Page) {\n    function getVariableByTokenId<T extends TokenWithVariable>(\n      id: number,\n      type: string,\n      aThing: (go: GameObject) => T | null\n    ): Variable {\n      const token = page.root.find({\n        what: aThing,\n        that: thing => thing.id === id,\n      });\n      if (!token) {\n        console.error('invalid', type, 'token id', id);\n        throw ':(';\n      }\n      return token.getVariable();\n    }\n\n    this.semantics = formulaGrammar\n      .createSemantics()\n      .addAttribute('variable', {\n        numberRef(at, idDigits) {\n          const id = parseInt(idDigits.sourceString);\n          return getVariableByTokenId(id, 'number', aNumberToken);\n        },\n        labelRef(hash, idDigits) {\n          const id = parseInt(idDigits.sourceString);\n          return getVariableByTokenId(id, 'label', aLabelToken);\n        },\n        propRef(bang, idDigits) {\n          const id = parseInt(idDigits.sourceString);\n          return getVariableByTokenId(id, 'propertyPicker', aPropertyPicker);\n        },\n      })\n      .addOperation('collectVars(vars)', {\n        AddExp_add(a, op, b) {\n          a.collectVars(this.args.vars);\n          b.collectVars(this.args.vars);\n        },\n        MulExp_mul(a, op, b) {\n          a.collectVars(this.args.vars);\n          b.collectVars(this.args.vars);\n        },\n        UnExp_neg(op, e) {\n          e.collectVars(this.args.vars);\n        },\n        PriExp_paren(oparen, e, cparen) {\n          e.collectVars(this.args.vars);\n        },\n        numberRef(at, idDigits) {\n          this.args.vars.add(this.variable);\n        },\n        labelRef(hash, idDigits) {\n          this.args.vars.add(this.variable);\n        },\n        propRef(bang, idDigits) {\n          this.args.vars.add(this.variable);\n        },\n      })\n      .addAttribute('vars', {\n        Exp(e) {\n          const vars = new Set<Variable>();\n          e.collectVars(vars);\n          return vars;\n        },\n      })\n      .addOperation('compile', {\n        AddExp_add(a, op, b) {\n          return `(${a.compile()} ${op.sourceString} ${b.compile()})`;\n        },\n        MulExp_mul(a, op, b) {\n          return `(${a.compile()} * ${b.compile()})`;\n        },\n        UnExp_neg(op, e) {\n          return `(${op.sourceString}${e.compile()})`;\n        },\n        PriExp_paren(oparen, e, cparen) {\n          return `(${e.compile()})`;\n        },\n        numberRef(at, id) {\n          return `v${this.variable.id}`;\n        },\n        labelRef(hash, id) {\n          return `v${this.variable.id}`;\n        },\n        propRef(bang, id) {\n          return `v${this.variable.id}`;\n        },\n      })\n      .addOperation<Removable | null>('toConstraint', {\n        Formula_oneExp(e, eq, ref, end) {\n          let vars: Set<Variable>;\n          try {\n            vars = e.vars;\n          } catch {\n            // formula has one or more number/label token refs with invalid ids\n            return null;\n          }\n          const formula = createFormulaConstraint([...vars], e.compile());\n          constraints.equals(ref.variable, formula.result);\n          return formula;\n        },\n        Formula_twoExps(left, eq, right) {\n          let leftVars: Set<Variable>, rightVars: Set<Variable>;\n          try {\n            leftVars = left.vars;\n            rightVars = right.vars;\n          } catch {\n            // formula has one or more number/label token refs with invalid ids\n            return null;\n          }\n          const leftFormula = createFormulaConstraint(\n            [...leftVars],\n            left.compile()\n          );\n          const rightFormula = createFormulaConstraint(\n            [...rightVars],\n            right.compile()\n          );\n          constraints.equals(rightFormula.result, leftFormula.result);\n          // const ks = [...leftVars].map(lv => constraints.constant(lv));\n          // setTimeout(() => ks.forEach(k => k.remove()), 100);\n          return {\n            remove() {\n              leftFormula.remove();\n              rightFormula.remove();\n              // equality constraint is removed transitively\n            },\n          };\n        },\n      });\n  }\n\n  /** Returns a formula constraint for this formula, if it's valid, or null otherwise. */\n  compile(input: string): Removable | null {\n    const m = formulaGrammar.match(input);\n    if (m.succeeded()) {\n      return this.semantics(m).toConstraint();\n    } else {\n      SVG.showStatus(m.shortMessage!);\n      console.error(m.message);\n      return null;\n    }\n  }\n}\n\nfunction createFormulaConstraint(vars: Variable[], compiledExp: string) {\n  const argNames = vars.map(v => `v${v.id}`);\n  const func = new Function(`[${argNames}]`, `return ${compiledExp}`) as (\n    xs: number[]\n  ) => number;\n  return constraints.formula(vars, func);\n}\n"],
  "mappings": "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",
  "names": []
}
