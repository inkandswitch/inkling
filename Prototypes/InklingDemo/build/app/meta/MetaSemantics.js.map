{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/InkbaseV2/src/app/meta/MetaSemantics.ts"],
  "sourcesContent": ["import * as constraints from '../constraints';\nimport { Constraint, Variable } from '../constraints';\nimport { Position } from '../../lib/types';\nimport { generateId } from '../../lib/helpers';\n\n// This file implements the semantics of meta ink independently of the visual language\n// There are two main types: Meta Value & Meta Connection\n\n// Meta Value\n// A meta value can be a Number, Struct(Component?) or Collection\nexport interface MetaValue {\n  /** Connects `this` MetaValue to `that` MetaValue. */\n  wireTo(that: MetaValue): MetaConnection | null;\n}\n\n/** An abstract \"wire\" between two values. */\nexport interface MetaConnection {\n  /** Clean up this connection. */\n  remove(): void;\n\n  get paused(): boolean;\n\n  togglePaused(newValue?: boolean): boolean;\n}\n\n// NUMBERS\nexport class MetaNumber implements MetaValue {\n  constructor(public variable: Variable) {}\n\n  wireTo(that: MetaValue): MetaNumberConnection | null {\n    if (that instanceof MetaNumber || that instanceof MetaNumber) {\n      return new MetaNumberConnection(this, that);\n    } else {\n      console.error(\"You can't wire those things together silly billy!\");\n      return null;\n    }\n  }\n}\n\nexport class MetaNumberConnection implements MetaConnection {\n  constraint: Constraint;\n\n  constructor(a: MetaNumber | MetaLabel, b: MetaNumber | MetaLabel) {\n    // The order of arguments to `equals` matters b/c the 1st one's\n    // associated value will flow into the second.\n    // The order in the call below used to be `a.variable, b.variable`\n    // but that caused jumps in the property picker's values.\n    this.constraint = constraints.equals(b.variable, a.variable);\n  }\n\n  get paused() {\n    return this.constraint.paused;\n  }\n\n  togglePaused(newValue = !this.constraint.paused) {\n    return (this.constraint.paused = newValue);\n  }\n\n  remove() {\n    this.constraint.remove();\n  }\n}\n\nexport class MetaLabel implements MetaValue {\n  readonly id: number = generateId();\n\n  constructor(\n    public readonly display: string | Position[][],\n    public variable: Variable\n  ) {}\n\n  wireTo(that: MetaValue): MetaConnection | null {\n    if (that instanceof MetaNumber || that instanceof MetaNumber) {\n      return new MetaNumberConnection(this, that);\n    } else {\n      console.error(\"You can't wire those things together silly billy!\");\n      return null;\n    }\n  }\n}\n\n/**\n * A collection of labels / names.\n */\nexport class MetaStruct implements MetaValue {\n  labelsById = new Map<number, MetaLabel>();\n  labelsByString = new Map<string, MetaLabel>();\n\n  constructor(input: Array<MetaLabel>) {\n    for (const label of input) {\n      this.labelsById.set(label.id, label);\n      if (typeof label.display === 'string') {\n        this.labelsByString.set(label.display as string, label);\n      }\n    }\n  }\n\n  createLabel(strokeData: string | Position[][]) {\n    const label = new MetaLabel(strokeData, constraints.variable(0));\n    label.variable.represents = { object: label, property: 'label-value' };\n    this.labelsById.set(label.id, label);\n    if (typeof strokeData === 'string') {\n      this.labelsByString.set(label.display as string, label);\n    }\n    return label;\n  }\n\n  getLabelByString(textLabel: string): MetaLabel | undefined {\n    return this.labelsByString.get(textLabel);\n  }\n\n  getLabelById(id: number): MetaLabel | undefined {\n    return this.labelsById.get(id);\n  }\n\n  isEmpty() {\n    return this.labelsById.size === 0;\n  }\n\n  list(): Array<MetaLabel> {\n    return Array.from(this.labelsById.values());\n  }\n\n  wireTo(that: MetaValue): MetaStructConnection | null {\n    if (that instanceof MetaStruct) {\n      return new MetaStructConnection(this, that);\n    } else {\n      console.error(\"You can't wire those things together silly billy!\");\n      return null;\n    }\n  }\n}\n\n// TODO: this class is implemented in an ad-hoc way and needs more thinking\nexport class MetaStructConnection implements MetaConnection {\n  b: MetaStruct;\n  private readonly constraints: Constraint[] = [];\n\n  constructor(a: MetaStruct, b: MetaStruct) {\n    // Make sure 'b' is the empty one, so we always unify towards the empty struct\n    if (a.isEmpty()) {\n      [a, b] = [b, a];\n    }\n\n    // Handle case when wiring two gizmos together\n    if (!b.isEmpty()) {\n      for (const [id, a_label] of a.labelsByString.entries()) {\n        const b_label = b.labelsByString.get(id);\n        if (b_label) {\n          this.constraints.push(\n            constraints.equals(b_label.variable, a_label.variable)\n          );\n        }\n      }\n    } else {\n      // Just point to the same Map in memory is fine here?\n      b.labelsById = a.labelsById;\n    }\n    this.b = b;\n  }\n\n  // TODO: figure out how to do pausing for this kind of connection\n\n  get paused() {\n    return false;\n  }\n\n  togglePaused(newValue: boolean): boolean {\n    return false;\n  }\n\n  remove() {\n    this.b.labelsById = new Map();\n    for (const constraint of this.constraints) {\n      constraint.remove();\n    }\n    return;\n  }\n}\n\n// COLLECTION (TBD)\nexport class MetaCollection implements MetaValue {\n  wireTo(that: MetaValue) {\n    return null;\n  }\n}\n"],
  "mappings": "AAAA;AAGA;AAuBO,wBAAsC;AAAA,EAC3C,YAAmB,UAAoB;AAApB;AAAA;AAAA,EAEnB,OAAO,MAA8C;AACnD,QAAI,gBAAgB,cAAc,gBAAgB,YAAY;AAC5D,aAAO,IAAI,qBAAqB,MAAM;AAAA,WACjC;AACL,cAAQ,MAAM;AACd,aAAO;AAAA;AAAA;AAAA;AAKN,kCAAqD;AAAA,EAG1D,YAAY,GAA2B,GAA2B;AAKhE,SAAK,aAAa,YAAY,OAAO,EAAE,UAAU,EAAE;AAAA;AAAA,MAGjD,SAAS;AACX,WAAO,KAAK,WAAW;AAAA;AAAA,EAGzB,aAAa,WAAW,CAAC,KAAK,WAAW,QAAQ;AAC/C,WAAQ,KAAK,WAAW,SAAS;AAAA;AAAA,EAGnC,SAAS;AACP,SAAK,WAAW;AAAA;AAAA;AAIb,uBAAqC;AAAA,EAG1C,YACkB,SACT,UACP;AAFgB;AACT;AAJA,cAAa;AAAA;AAAA,EAOtB,OAAO,MAAwC;AAC7C,QAAI,gBAAgB,cAAc,gBAAgB,YAAY;AAC5D,aAAO,IAAI,qBAAqB,MAAM;AAAA,WACjC;AACL,cAAQ,MAAM;AACd,aAAO;AAAA;AAAA;AAAA;AAQN,wBAAsC;AAAA,EAI3C,YAAY,OAAyB;AAHrC,sBAAa,IAAI;AACjB,0BAAiB,IAAI;AAGnB,eAAW,SAAS,OAAO;AACzB,WAAK,WAAW,IAAI,MAAM,IAAI;AAC9B,UAAI,OAAO,MAAM,YAAY,UAAU;AACrC,aAAK,eAAe,IAAI,MAAM,SAAmB;AAAA;AAAA;AAAA;AAAA,EAKvD,YAAY,YAAmC;AAC7C,UAAM,QAAQ,IAAI,UAAU,YAAY,YAAY,SAAS;AAC7D,UAAM,SAAS,aAAa,CAAE,QAAQ,OAAO,UAAU;AACvD,SAAK,WAAW,IAAI,MAAM,IAAI;AAC9B,QAAI,OAAO,eAAe,UAAU;AAClC,WAAK,eAAe,IAAI,MAAM,SAAmB;AAAA;AAEnD,WAAO;AAAA;AAAA,EAGT,iBAAiB,WAA0C;AACzD,WAAO,KAAK,eAAe,IAAI;AAAA;AAAA,EAGjC,aAAa,IAAmC;AAC9C,WAAO,KAAK,WAAW,IAAI;AAAA;AAAA,EAG7B,UAAU;AACR,WAAO,KAAK,WAAW,SAAS;AAAA;AAAA,EAGlC,OAAyB;AACvB,WAAO,MAAM,KAAK,KAAK,WAAW;AAAA;AAAA,EAGpC,OAAO,MAA8C;AACnD,QAAI,gBAAgB,YAAY;AAC9B,aAAO,IAAI,qBAAqB,MAAM;AAAA,WACjC;AACL,cAAQ,MAAM;AACd,aAAO;AAAA;AAAA;AAAA;AAMN,kCAAqD;AAAA,EAI1D,YAAY,GAAe,GAAe;AAFzB,uBAA4B;AAI3C,QAAI,EAAE,WAAW;AACf,OAAC,GAAG,KAAK,CAAC,GAAG;AAAA;AAIf,QAAI,CAAC,EAAE,WAAW;AAChB,iBAAW,CAAC,IAAI,YAAY,EAAE,eAAe,WAAW;AACtD,cAAM,UAAU,EAAE,eAAe,IAAI;AACrC,YAAI,SAAS;AACX,eAAK,YAAY,KACf,YAAY,OAAO,QAAQ,UAAU,QAAQ;AAAA;AAAA;AAAA,WAI9C;AAEL,QAAE,aAAa,EAAE;AAAA;AAEnB,SAAK,IAAI;AAAA;AAAA,MAKP,SAAS;AACX,WAAO;AAAA;AAAA,EAGT,aAAa,UAA4B;AACvC,WAAO;AAAA;AAAA,EAGT,SAAS;AACP,SAAK,EAAE,aAAa,IAAI;AACxB,eAAW,cAAc,KAAK,aAAa;AACzC,iBAAW;AAAA;AAEb;AAAA;AAAA;AAKG,4BAA0C;AAAA,EAC/C,OAAO,MAAiB;AACtB,WAAO;AAAA;AAAA;",
  "names": []
}
