{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/InkbaseV2/src/app/NativeEvents.ts"],
  "sourcesContent": ["import { Position, PositionWithPressure } from '../lib/types';\nimport Vec from '../lib/vec';\nimport Config from './Config';\nimport { Gesture } from './gestures/Gesture';\nimport MetaToggle from './gui/MetaToggle';\n\n// TODO: Do we want to add some way to fake pencil input with a finger?\n// That might be a useful thing to add HERE, so that other parts of the system\n// will be forced to assume multi-pencil support exists, which might drive novel ideas.\n\n// TODO: Check if we have stale events lingering for a long time, which could be caused by\n// the Swift wrapper not sending us (say) finger ended events. If so, we might need to\n// cull fingers (or pencils?) if we go for a certain amount of time without receiving a new\n// event with a corresponding TouchId.\n\n// How far does the input need to move before we count it as a drag?\nconst fingerMinDragDist = 10;\nconst pencilMinDragDist = 10;\n\n// How long (milliseconds) can a touch go without being updated before we consider it \"dead\"?\nconst touchMaxAge = 15000;\n\nexport type Event = PencilEvent | FingerEvent;\nexport type InputState = PencilState | FingerState;\n\nexport type EventType = Event['type'];\nexport type EventState = 'began' | 'moved' | 'ended';\nexport type EventStateWithCancelled = EventState | 'cancelled';\nexport type TouchId = string;\n\ninterface SharedEventProperties {\n  state: EventState;\n  id: TouchId;\n  position: Position;\n  timestamp: number;\n  radius: number;\n  lastUpdated: number;\n}\n\nexport interface PencilEvent extends SharedEventProperties {\n  type: 'pencil';\n  pressure: number;\n  altitude: number;\n  azimuth: number;\n}\n\nexport interface FingerEvent extends SharedEventProperties {\n  type: 'finger';\n}\n\ninterface SharedStateProperties {\n  down: boolean; // Is the touch currently down?\n  drag: boolean; // Has the touch moved at least a tiny bit since being put down?\n  dragDist: number; // How far has the touch moved?\n  // TODO \u2014 do we want to store the original & current *event* instead of cherry-picking their properties?\n  position: Position | null; // Where is the touch now?\n  originalPosition: Position | null; // Where was the touch initially put down?\n  lastUpdated: number;\n}\n\nexport interface PencilState extends SharedStateProperties {\n  event: PencilEvent; // What's the current (or most recent) event that has contributed to the state?\n}\nexport interface FingerState extends SharedStateProperties {\n  id: TouchId; // What's the ID of this finger?\n  event: FingerEvent; // What's the current (or most recent) event that has contributed to the state?\n}\n\ntype TouchPoint = {\n  type: EventType;\n  altitude: number;\n  azimuth: number;\n  pressure: number;\n  radius: number;\n  timestamp: number;\n  position: Position;\n};\n\ntype ApplyEvent = (event: Event, state: InputState) => void;\n\nexport default class Events {\n  events: Event[] = [];\n  pencilState: PencilState | null = null;\n  fingerStates: FingerState[] = [];\n  forcePseudo: number = 0;\n\n  constructor(\n    private metaToggle: MetaToggle,\n    private applyEvent: ApplyEvent\n  ) {\n    this.setupFallbackEvents();\n    this.setupNativeEventHandler();\n  }\n\n  // prettier-ignore\n  update() {\n    for (const event of this.events) {\n      let state: InputState;\n\n      // Tempted to make this a dynamic dispatch\n      if (event.type === 'finger') {\n        switch(event.state) {\n          case 'began':     state = this.fingerBegan(event); break;\n          case 'moved':     state = this.fingerMoved(event); break;\n          case 'ended':     state = this.fingerEnded(event); break;\n        }\n      } else {\n        switch(event.state) {\n          case 'began':     state = this.pencilBegan(event); break;\n          case 'moved':     state = this.pencilMoved(event); break;\n          case 'ended':     state = this.pencilEnded(event); break;\n        }\n      }\n\n      state.lastUpdated = performance.now();\n\n      this.applyEvent(event, state);\n\n      // Remove states that are no longer down\n      if (this.pencilState?.down === false) { this.pencilState = null }\n      this.fingerStates = this.fingerStates.filter((state) => state.down);\n    }\n\n    this.events = [];\n\n    // We need to reap any eventStates that haven't been touched in a while,\n    // because we don't always receive the \"ended\".\n    if (Config.gesture.reapTouches) {\n      this.fingerStates = this.fingerStates.filter(wasRecentlyUpdated);\n      if (this.pencilState && !wasRecentlyUpdated(this.pencilState)) {\n        this.pencilState = null;\n      }\n    }\n  }\n\n  private mouseEvent(e: MouseEvent, state: EventState) {\n    this.events.push({\n      position: { x: e.clientX, y: e.clientY },\n      id: '-1',\n      state,\n      type: this.keymap.space ? 'pencil' : 'finger',\n      timestamp: performance.now(),\n      radius: 1,\n      lastUpdated: performance.now(),\n      altitude: 0,\n      azimuth: 0,\n      pressure: 1,\n    });\n  }\n\n  keymap: Record<string, boolean> = {};\n\n  private keyboardEvent(e: KeyboardEvent, state: EventState) {\n    const k = keyName(e);\n\n    if (state === 'began' && this.keymap[k]) {\n      return;\n    } else if (state === 'began') {\n      this.keymap[k] = true;\n    } else {\n      delete this.keymap[k];\n    }\n\n    this.forcePseudo =\n      [\n        this.keymap['1'],\n        this.keymap['2'],\n        this.keymap['3'],\n        this.keymap['4'],\n      ].lastIndexOf(true) + 1;\n\n    if (state === 'began') {\n      if (this.shortcuts[k]) {\n        this.shortcuts[k]();\n        e.preventDefault();\n      }\n    }\n  }\n\n  private shortcuts: Record<string, Function> = {\n    Tab: () => {\n      this.metaToggle.toggle();\n    },\n  };\n\n  private setupFallbackEvents() {\n    window.onmousedown = (e: MouseEvent) => this.mouseEvent(e, 'began');\n    window.onmousemove = (e: MouseEvent) => this.mouseEvent(e, 'moved');\n    window.onmouseup = (e: MouseEvent) => this.mouseEvent(e, 'ended');\n    window.onkeydown = (e: KeyboardEvent) => this.keyboardEvent(e, 'began');\n    window.onkeyup = (e: KeyboardEvent) => this.keyboardEvent(e, 'ended');\n  }\n\n  private disableFallbackEvents() {\n    window.onmousedown = null;\n    window.onmousemove = null;\n    window.onmouseup = null;\n    window.onkeydown = null;\n    window.onkeyup = null;\n  }\n\n  // prettier-ignore\n  private setupNativeEventHandler() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (window as any).nativeEvent = (state: EventStateWithCancelled, touches: Record<TouchId, TouchPoint[]>) => {\n      this.disableFallbackEvents();\n\n      // The swift wrapper passes us 'cancelled' events, but they're a pain to code around, so we treat them as 'ended'\n      if (state === 'cancelled') {\n        state = 'ended'\n      }\n\n      const lastUpdated = performance.now();\n\n      // Okay, so this is weird. Swift gives us a single EventState, but multiple \"touches\"?\n      // And then we loop through the touches and make\u2026 an Event for each one?\n      // Why are we thinking of these as \"touches\"? What does that word mean here?\n      // Why doesn't the Swift wrapper just give us an array of Events?\n      // This seems like an abstraction leak, where the design of UIGestureRecognizer\n      // is forcing a data model that doesn't match what we're actually trying to do.\n      for (const id in touches) {\n        for (const point of touches[id]) {\n          const { type, timestamp, position, radius, pressure, altitude, azimuth } = point;\n          const sharedProperties = { id, state, type, timestamp, position, radius, lastUpdated };\n          const event: Event = type === 'finger'\n            ? { ...sharedProperties, type }\n            : { ...sharedProperties, type, pressure, altitude, azimuth };\n          this.events.push(event);\n        }\n      }\n    };\n  }\n\n  // TODO: I suspect the below functions could be made generic, to act on both pencils and fingers,\n  // with no loss of clarity. I also suspect they could be made drastically smaller.\n\n  fingerBegan(event: FingerEvent, down = true) {\n    const state: FingerState = {\n      id: event.id,\n      down,\n      drag: false,\n      dragDist: 0,\n      position: event.position,\n      originalPosition: event.position,\n      event,\n      lastUpdated: 0,\n    };\n    this.fingerStates.push(state);\n    return state;\n  }\n\n  pencilBegan(event: PencilEvent, down = true) {\n    this.pencilState = {\n      down,\n      drag: false,\n      dragDist: 0,\n      position: event.position,\n      originalPosition: event.position,\n      event,\n      lastUpdated: 0,\n    };\n    return this.pencilState;\n  }\n\n  fingerMoved(event: FingerEvent) {\n    let state = this.fingerStates.find(state => state.id === event.id);\n    if (!state) {\n      state = this.fingerBegan(event, false);\n    }\n    state.dragDist = Vec.dist(event.position, state.originalPosition!);\n    state.drag ||= state.dragDist > fingerMinDragDist;\n    state.position = event.position;\n    state.event = event;\n    return state;\n  }\n\n  pencilMoved(event: PencilEvent) {\n    let state = this.pencilState;\n    if (!state) {\n      state = this.pencilBegan(event, false);\n    }\n    state.dragDist = Vec.dist(event.position, state.originalPosition!);\n    state.drag ||= state.dragDist > pencilMinDragDist;\n    state.position = event.position;\n    state.event = event;\n    return state;\n  }\n\n  fingerEnded(event: FingerEvent) {\n    let state = this.fingerStates.find(state => state.id === event.id);\n    if (!state) {\n      state = this.fingerBegan(event, false);\n    }\n    state.down = false;\n    state.event = event;\n    return state;\n  }\n\n  pencilEnded(event: PencilEvent) {\n    let state = this.pencilState;\n    if (!state) {\n      (state = this.pencilBegan(event)), false;\n    }\n    state.down = false;\n    state.event = event;\n    return state;\n  }\n}\n\nexport function getPositionWithPressure(\n  event: PencilEvent\n): PositionWithPressure {\n  return { ...event.position, pressure: event.pressure };\n}\n\nexport function wasRecentlyUpdated(thing: InputState | Gesture | Event) {\n  const recentlyUpdated = thing.lastUpdated + touchMaxAge > performance.now();\n  if (!recentlyUpdated) {\n    console.log('TELL IVAN YOU SAW THIS');\n  }\n  return recentlyUpdated;\n}\n\nfunction keyName(e: KeyboardEvent) {\n  return e.key.replace(' ', 'space');\n}\n"],
  "mappings": "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",
  "names": []
}
