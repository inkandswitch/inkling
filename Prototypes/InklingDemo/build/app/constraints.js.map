{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/InkbaseV2/src/app/constraints.ts"],
  "sourcesContent": ["import { GameObject } from './GameObject';\nimport SVG from './Svg';\nimport Handle, { aHandle } from './ink/Handle';\nimport { forDebugging, generateId, sets } from '../lib/helpers';\nimport { minimize } from '../lib/g9';\nimport { TAU } from '../lib/math';\nimport { Position } from '../lib/types';\nimport Vec from '../lib/vec';\n\n// #region variables\n\ntype VariableInfo = CanonicalVariableInfo | AbsorbedVariableInfo;\n\ninterface CanonicalVariableInfo {\n  isCanonical: true;\n  absorbedVariables: Set<Variable>;\n}\n\ninterface AbsorbedVariableInfo {\n  isCanonical: false;\n  canonicalInstance: Variable;\n  // canonicalInstance.value === offset.m * absorbedVariable.value + offset.b\n  offset: { m: number; b: number };\n}\n\nexport class Variable {\n  static readonly all = new Set<Variable>();\n\n  static create(value = 0, represents?: { object: object; property: string }) {\n    return new Variable(value, represents);\n  }\n\n  readonly id = generateId();\n  info: VariableInfo = {\n    isCanonical: true,\n    absorbedVariables: new Set(),\n  };\n  represents?: { object: object; property: string };\n\n  private constructor(\n    private _value: number = 0,\n    represents?: { object: object; property: string }\n  ) {\n    this.represents = represents;\n    Variable.all.add(this);\n  }\n\n  /** Removes this variable and any constraint that reference it. */\n  remove() {\n    if (!Variable.all.has(this)) {\n      // needed to break cycles\n      return;\n    }\n\n    Variable.all.delete(this);\n    for (const constraint of Constraint.all) {\n      if (constraint.variables.includes(this)) {\n        constraint.remove();\n      }\n    }\n  }\n\n  get isCanonicalInstance() {\n    return this.info.isCanonical;\n  }\n\n  get canonicalInstance(): Variable {\n    return this.info.isCanonical ? this : this.info.canonicalInstance;\n  }\n\n  get offset() {\n    return this.info.isCanonical ? { m: 1, b: 0 } : this.info.offset;\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  set value(newValue: number) {\n    if (this.info.isCanonical) {\n      this._value = newValue;\n      for (const that of this.info.absorbedVariables) {\n        const { m, b } = (that.info as AbsorbedVariableInfo).offset;\n        that._value = (newValue - b) / m;\n      }\n    } else {\n      this.info.canonicalInstance.value = this.toCanonicalValue(newValue);\n    }\n  }\n\n  toCanonicalValue(value: number) {\n    if (this.info.isCanonical) {\n      return value;\n    }\n\n    const { m, b } = this.info.offset;\n    return m * value + b;\n  }\n\n  /** y.makeEqualTo(x, { m, b }) ==> y = m * x + b */\n  makeEqualTo(that: Variable, offset = { m: 1, b: 0 }) {\n    if (this === that) {\n      return;\n    } else if (!this.info.isCanonical) {\n      const { m: mThat, b: bThat } = offset;\n      const { m: mThis, b: bThis } = this.offset;\n      // this = mThat * that + bThat\n      // this.CI = mThis * (mThat * that + bThat) + bThis\n      // this.CI = mthis * mThat * that + mThis * bThat + bThis\n      this.canonicalInstance.makeEqualTo(that, {\n        m: mThis * mThat,\n        b: mThis * bThat + bThis,\n      });\n      return;\n    } else if (!that.info.isCanonical) {\n      const { m: mThat, b: bThat } = that.offset;\n      const { m, b } = offset;\n      // that.CI = mThat * that + bThat  ==>  that = (that.CI - bThat) / mThat\n      // this = m * that + b\n      // this = m * (that.CI - bThat) / mThat + b = m / mThat * that.CI + b - bThat / mThat\n      this.makeEqualTo(that.canonicalInstance, {\n        m: m / mThat,\n        b: b - bThat / mThat,\n      });\n      return;\n    }\n\n    const thatLockConstraint = that.lockConstraint;\n\n    for (const otherVariable of that.info.absorbedVariables) {\n      const otherVariableInfo = otherVariable.info as AbsorbedVariableInfo;\n      otherVariableInfo.canonicalInstance = this;\n      // m1 * (m2 * x + b2) + b1 = m1 * m2 * x + m1 * b2 + b1\n      otherVariableInfo.offset = {\n        m: offset.m * otherVariableInfo.offset.m,\n        b: offset.m * otherVariableInfo.offset.b + offset.b,\n      };\n      this.info.absorbedVariables.add(otherVariable);\n    }\n\n    that.info = {\n      isCanonical: false,\n      canonicalInstance: this,\n      offset: offset,\n    };\n    this.info.absorbedVariables.add(that);\n\n    // Now that all of the relationships are set up, the following\n    // \"self-assignment\" updates the values of all of the absorbed\n    // variables, taking the linear relationships into account.\n    // eslint-disable-next-line no-self-assign\n    this.value = this.value;\n\n    if (thatLockConstraint || this.isLocked) {\n      this.lock(); // ensure that they're all locked\n    } else {\n      this.unlock(); // ensure that they're all unlocked\n    }\n  }\n\n  promoteToCanonical() {\n    if (this.info.isCanonical) {\n      // nothing to do\n    } else {\n      this.info.canonicalInstance.breakOff(this);\n    }\n  }\n\n  breakOff(that: Variable) {\n    if (!this.info.isCanonical) {\n      throw new Error('Handle.breakOff() called on absorbed variable');\n    }\n    if (!this.info.absorbedVariables.has(that)) {\n      throw new Error('cannot break off a variable that has not been absorbed');\n    }\n\n    this.info.absorbedVariables.delete(that);\n    that.info = { isCanonical: true, absorbedVariables: new Set() };\n\n    if (this.isLocked) {\n      that.lock();\n    }\n\n    forgetClustersForSolver();\n  }\n\n  get lockConstraint(): Constant | null {\n    for (const c of Constraint.all) {\n      if (c instanceof Constant && c.variable === this.canonicalInstance) {\n        return c;\n      }\n    }\n    return null;\n  }\n\n  get isLocked() {\n    return !!this.lockConstraint;\n  }\n\n  // TODO: this is kind of a hack, consider keeping track of this info some other way!\n  isScrubbing = false;\n\n  lock(value?: number, scrub = false) {\n    if (!this.info.isCanonical) {\n      this.canonicalInstance.lock(\n        value !== undefined ? this.toCanonicalValue(value) : undefined,\n        scrub\n      );\n      return;\n    }\n\n    if (value !== undefined) {\n      this.value = value; // this also changes the values of the absorbed vars\n    }\n    for (const variable of [this, ...this.info.absorbedVariables]) {\n      constant(variable);\n      variable.isScrubbing = scrub;\n    }\n  }\n\n  unlock() {\n    if (!this.info.isCanonical) {\n      this.canonicalInstance.unlock();\n      return;\n    }\n\n    for (const variable of [this, ...this.info.absorbedVariables]) {\n      constant(variable).remove();\n      variable.isScrubbing = false;\n    }\n  }\n\n  toggleLock() {\n    if (this.isLocked) {\n      this.unlock();\n    } else {\n      this.lock();\n    }\n  }\n\n  equals(that: Variable) {\n    return (\n      (this.canonicalInstance === that &&\n        this.offset.m === 1 &&\n        this.offset.b === 0) ||\n      (that.canonicalInstance === this &&\n        that.offset.m === 1 &&\n        that.offset.b === 0) ||\n      (this.canonicalInstance === that.canonicalInstance &&\n        this.offset.m === that.offset.m &&\n        this.offset.b === that.offset.b)\n    );\n  }\n\n  hasLinearRelationshipWith(that: Variable) {\n    return this.canonicalInstance === that.canonicalInstance;\n  }\n}\n\nexport const variable = Variable.create;\n\n// #endregion variables\n\n// #region low-level constraints\n\nabstract class LowLevelConstraint {\n  readonly variables = [] as Variable[];\n  readonly ownVariables = new Set<Variable>();\n\n  /**\n   * Add this constraint to the list of constraints. In case of clashes,\n   * implementations of this method should not add this constraint. They should\n   * instead create linear relationships between variables so that the behavior\n   * of this constraint is maintained w/o duplication, which results in poorly-\n   * behaved gradients.\n   */\n  abstract addTo(constraints: LowLevelConstraint[]): void;\n\n  /**\n   * If this constraint can determine the values of any variables based on\n   * other state that is already known, it should set the values of those\n   * variables and add them to `knowns`.\n   */\n  propagateKnowns(knowns: Set<Variable>) {}\n\n  /**\n   * Returns the current error for this constraint. (OK if it's negative.)\n   * If this constraint owns a \"free\" variable, i.e., one  whose value can be\n   * determined locally, ignore the corresponding value in `variableValues` and\n   * instead set the value of that variable to make the error equal to zero.\n   */\n  abstract getError(\n    variableValues: number[],\n    knowns: Set<Variable>,\n    freeVariables: Set<Variable>\n  ): number;\n}\n\nclass Distance extends LowLevelConstraint {\n  constructor(\n    constraint: Constraint,\n    public readonly a: Handle,\n    public readonly b: Handle\n  ) {\n    super();\n    this.variables.push(\n      variable(Vec.dist(a.position, b.position), {\n        object: constraint,\n        property: 'distance',\n      }),\n      a.xVariable,\n      a.yVariable,\n      b.xVariable,\n      b.yVariable\n    );\n    this.ownVariables.add(this.distance);\n  }\n\n  get distance() {\n    return this.variables[0];\n  }\n\n  addTo(constraints: LowLevelConstraint[]) {\n    for (const that of constraints) {\n      if (\n        that instanceof Distance &&\n        ((this.a.equals(that.a) && this.b.equals(that.b)) ||\n          (this.a.equals(that.b) && this.b.equals(that.a)))\n      ) {\n        that.distance.makeEqualTo(this.distance);\n        return;\n      }\n    }\n\n    constraints.push(this);\n  }\n\n  propagateKnowns(knowns: Set<Variable>) {\n    if (\n      !knowns.has(this.distance.canonicalInstance) &&\n      knowns.has(this.a.xVariable.canonicalInstance) &&\n      knowns.has(this.a.yVariable.canonicalInstance) &&\n      knowns.has(this.b.xVariable.canonicalInstance) &&\n      knowns.has(this.b.yVariable.canonicalInstance)\n    ) {\n      this.distance.value = Vec.dist(this.a, this.b);\n      knowns.add(this.distance.canonicalInstance);\n    }\n  }\n\n  getError(\n    [dist, ax, ay, bx, by]: number[],\n    knowns: Set<Variable>,\n    freeVariables: Set<Variable>\n  ): number {\n    const aPos = { x: ax, y: ay };\n    const bPos = { x: bx, y: by };\n    const currDist = Vec.dist(aPos, bPos);\n    if (freeVariables.has(this.distance.canonicalInstance)) {\n      this.distance.value = currDist;\n    }\n    return currDist - dist;\n  }\n}\n\nclass Angle extends LowLevelConstraint {\n  constructor(\n    constraint: Constraint,\n    public readonly a: Handle,\n    public readonly b: Handle\n  ) {\n    super();\n    this.variables.push(\n      variable(Vec.angle(Vec.sub(b.position, a.position)), {\n        object: constraint,\n        property: 'distance',\n      }),\n      a.xVariable,\n      a.yVariable,\n      b.xVariable,\n      b.yVariable\n    );\n    this.ownVariables.add(this.angle);\n  }\n\n  get angle() {\n    return this.variables[0];\n  }\n\n  addTo(constraints: LowLevelConstraint[]) {\n    for (const that of constraints) {\n      if (!(that instanceof Angle)) {\n        continue;\n      } else if (this.a.equals(that.a) && this.b.equals(that.b)) {\n        that.angle.makeEqualTo(this.angle);\n        return;\n      } else if (this.a.equals(that.b) && this.b.equals(that.a)) {\n        that.angle.makeEqualTo(this.angle, { m: 1, b: Math.PI });\n        return;\n      }\n    }\n\n    constraints.push(this);\n  }\n\n  propagateKnowns(knowns: Set<Variable>) {\n    if (\n      !knowns.has(this.angle) &&\n      knowns.has(this.a.xVariable.canonicalInstance) &&\n      knowns.has(this.a.yVariable.canonicalInstance) &&\n      knowns.has(this.b.xVariable.canonicalInstance) &&\n      knowns.has(this.b.yVariable.canonicalInstance)\n    ) {\n      updateAngle(this.angle, this.a, this.b);\n      knowns.add(this.angle.canonicalInstance);\n    }\n  }\n\n  getError(\n    [angle, ax, ay, bx, by]: number[],\n    knowns: Set<Variable>,\n    freeVariables: Set<Variable>\n  ): number {\n    // The old way, which has problems b/c errors are in terms of angles.\n    // const aPos = { x: ax, y: ay };\n    // const bPos = { x: bx, y: by };\n    // const currAngle = Vec.angle(Vec.sub(bPos, aPos));\n    // return (currAngle - angle) * 100;\n\n    // The new way, implemented in terms of the minimum amount of displacement\n    // required to satisfy the constraint.\n\n    const aPos = { x: ax, y: ay };\n    const bPos = { x: bx, y: by };\n    if (freeVariables.has(this.angle.canonicalInstance)) {\n      updateAngle(this.angle, aPos, bPos);\n      return 0;\n    }\n\n    const r = Vec.dist(bPos, aPos);\n    let error = Infinity;\n\n    if (\n      !knowns.has(this.b.xVariable.canonicalInstance) &&\n      !knowns.has(this.b.yVariable.canonicalInstance)\n    ) {\n      const x = ax + r * Math.cos(angle);\n      const y = ay + r * Math.sin(angle);\n      error = Math.min(error, Vec.dist(bPos, { x, y }));\n    } else if (!knowns.has(this.b.xVariable.canonicalInstance)) {\n      const x = ax + (by - ay) / Math.tan(angle);\n      error = Math.min(error, Math.abs(x - bx));\n    } else if (!knowns.has(this.b.yVariable.canonicalInstance)) {\n      const y = ay + (bx - ax) * Math.tan(angle);\n      error = Math.min(error, Math.abs(y - by));\n    }\n\n    if (\n      !knowns.has(this.a.xVariable.canonicalInstance) &&\n      !knowns.has(this.a.yVariable.canonicalInstance)\n    ) {\n      const x = bx + r * Math.cos(angle + Math.PI);\n      const y = by + r * Math.sin(angle + Math.PI);\n      error = Math.min(error, Vec.dist(aPos, { x, y }));\n    } else if (!knowns.has(this.a.xVariable.canonicalInstance)) {\n      const x = bx + (ay - by) / Math.tan(angle + Math.PI);\n      error = Math.min(error, Math.abs(x - ax));\n    } else if (!knowns.has(this.a.yVariable.canonicalInstance)) {\n      const y = by + (ax - bx) * Math.tan(angle + Math.PI);\n      error = Math.min(error, Math.abs(y - ay));\n    }\n\n    if (!Number.isFinite(error)) {\n      // We can't move anything, but we'll ignore that and return a \"reasonable\" error.\n      // (This gets better results than returning zero.)\n\n      error = Math.min(\n        // error we'd get from moving b to satisfy the constraint\n        Vec.dist(bPos, {\n          x: ax + r * Math.cos(angle),\n          y: ay + r * Math.sin(angle),\n        }),\n        // error we'd get from moving a to satisfy the constraint\n        Vec.dist(aPos, {\n          x: bx + r * Math.cos(angle + Math.PI),\n          y: by + r * Math.sin(angle + Math.PI),\n        })\n      );\n    }\n\n    return error;\n  }\n}\n\nfunction updateAngle(angleVar: Variable, aPos: Position, bPos: Position) {\n  const currAngle = normalizeAngle(angleVar.value);\n  const newAngle = normalizeAngle(Vec.angle(Vec.sub(bPos, aPos)));\n  let diff = normalizeAngle(newAngle - currAngle);\n  if (diff > Math.PI) {\n    diff -= TAU;\n  }\n  angleVar.value += diff;\n}\n\n/** Returns the equivalent angle in the range [0, 2pi) */\nfunction normalizeAngle(angle: number) {\n  return ((angle % TAU) + TAU) % TAU;\n}\n\nclass LLFormula extends LowLevelConstraint {\n  readonly result: Variable;\n\n  constructor(\n    constraint: Constraint,\n    readonly args: Variable[],\n    private readonly fn: (xs: number[]) => number\n  ) {\n    super();\n    this.result = variable(this.computeResult(), {\n      object: constraint,\n      property: 'result',\n    });\n    this.variables.push(...args, this.result);\n    this.ownVariables.add(this.result);\n  }\n\n  addTo(constraints: LowLevelConstraint[]) {\n    constraints.push(this);\n  }\n\n  propagateKnowns(knowns: Set<Variable>) {\n    if (\n      !knowns.has(this.result.canonicalInstance) &&\n      this.args.every(arg => knowns.has(arg.canonicalInstance))\n    ) {\n      this.result.value = this.computeResult();\n      knowns.add(this.result.canonicalInstance);\n    }\n  }\n\n  getError(\n    variableValues: number[],\n    knowns: Set<Variable>,\n    freeVariables: Set<Variable>\n  ): number {\n    const currValue = this.computeResult(variableValues);\n    if (freeVariables.has(this.result.canonicalInstance)) {\n      this.result.value = currValue;\n    }\n    return currValue - this.result.value;\n  }\n\n  private computeResult(\n    xs: number[] = this.args.map(arg => arg.value)\n  ): number {\n    return this.fn(xs);\n  }\n}\n\n// #endregion low-level constraints\n\n// #region high-level constraints\n\nexport abstract class Constraint {\n  static readonly all = new Set<Constraint>();\n\n  private _paused = false;\n\n  get paused() {\n    return this._paused;\n  }\n\n  set paused(newValue: boolean) {\n    if (newValue !== this._paused) {\n      this._paused = newValue;\n      forgetClustersForSolver();\n    }\n  }\n\n  readonly variables = [] as Variable[];\n  readonly lowLevelConstraints = [] as LowLevelConstraint[];\n\n  constructor() {\n    Constraint.all.add(this);\n    forgetClustersForSolver();\n  }\n\n  /**\n   * In this constraint system, equality is not a constraint but rather a\n   * relationship between two variables that is maintained by unifying the two\n   * variables. This method should be overridden by constraints that need to\n   * set up equalities between variables and/or, more generally, linear\n   * relationships between variables. This is done by calling Variable's\n   * makeEqualTo() method. E.g., y.makeEqualTo(x, { m: 3, b: 1 }) sets up\n   * the linear relationship y = 3 * x + b.\n   */\n  setUpVariableRelationships() {}\n\n  /**\n   * If this constraint can determine the values of any variables based on\n   * other state that is already known, it should set the values of those\n   * variables and add them to `knowns`.\n   *\n   * Subclasses may override this method, but should always call\n   * super.addKnowns(knowns) at the end!\n   */\n  propagateKnowns(knowns: Set<Variable>) {\n    for (const llc of this.lowLevelConstraints) {\n      llc.propagateKnowns(knowns);\n    }\n  }\n\n  /** Returns the set of (canonical) variables that are referenced by this constraint. */\n  getManipulationSet(): Set<Variable> {\n    return new Set(this.variables.map(v => v.canonicalInstance));\n  }\n\n  public remove() {\n    if (!Constraint.all.has(this)) {\n      // needed to break cycles\n      return;\n    }\n\n    Constraint.all.delete(this);\n    for (const llc of this.lowLevelConstraints) {\n      for (const v of llc.ownVariables) {\n        // this will result in other constraints that involve this variable\n        // being removed as well\n        v.remove();\n      }\n    }\n    forgetClustersForSolver();\n  }\n}\n\nexport class Constant extends Constraint {\n  private static readonly memo = new Map<Variable, Constant>();\n\n  static create(variable: Variable, value: number = variable.value) {\n    let constant = Constant.memo.get(variable);\n    if (constant) {\n      constant.value = value;\n    } else {\n      constant = new Constant(variable, value);\n      Constant.memo.set(variable, constant);\n    }\n    return constant;\n  }\n\n  private constructor(\n    public readonly variable: Variable,\n    public value: number\n  ) {\n    super();\n    this.variables.push(variable);\n  }\n\n  propagateKnowns(knowns: Set<Variable>) {\n    if (!knowns.has(this.variable.canonicalInstance)) {\n      this.variable.value = this.value;\n      knowns.add(this.variable.canonicalInstance);\n    }\n    super.propagateKnowns(knowns);\n  }\n\n  public remove() {\n    Constant.memo.delete(this.variable);\n    super.remove();\n  }\n}\n\nexport const constant = Constant.create;\n\nabstract class PinLikeConstraint extends Constraint {\n  constructor(\n    public readonly handle: Handle,\n    public position: Position\n  ) {\n    super();\n    this.variables.push(handle.xVariable, handle.yVariable);\n  }\n\n  propagateKnowns(knowns: Set<Variable>) {\n    const { xVariable: x, yVariable: y } = this.handle;\n    if (!knowns.has(x.canonicalInstance) || !knowns.has(y.canonicalInstance)) {\n      ({ x: x.value, y: y.value } = this.position);\n      knowns.add(x.canonicalInstance);\n      knowns.add(y.canonicalInstance);\n    }\n    super.propagateKnowns(knowns);\n  }\n}\n\nexport class Pin extends PinLikeConstraint {\n  private static readonly memo = new Map<Handle, Pin>();\n\n  static create(handle: Handle, position: Position = handle.position) {\n    let pin = Pin.memo.get(handle);\n    if (pin) {\n      pin.position = position;\n    } else {\n      pin = new Pin(handle, position);\n      Pin.memo.set(handle, pin);\n    }\n    return pin;\n  }\n\n  private constructor(handle: Handle, position: Position) {\n    super(handle, position);\n  }\n\n  public remove() {\n    Pin.memo.delete(this.handle);\n    super.remove();\n  }\n}\n\nexport const pin = Pin.create;\n\nexport class Finger extends PinLikeConstraint {\n  private static readonly memo = new Map<Handle, Finger>();\n\n  static create(handle: Handle, position: Position = handle.position) {\n    let finger = Finger.memo.get(handle);\n    if (finger) {\n      finger.position = position;\n    } else {\n      finger = new Finger(handle, position);\n      Finger.memo.set(handle, finger);\n    }\n    return finger;\n  }\n\n  private constructor(handle: Handle, position: Position) {\n    super(handle, position);\n  }\n\n  public remove() {\n    Finger.memo.delete(this.handle);\n    super.remove();\n  }\n}\n\nexport const finger = Finger.create;\n\nexport class LinearRelationship extends Constraint {\n  private static readonly memo = new Map<\n    Variable,\n    Map<Variable, LinearRelationship>\n  >();\n\n  static create(y: Variable, m: number, x: Variable, b: number) {\n    if (m === 0) {\n      throw new Error('tried to create a linear relationship w/ m = 0');\n    }\n\n    let lr = LinearRelationship.memo.get(y)?.get(x);\n    if (lr) {\n      lr.m = m;\n      lr.b = b;\n      return lr;\n    }\n\n    lr = LinearRelationship.memo.get(x)?.get(y);\n    if (lr) {\n      lr.m = 1 / m;\n      lr.b = -b / m;\n      return lr;\n    }\n\n    lr = new LinearRelationship(y, m, x, b);\n    if (!LinearRelationship.memo.has(y)) {\n      LinearRelationship.memo.set(y, new Map());\n    }\n    LinearRelationship.memo.get(y)!.set(x, lr);\n    return lr;\n  }\n\n  private constructor(\n    readonly y: Variable,\n    private m: number,\n    readonly x: Variable,\n    private b: number\n  ) {\n    super();\n    this.variables.push(y, x);\n  }\n\n  setUpVariableRelationships() {\n    this.y.makeEqualTo(this.x, { m: this.m, b: this.b });\n  }\n\n  public remove() {\n    const yDict = LinearRelationship.memo.get(this.y);\n    if (yDict) {\n      yDict.delete(this.x);\n      if (yDict.size === 0) {\n        LinearRelationship.memo.delete(this.y);\n      }\n    }\n\n    const xDict = LinearRelationship.memo.get(this.x);\n    if (xDict) {\n      xDict.delete(this.y);\n      if (xDict.size === 0) {\n        LinearRelationship.memo.delete(this.x);\n      }\n    }\n\n    super.remove();\n  }\n}\n\nexport const linearRelationship = LinearRelationship.create;\n\nexport const equals = (x: Variable, y: Variable) =>\n  linearRelationship(y, 1, x, 0);\n\nexport class Absorb extends Constraint {\n  // child handle -> Absorb constraint\n  private static readonly memo = new Map<Handle, Absorb>();\n\n  static create(parent: Handle, child: Handle) {\n    if (Absorb.memo.has(child)) {\n      Absorb.memo.get(child)!.remove();\n    }\n\n    const a = new Absorb(parent, child);\n    Absorb.memo.set(child, a);\n    return a;\n  }\n\n  private constructor(\n    readonly parent: Handle,\n    readonly child: Handle\n  ) {\n    super();\n    this.variables.push(\n      parent.xVariable,\n      parent.yVariable,\n      child.xVariable,\n      child.yVariable\n    );\n  }\n\n  setUpVariableRelationships() {\n    this.parent.xVariable.makeEqualTo(this.child.xVariable);\n    this.parent.yVariable.makeEqualTo(this.child.yVariable);\n    this.parent._absorb(this.child);\n  }\n\n  public remove() {\n    Absorb.memo.delete(this.child);\n    super.remove();\n  }\n}\n\nexport const absorb = Absorb.create;\n\nexport class PolarVector extends Constraint {\n  private static readonly memo = new Map<Handle, Map<Handle, PolarVector>>();\n\n  static create(a: Handle, b: Handle) {\n    let pv = PolarVector.memo.get(a)?.get(b);\n    if (pv) {\n      return pv;\n    }\n\n    pv = new PolarVector(a, b);\n    if (!PolarVector.memo.get(a)) {\n      PolarVector.memo.set(a, new Map());\n    }\n    PolarVector.memo.get(a)!.set(b, pv);\n    return pv;\n  }\n\n  readonly distance: Variable;\n  readonly angle: Variable;\n\n  private constructor(\n    readonly a: Handle,\n    readonly b: Handle\n  ) {\n    super();\n\n    const dc = new Distance(this, a, b);\n    this.lowLevelConstraints.push(dc);\n    this.distance = dc.distance;\n\n    const ac = new Angle(this, a, b);\n    this.lowLevelConstraints.push(ac);\n    this.angle = ac.angle;\n\n    this.variables.push(\n      a.xVariable,\n      a.yVariable,\n      b.xVariable,\n      b.yVariable,\n      this.distance,\n      this.angle\n    );\n  }\n\n  public remove() {\n    const aDict = PolarVector.memo.get(this.a)!;\n    aDict.delete(this.b);\n    if (aDict.size === 0) {\n      PolarVector.memo.delete(this.a);\n    }\n    super.remove();\n  }\n}\n\nexport const polarVector = PolarVector.create;\n\nexport class Formula extends Constraint {\n  static create(args: Variable[], fn: (xs: number[]) => number) {\n    return new Formula(args, fn);\n  }\n\n  readonly result: Variable;\n\n  private constructor(args: Variable[], fn: (xs: number[]) => number) {\n    super();\n    const fc = new LLFormula(this, args, fn);\n    this.lowLevelConstraints.push(fc);\n    this.result = fc.result;\n    this.variables.push(...args, this.result);\n  }\n}\n\nexport const formula = Formula.create;\n\n// #endregion high-level constraints\n\n// #region solver\n\n/**\n * A group of constraints and variables that they operate on that should be solved together.\n */\ninterface ClusterForSolver {\n  constraints: Constraint[];\n  lowLevelConstraints: LowLevelConstraint[];\n  variables: Variable[];\n  // Set of variables that are \"free\". The value of each of these variables can be set by\n  // their owning low-level constraint's `getError` method in order to make the error due\n  // to that constraint equal to zero.\n  freeVariables: Set<Variable>;\n}\n\nlet clustersForSolver: Set<ClusterForSolver> | null = null;\n\nfunction getClustersForSolver(root: GameObject): Set<ClusterForSolver> {\n  if (clustersForSolver) {\n    return clustersForSolver;\n  }\n\n  // break up all relationships between handles ...\n  root.forEach({\n    what: aHandle,\n    recursive: true,\n    do(handle) {\n      handle._forgetAbsorbedHandles();\n    },\n  });\n  // ... and variables\n  for (const variable of Variable.all) {\n    variable.info = { isCanonical: true, absorbedVariables: new Set() };\n  }\n\n  // ignore constraints that are paused\n  const activeConstraints = [...Constraint.all].filter(\n    constraint => !constraint.paused\n  );\n\n  // set up updated relationships among handles and variables\n  for (const constraint of activeConstraints) {\n    constraint.setUpVariableRelationships();\n  }\n\n  clustersForSolver = computeClusters(activeConstraints);\n  forDebugging('clusters', clustersForSolver);\n  SVG.showStatus(`${clustersForSolver.size} clusters`);\n\n  return clustersForSolver;\n}\n\nfunction computeClusters(\n  activeConstraints: Constraint[]\n): Set<ClusterForSolver> {\n  interface Cluster {\n    constraints: Constraint[];\n    lowLevelConstraints: LowLevelConstraint[];\n    manipulationSet: Set<Variable>;\n  }\n  const clusters = new Set<Cluster>();\n  for (const constraint of activeConstraints) {\n    const constraints = [constraint];\n    const lowLevelConstraints = [...constraint.lowLevelConstraints];\n    let manipulationSet = constraint.getManipulationSet();\n    for (const cluster of clusters) {\n      if (!sets.overlap(cluster.manipulationSet, manipulationSet)) {\n        continue;\n      }\n\n      constraints.push(...cluster.constraints);\n      for (const llc of cluster.lowLevelConstraints) {\n        llc.addTo(lowLevelConstraints);\n      }\n\n      // this step must be done *after* adding the LLCs b/c that operation creates new\n      // linear relationships among variables (i.e., variables are absorbed as a result)\n      manipulationSet = new Set(\n        [...manipulationSet, ...cluster.manipulationSet].map(\n          v => v.canonicalInstance\n        )\n      );\n\n      clusters.delete(cluster);\n    }\n    clusters.add({ constraints, lowLevelConstraints, manipulationSet });\n  }\n  return sets.map(clusters, ({ constraints, lowLevelConstraints }) =>\n    createClusterForSolver(constraints, lowLevelConstraints)\n  );\n}\n\nfunction createClusterForSolver(\n  constraints: Constraint[],\n  lowLevelConstraints: LowLevelConstraint[]\n): ClusterForSolver {\n  const knowns = computeKnowns(constraints, lowLevelConstraints);\n\n  const variables = new Set<Variable>();\n  for (const constraint of constraints) {\n    for (const variable of constraint.variables) {\n      if (!knowns.has(variable.canonicalInstance)) {\n        variables.add(variable.canonicalInstance);\n      }\n    }\n  }\n\n  const freeVariableCandidates = new Set<Variable>();\n  for (const llc of lowLevelConstraints) {\n    for (const variable of llc.ownVariables) {\n      if (!knowns.has(variable.canonicalInstance)) {\n        freeVariableCandidates.add(variable.canonicalInstance);\n      }\n    }\n  }\n\n  const freeVarCandidateCounts = new Map<Variable, number>();\n  for (const llc of lowLevelConstraints) {\n    for (const variable of llc.variables) {\n      if (!freeVariableCandidates.has(variable.canonicalInstance)) {\n        continue;\n      }\n\n      const n = freeVarCandidateCounts.get(variable.canonicalInstance) ?? 0;\n      freeVarCandidateCounts.set(variable.canonicalInstance, n + 1);\n    }\n  }\n\n  const freeVariables = new Set<Variable>();\n  for (const [variable, count] of freeVarCandidateCounts.entries()) {\n    if (count === 1) {\n      freeVariables.add(variable.canonicalInstance);\n    }\n  }\n\n  return {\n    constraints,\n    lowLevelConstraints,\n    variables: Array.from(variables),\n    freeVariables,\n  };\n}\n\nfunction forgetClustersForSolver() {\n  clustersForSolver = null;\n}\n\nexport function solve(root: GameObject) {\n  const clusters = getClustersForSolver(root);\n  for (const cluster of clusters) {\n    solveCluster(cluster);\n  }\n}\n\nfunction solveCluster(cluster: ClusterForSolver) {\n  const { constraints, lowLevelConstraints, variables } = cluster;\n  let { freeVariables } = cluster;\n\n  if (constraints.length === 0) {\n    // nothing to solve!\n    return;\n  }\n\n  const knowns = computeKnowns(constraints, lowLevelConstraints);\n\n  // Let the user to modify the locked distance or angle of a polar vector\n  // constraint by manipulating the handles with their fingers.\n  const handlesWithFingers = getHandlesWithFingers(constraints);\n  for (const pv of constraints) {\n    if (\n      pv instanceof PolarVector &&\n      handlesWithFingers.has(pv.a.canonicalInstance) &&\n      handlesWithFingers.has(pv.b.canonicalInstance)\n    ) {\n      for (const k of constraints) {\n        if (\n          k instanceof Constant &&\n          (k.variable.hasLinearRelationshipWith(pv.distance) ||\n            k.variable.hasLinearRelationshipWith(pv.angle))\n        ) {\n          // TODO: do we need to do this to the siblings too? (to avoid getting out of step)\n          k.value = k.variable.value;\n        }\n      }\n    }\n  }\n\n  // Hack to avoid gizmos' handles converging as user scrubs the angle\n  // TODO: make sure this doesn't break anything!\n  let gizmoHack = false;\n  for (const pv of constraints) {\n    if (\n      pv instanceof PolarVector &&\n      pv.angle.isScrubbing &&\n      freeVariables.has(pv.distance.canonicalInstance)\n    ) {\n      gizmoHack = true;\n      knowns.add(pv.distance.canonicalInstance);\n    }\n  }\n  if (gizmoHack) {\n    freeVariables = new Set(\n      [...freeVariables].filter(fv => !knowns.has(fv.canonicalInstance))\n    );\n  }\n\n  // The state that goes into `inputs` is the stuff that can be modified by the solver.\n  // It excludes any value that we've already computed from known values like pin and\n  // constant constraints.\n  const inputs: number[] = [];\n  const varIdx = new Map<Variable, number>();\n  for (const variable of variables) {\n    if (\n      variable.isCanonicalInstance &&\n      !knowns.has(variable) &&\n      !freeVariables.has(variable)\n    ) {\n      varIdx.set(variable, inputs.length);\n      inputs.push(variable.value);\n    }\n  }\n\n  // This is where we actually run the solver.\n\n  function computeTotalError(currState: number[]) {\n    let error = 0;\n    for (const llc of lowLevelConstraints) {\n      const values = llc.variables.map(variable => {\n        const { m, b } = variable.offset;\n        variable = variable.canonicalInstance;\n        const vi = varIdx.get(variable);\n        return ((vi === undefined ? variable.value : currState[vi]) - b) / m;\n      });\n      error += Math.pow(llc.getError(values, knowns, freeVariables), 2);\n    }\n    return error;\n  }\n\n  if (inputs.length === 0) {\n    // No variables to solve for, but we still need to assign the correct values\n    // to free variables. We do this by calling computeTotalError() below.\n    computeTotalError(inputs);\n    return;\n  }\n\n  let result: ReturnType<typeof minimize>;\n  try {\n    result = minimize(computeTotalError, inputs, 1_000, 1e-3);\n  } catch (e) {\n    console.log(\n      'minimizeError threw',\n      e,\n      'while working on cluster',\n      cluster,\n      'with knowns',\n      knowns\n    );\n    SVG.showStatus('' + e);\n    throw e;\n  }\n\n  // SVG.showStatus(`${result.iterations} iterations`);\n  forDebugging('solverResult', result);\n  forDebugging('solverResultMessages', (messages?: Set<string>) => {\n    if (!messages) {\n      messages = new Set();\n    }\n    messages.add(result.message);\n    return messages;\n  });\n  if (!result || result.message?.includes('maxit')) {\n    // console.error(\n    //   'solveCluster gave up with result',\n    //   result,\n    //   'while working on',\n    //   cluster\n    // );\n    // const lastConstraint = constraints[constraints.length - 1];\n    // lastConstraint.paused = true;\n    // console.log('paused', lastConstraint, 'to see if it helps');\n    return;\n  }\n\n  // Now we write the solution from the solver back into our variables and handles.\n  const outputs = result.solution;\n  for (const variable of variables) {\n    if (\n      variable.isCanonicalInstance &&\n      !knowns.has(variable) &&\n      !freeVariables.has(variable)\n    ) {\n      variable.value = outputs.shift()!;\n    }\n  }\n}\n\nfunction computeKnowns(\n  constraints: Constraint[],\n  lowLevelConstraints: LowLevelConstraint[]\n) {\n  const knowns = new Set<Variable>();\n  while (true) {\n    const oldNumKnowns = knowns.size;\n\n    // do finger and polar vector constraints first\n    // (that way the user can set gizmo distances and angles w/ fingers)\n    for (const constraint of constraints) {\n      if (constraint instanceof Finger) {\n        constraint.propagateKnowns(knowns);\n      }\n    }\n    for (const constraint of constraints) {\n      if (constraint instanceof PolarVector) {\n        constraint.propagateKnowns(knowns);\n      }\n    }\n\n    // ... then do other constraints\n    for (const constraint of constraints) {\n      if (\n        !(constraint instanceof Finger || constraint instanceof PolarVector)\n      ) {\n        constraint.propagateKnowns(knowns);\n      }\n    }\n\n    // ... and the low-level constraints\n    for (const llc of lowLevelConstraints) {\n      llc.propagateKnowns(knowns);\n    }\n\n    if (knowns.size === oldNumKnowns) {\n      break;\n    }\n  }\n  return knowns;\n}\n\nfunction getHandlesWithFingers(constraints: Constraint[]) {\n  const handlesWithFingers = new Set<Handle>();\n  for (const constraint of constraints) {\n    if (constraint instanceof Finger) {\n      handlesWithFingers.add(constraint.handle.canonicalInstance);\n    }\n  }\n  return handlesWithFingers;\n}\n\n// #endregion solver\n"],
  "mappings": "AACA;AACA;AACA;AACA;AACA;AAEA;AAkBO,wBAAe;AAAA,EAcZ,YACE,SAAiB,GACzB,YACA;AAFQ;AARD,cAAK;AACd,gBAAqB;AAAA,MACnB,aAAa;AAAA,MACb,mBAAmB,IAAI;AAAA;AAqKzB,uBAAc;AA7JZ,SAAK,aAAa;AAClB,cAAS,IAAI,IAAI;AAAA;AAAA,SAhBZ,OAAO,QAAQ,GAAG,YAAmD;AAC1E,WAAO,IAAI,UAAS,OAAO;AAAA;AAAA,EAmB7B,SAAS;AACP,QAAI,CAAC,UAAS,IAAI,IAAI,OAAO;AAE3B;AAAA;AAGF,cAAS,IAAI,OAAO;AACpB,eAAW,cAAc,WAAW,KAAK;AACvC,UAAI,WAAW,UAAU,SAAS,OAAO;AACvC,mBAAW;AAAA;AAAA;AAAA;AAAA,MAKb,sBAAsB;AACxB,WAAO,KAAK,KAAK;AAAA;AAAA,MAGf,oBAA8B;AAChC,WAAO,KAAK,KAAK,cAAc,OAAO,KAAK,KAAK;AAAA;AAAA,MAG9C,SAAS;AACX,WAAO,KAAK,KAAK,cAAc,CAAE,GAAG,GAAG,GAAG,KAAM,KAAK,KAAK;AAAA;AAAA,MAGxD,QAAQ;AACV,WAAO,KAAK;AAAA;AAAA,MAGV,MAAM,UAAkB;AAC1B,QAAI,KAAK,KAAK,aAAa;AACzB,WAAK,SAAS;AACd,iBAAW,QAAQ,KAAK,KAAK,mBAAmB;AAC9C,cAAM,CAAE,GAAG,KAAO,KAAK,KAA8B;AACrD,aAAK,SAAU,YAAW,KAAK;AAAA;AAAA,WAE5B;AACL,WAAK,KAAK,kBAAkB,QAAQ,KAAK,iBAAiB;AAAA;AAAA;AAAA,EAI9D,iBAAiB,OAAe;AAC9B,QAAI,KAAK,KAAK,aAAa;AACzB,aAAO;AAAA;AAGT,UAAM,CAAE,GAAG,KAAM,KAAK,KAAK;AAC3B,WAAO,IAAI,QAAQ;AAAA;AAAA,EAIrB,YAAY,MAAgB,SAAS,CAAE,GAAG,GAAG,GAAG,IAAK;AACnD,QAAI,SAAS,MAAM;AACjB;AAAA,eACS,CAAC,KAAK,KAAK,aAAa;AACjC,YAAM,CAAE,GAAG,OAAO,GAAG,SAAU;AAC/B,YAAM,CAAE,GAAG,OAAO,GAAG,SAAU,KAAK;AAIpC,WAAK,kBAAkB,YAAY,MAAM;AAAA,QACvC,GAAG,QAAQ;AAAA,QACX,GAAG,QAAQ,QAAQ;AAAA;AAErB;AAAA,eACS,CAAC,KAAK,KAAK,aAAa;AACjC,YAAM,CAAE,GAAG,OAAO,GAAG,SAAU,KAAK;AACpC,YAAM,CAAE,GAAG,KAAM;AAIjB,WAAK,YAAY,KAAK,mBAAmB;AAAA,QACvC,GAAG,IAAI;AAAA,QACP,GAAG,IAAI,QAAQ;AAAA;AAEjB;AAAA;AAGF,UAAM,qBAAqB,KAAK;AAEhC,eAAW,iBAAiB,KAAK,KAAK,mBAAmB;AACvD,YAAM,oBAAoB,cAAc;AACxC,wBAAkB,oBAAoB;AAEtC,wBAAkB,SAAS;AAAA,QACzB,GAAG,OAAO,IAAI,kBAAkB,OAAO;AAAA,QACvC,GAAG,OAAO,IAAI,kBAAkB,OAAO,IAAI,OAAO;AAAA;AAEpD,WAAK,KAAK,kBAAkB,IAAI;AAAA;AAGlC,SAAK,OAAO;AAAA,MACV,aAAa;AAAA,MACb,mBAAmB;AAAA,MACnB;AAAA;AAEF,SAAK,KAAK,kBAAkB,IAAI;AAMhC,SAAK,QAAQ,KAAK;AAElB,QAAI,sBAAsB,KAAK,UAAU;AACvC,WAAK;AAAA,WACA;AACL,WAAK;AAAA;AAAA;AAAA,EAIT,qBAAqB;AACnB,QAAI,KAAK,KAAK,aAAa;AAAA,WAEpB;AACL,WAAK,KAAK,kBAAkB,SAAS;AAAA;AAAA;AAAA,EAIzC,SAAS,MAAgB;AACvB,QAAI,CAAC,KAAK,KAAK,aAAa;AAC1B,YAAM,IAAI,MAAM;AAAA;AAElB,QAAI,CAAC,KAAK,KAAK,kBAAkB,IAAI,OAAO;AAC1C,YAAM,IAAI,MAAM;AAAA;AAGlB,SAAK,KAAK,kBAAkB,OAAO;AACnC,SAAK,OAAO,CAAE,aAAa,MAAM,mBAAmB,IAAI;AAExD,QAAI,KAAK,UAAU;AACjB,WAAK;AAAA;AAGP;AAAA;AAAA,MAGE,iBAAkC;AACpC,eAAW,KAAK,WAAW,KAAK;AAC9B,UAAI,aAAa,YAAY,EAAE,aAAa,KAAK,mBAAmB;AAClE,eAAO;AAAA;AAAA;AAGX,WAAO;AAAA;AAAA,MAGL,WAAW;AACb,WAAO,CAAC,CAAC,KAAK;AAAA;AAAA,EAMhB,KAAK,OAAgB,QAAQ,OAAO;AAClC,QAAI,CAAC,KAAK,KAAK,aAAa;AAC1B,WAAK,kBAAkB,KACrB,UAAU,SAAY,KAAK,iBAAiB,SAAS,QACrD;AAEF;AAAA;AAGF,QAAI,UAAU,QAAW;AACvB,WAAK,QAAQ;AAAA;AAEf,eAAW,aAAY,CAAC,MAAM,GAAG,KAAK,KAAK,oBAAoB;AAC7D,eAAS;AACT,gBAAS,cAAc;AAAA;AAAA;AAAA,EAI3B,SAAS;AACP,QAAI,CAAC,KAAK,KAAK,aAAa;AAC1B,WAAK,kBAAkB;AACvB;AAAA;AAGF,eAAW,aAAY,CAAC,MAAM,GAAG,KAAK,KAAK,oBAAoB;AAC7D,eAAS,WAAU;AACnB,gBAAS,cAAc;AAAA;AAAA;AAAA,EAI3B,aAAa;AACX,QAAI,KAAK,UAAU;AACjB,WAAK;AAAA,WACA;AACL,WAAK;AAAA;AAAA;AAAA,EAIT,OAAO,MAAgB;AACrB,WACG,KAAK,sBAAsB,QAC1B,KAAK,OAAO,MAAM,KAClB,KAAK,OAAO,MAAM,KACnB,KAAK,sBAAsB,QAC1B,KAAK,OAAO,MAAM,KAClB,KAAK,OAAO,MAAM,KACnB,KAAK,sBAAsB,KAAK,qBAC/B,KAAK,OAAO,MAAM,KAAK,OAAO,KAC9B,KAAK,OAAO,MAAM,KAAK,OAAO;AAAA;AAAA,EAIpC,0BAA0B,MAAgB;AACxC,WAAO,KAAK,sBAAsB,KAAK;AAAA;AAAA;AAtOpC;AACW,AADX,SACW,MAAM,IAAI;AAyOrB,aAAM,WAAW,SAAS;AAMjC,yBAAkC;AAAA,EAAlC,cAzQA;AA0QW,qBAAY;AACZ,wBAAe,IAAI;AAAA;AAAA,EAgB5B,gBAAgB,QAAuB;AAAA;AAAA;AAezC,uBAAuB,mBAAmB;AAAA,EACxC,YACE,YACgB,GACA,GAChB;AACA;AAHgB;AACA;AAGhB,SAAK,UAAU,KACb,SAAS,IAAI,KAAK,EAAE,UAAU,EAAE,WAAW;AAAA,MACzC,QAAQ;AAAA,MACR,UAAU;AAAA,QAEZ,EAAE,WACF,EAAE,WACF,EAAE,WACF,EAAE;AAEJ,SAAK,aAAa,IAAI,KAAK;AAAA;AAAA,MAGzB,WAAW;AACb,WAAO,KAAK,UAAU;AAAA;AAAA,EAGxB,MAAM,aAAmC;AACvC,eAAW,QAAQ,aAAa;AAC9B,UACE,gBAAgB,YACd,MAAK,EAAE,OAAO,KAAK,MAAM,KAAK,EAAE,OAAO,KAAK,MAC3C,KAAK,EAAE,OAAO,KAAK,MAAM,KAAK,EAAE,OAAO,KAAK,KAC/C;AACA,aAAK,SAAS,YAAY,KAAK;AAC/B;AAAA;AAAA;AAIJ,gBAAY,KAAK;AAAA;AAAA,EAGnB,gBAAgB,QAAuB;AACrC,QACE,CAAC,OAAO,IAAI,KAAK,SAAS,sBAC1B,OAAO,IAAI,KAAK,EAAE,UAAU,sBAC5B,OAAO,IAAI,KAAK,EAAE,UAAU,sBAC5B,OAAO,IAAI,KAAK,EAAE,UAAU,sBAC5B,OAAO,IAAI,KAAK,EAAE,UAAU,oBAC5B;AACA,WAAK,SAAS,QAAQ,IAAI,KAAK,KAAK,GAAG,KAAK;AAC5C,aAAO,IAAI,KAAK,SAAS;AAAA;AAAA;AAAA,EAI7B,SACE,CAAC,MAAM,IAAI,IAAI,IAAI,KACnB,QACA,eACQ;AACR,UAAM,OAAO,CAAE,GAAG,IAAI,GAAG;AACzB,UAAM,OAAO,CAAE,GAAG,IAAI,GAAG;AACzB,UAAM,WAAW,IAAI,KAAK,MAAM;AAChC,QAAI,cAAc,IAAI,KAAK,SAAS,oBAAoB;AACtD,WAAK,SAAS,QAAQ;AAAA;AAExB,WAAO,WAAW;AAAA;AAAA;AAItB,oBAAoB,mBAAmB;AAAA,EACrC,YACE,YACgB,GACA,GAChB;AACA;AAHgB;AACA;AAGhB,SAAK,UAAU,KACb,SAAS,IAAI,MAAM,IAAI,IAAI,EAAE,UAAU,EAAE,YAAY;AAAA,MACnD,QAAQ;AAAA,MACR,UAAU;AAAA,QAEZ,EAAE,WACF,EAAE,WACF,EAAE,WACF,EAAE;AAEJ,SAAK,aAAa,IAAI,KAAK;AAAA;AAAA,MAGzB,QAAQ;AACV,WAAO,KAAK,UAAU;AAAA;AAAA,EAGxB,MAAM,aAAmC;AACvC,eAAW,QAAQ,aAAa;AAC9B,UAAI,CAAE,iBAAgB,QAAQ;AAC5B;AAAA,iBACS,KAAK,EAAE,OAAO,KAAK,MAAM,KAAK,EAAE,OAAO,KAAK,IAAI;AACzD,aAAK,MAAM,YAAY,KAAK;AAC5B;AAAA,iBACS,KAAK,EAAE,OAAO,KAAK,MAAM,KAAK,EAAE,OAAO,KAAK,IAAI;AACzD,aAAK,MAAM,YAAY,KAAK,OAAO,CAAE,GAAG,GAAG,GAAG,KAAK;AACnD;AAAA;AAAA;AAIJ,gBAAY,KAAK;AAAA;AAAA,EAGnB,gBAAgB,QAAuB;AACrC,QACE,CAAC,OAAO,IAAI,KAAK,UACjB,OAAO,IAAI,KAAK,EAAE,UAAU,sBAC5B,OAAO,IAAI,KAAK,EAAE,UAAU,sBAC5B,OAAO,IAAI,KAAK,EAAE,UAAU,sBAC5B,OAAO,IAAI,KAAK,EAAE,UAAU,oBAC5B;AACA,kBAAY,KAAK,OAAO,KAAK,GAAG,KAAK;AACrC,aAAO,IAAI,KAAK,MAAM;AAAA;AAAA;AAAA,EAI1B,SACE,CAAC,OAAO,IAAI,IAAI,IAAI,KACpB,QACA,eACQ;AAUR,UAAM,OAAO,CAAE,GAAG,IAAI,GAAG;AACzB,UAAM,OAAO,CAAE,GAAG,IAAI,GAAG;AACzB,QAAI,cAAc,IAAI,KAAK,MAAM,oBAAoB;AACnD,kBAAY,KAAK,OAAO,MAAM;AAC9B,aAAO;AAAA;AAGT,UAAM,IAAI,IAAI,KAAK,MAAM;AACzB,QAAI,QAAQ;AAEZ,QACE,CAAC,OAAO,IAAI,KAAK,EAAE,UAAU,sBAC7B,CAAC,OAAO,IAAI,KAAK,EAAE,UAAU,oBAC7B;AACA,YAAM,IAAI,KAAK,IAAI,KAAK,IAAI;AAC5B,YAAM,IAAI,KAAK,IAAI,KAAK,IAAI;AAC5B,cAAQ,KAAK,IAAI,OAAO,IAAI,KAAK,MAAM,CAAE,GAAG;AAAA,eACnC,CAAC,OAAO,IAAI,KAAK,EAAE,UAAU,oBAAoB;AAC1D,YAAM,IAAI,KAAM,MAAK,MAAM,KAAK,IAAI;AACpC,cAAQ,KAAK,IAAI,OAAO,KAAK,IAAI,IAAI;AAAA,eAC5B,CAAC,OAAO,IAAI,KAAK,EAAE,UAAU,oBAAoB;AAC1D,YAAM,IAAI,KAAM,MAAK,MAAM,KAAK,IAAI;AACpC,cAAQ,KAAK,IAAI,OAAO,KAAK,IAAI,IAAI;AAAA;AAGvC,QACE,CAAC,OAAO,IAAI,KAAK,EAAE,UAAU,sBAC7B,CAAC,OAAO,IAAI,KAAK,EAAE,UAAU,oBAC7B;AACA,YAAM,IAAI,KAAK,IAAI,KAAK,IAAI,QAAQ,KAAK;AACzC,YAAM,IAAI,KAAK,IAAI,KAAK,IAAI,QAAQ,KAAK;AACzC,cAAQ,KAAK,IAAI,OAAO,IAAI,KAAK,MAAM,CAAE,GAAG;AAAA,eACnC,CAAC,OAAO,IAAI,KAAK,EAAE,UAAU,oBAAoB;AAC1D,YAAM,IAAI,KAAM,MAAK,MAAM,KAAK,IAAI,QAAQ,KAAK;AACjD,cAAQ,KAAK,IAAI,OAAO,KAAK,IAAI,IAAI;AAAA,eAC5B,CAAC,OAAO,IAAI,KAAK,EAAE,UAAU,oBAAoB;AAC1D,YAAM,IAAI,KAAM,MAAK,MAAM,KAAK,IAAI,QAAQ,KAAK;AACjD,cAAQ,KAAK,IAAI,OAAO,KAAK,IAAI,IAAI;AAAA;AAGvC,QAAI,CAAC,OAAO,SAAS,QAAQ;AAI3B,cAAQ,KAAK,IAEX,IAAI,KAAK,MAAM;AAAA,QACb,GAAG,KAAK,IAAI,KAAK,IAAI;AAAA,QACrB,GAAG,KAAK,IAAI,KAAK,IAAI;AAAA,UAGvB,IAAI,KAAK,MAAM;AAAA,QACb,GAAG,KAAK,IAAI,KAAK,IAAI,QAAQ,KAAK;AAAA,QAClC,GAAG,KAAK,IAAI,KAAK,IAAI,QAAQ,KAAK;AAAA;AAAA;AAKxC,WAAO;AAAA;AAAA;AAIX,qBAAqB,UAAoB,MAAgB,MAAgB;AACvE,QAAM,YAAY,eAAe,SAAS;AAC1C,QAAM,WAAW,eAAe,IAAI,MAAM,IAAI,IAAI,MAAM;AACxD,MAAI,OAAO,eAAe,WAAW;AACrC,MAAI,OAAO,KAAK,IAAI;AAClB,YAAQ;AAAA;AAEV,WAAS,SAAS;AAAA;AAIpB,wBAAwB,OAAe;AACrC,SAAS,SAAQ,MAAO,OAAO;AAAA;AAGjC,wBAAwB,mBAAmB;AAAA,EAGzC,YACE,YACS,MACQ,IACjB;AACA;AAHS;AACQ;AAGjB,SAAK,SAAS,SAAS,KAAK,iBAAiB;AAAA,MAC3C,QAAQ;AAAA,MACR,UAAU;AAAA;AAEZ,SAAK,UAAU,KAAK,GAAG,MAAM,KAAK;AAClC,SAAK,aAAa,IAAI,KAAK;AAAA;AAAA,EAG7B,MAAM,aAAmC;AACvC,gBAAY,KAAK;AAAA;AAAA,EAGnB,gBAAgB,QAAuB;AACrC,QACE,CAAC,OAAO,IAAI,KAAK,OAAO,sBACxB,KAAK,KAAK,MAAM,SAAO,OAAO,IAAI,IAAI,qBACtC;AACA,WAAK,OAAO,QAAQ,KAAK;AACzB,aAAO,IAAI,KAAK,OAAO;AAAA;AAAA;AAAA,EAI3B,SACE,gBACA,QACA,eACQ;AACR,UAAM,YAAY,KAAK,cAAc;AACrC,QAAI,cAAc,IAAI,KAAK,OAAO,oBAAoB;AACpD,WAAK,OAAO,QAAQ;AAAA;AAEtB,WAAO,YAAY,KAAK,OAAO;AAAA;AAAA,EAGzB,cACN,KAAe,KAAK,KAAK,IAAI,SAAO,IAAI,QAChC;AACR,WAAO,KAAK,GAAG;AAAA;AAAA;AAQZ,0BAA0B;AAAA,EAmB/B,cAAc;AAhBN,mBAAU;AAaT,qBAAY;AACZ,+BAAsB;AAG7B,gBAAW,IAAI,IAAI;AACnB;AAAA;AAAA,MAhBE,SAAS;AACX,WAAO,KAAK;AAAA;AAAA,MAGV,OAAO,UAAmB;AAC5B,QAAI,aAAa,KAAK,SAAS;AAC7B,WAAK,UAAU;AACf;AAAA;AAAA;AAAA,EAqBJ,6BAA6B;AAAA;AAAA,EAU7B,gBAAgB,QAAuB;AACrC,eAAW,OAAO,KAAK,qBAAqB;AAC1C,UAAI,gBAAgB;AAAA;AAAA;AAAA,EAKxB,qBAAoC;AAClC,WAAO,IAAI,IAAI,KAAK,UAAU,IAAI,OAAK,EAAE;AAAA;AAAA,EAGpC,SAAS;AACd,QAAI,CAAC,YAAW,IAAI,IAAI,OAAO;AAE7B;AAAA;AAGF,gBAAW,IAAI,OAAO;AACtB,eAAW,OAAO,KAAK,qBAAqB;AAC1C,iBAAW,KAAK,IAAI,cAAc;AAGhC,UAAE;AAAA;AAAA;AAGN;AAAA;AAAA;AApEG;AACW,AADX,WACW,MAAM,IAAI;AAuErB,gCAAuB,WAAW;AAAA,EAc/B,YACU,WACT,OACP;AACA;AAHgB;AACT;AAGP,SAAK,UAAU,KAAK;AAAA;AAAA,SAhBf,OAAO,WAAoB,QAAgB,UAAS,OAAO;AAChE,QAAI,YAAW,UAAS,KAAK,IAAI;AACjC,QAAI,WAAU;AACZ,gBAAS,QAAQ;AAAA,WACZ;AACL,kBAAW,IAAI,UAAS,WAAU;AAClC,gBAAS,KAAK,IAAI,WAAU;AAAA;AAE9B,WAAO;AAAA;AAAA,EAWT,gBAAgB,QAAuB;AACrC,QAAI,CAAC,OAAO,IAAI,KAAK,SAAS,oBAAoB;AAChD,WAAK,SAAS,QAAQ,KAAK;AAC3B,aAAO,IAAI,KAAK,SAAS;AAAA;AAE3B,UAAM,gBAAgB;AAAA;AAAA,EAGjB,SAAS;AACd,cAAS,KAAK,OAAO,KAAK;AAC1B,UAAM;AAAA;AAAA;AAhCH;AACmB,AADnB,SACmB,OAAO,IAAI;AAmC9B,aAAM,WAAW,SAAS;AAEjC,gCAAyC,WAAW;AAAA,EAClD,YACkB,QACT,UACP;AACA;AAHgB;AACT;AAGP,SAAK,UAAU,KAAK,OAAO,WAAW,OAAO;AAAA;AAAA,EAG/C,gBAAgB,QAAuB;AACrC,UAAM,CAAE,WAAW,GAAG,WAAW,KAAM,KAAK;AAC5C,QAAI,CAAC,OAAO,IAAI,EAAE,sBAAsB,CAAC,OAAO,IAAI,EAAE,oBAAoB;AACxE,MAAC,EAAE,GAAG,EAAE,OAAO,GAAG,EAAE,SAAU,KAAK;AACnC,aAAO,IAAI,EAAE;AACb,aAAO,IAAI,EAAE;AAAA;AAEf,UAAM,gBAAgB;AAAA;AAAA;AAInB,2BAAkB,kBAAkB;AAAA,SAGlC,OAAO,QAAgB,WAAqB,OAAO,UAAU;AAClE,QAAI,OAAM,KAAI,KAAK,IAAI;AACvB,QAAI,MAAK;AACP,WAAI,WAAW;AAAA,WACV;AACL,aAAM,IAAI,KAAI,QAAQ;AACtB,WAAI,KAAK,IAAI,QAAQ;AAAA;AAEvB,WAAO;AAAA;AAAA,EAGD,YAAY,QAAgB,UAAoB;AACtD,UAAM,QAAQ;AAAA;AAAA,EAGT,SAAS;AACd,SAAI,KAAK,OAAO,KAAK;AACrB,UAAM;AAAA;AAAA;AApBH;AACmB,AADnB,IACmB,OAAO,IAAI;AAuB9B,aAAM,MAAM,IAAI;AAEhB,8BAAqB,kBAAkB;AAAA,SAGrC,OAAO,QAAgB,WAAqB,OAAO,UAAU;AAClE,QAAI,UAAS,QAAO,KAAK,IAAI;AAC7B,QAAI,SAAQ;AACV,cAAO,WAAW;AAAA,WACb;AACL,gBAAS,IAAI,QAAO,QAAQ;AAC5B,cAAO,KAAK,IAAI,QAAQ;AAAA;AAE1B,WAAO;AAAA;AAAA,EAGD,YAAY,QAAgB,UAAoB;AACtD,UAAM,QAAQ;AAAA;AAAA,EAGT,SAAS;AACd,YAAO,KAAK,OAAO,KAAK;AACxB,UAAM;AAAA;AAAA;AApBH;AACmB,AADnB,OACmB,OAAO,IAAI;AAuB9B,aAAM,SAAS,OAAO;AAEtB,0CAAiC,WAAW;AAAA,EAiCzC,YACG,GACD,GACC,GACD,GACR;AACA;AALS;AACD;AACC;AACD;AAGR,SAAK,UAAU,KAAK,GAAG;AAAA;AAAA,SAlClB,OAAO,GAAa,GAAW,GAAa,GAAW;AAC5D,QAAI,MAAM,GAAG;AACX,YAAM,IAAI,MAAM;AAAA;AAGlB,QAAI,KAAK,oBAAmB,KAAK,IAAI,IAAI,IAAI;AAC7C,QAAI,IAAI;AACN,SAAG,IAAI;AACP,SAAG,IAAI;AACP,aAAO;AAAA;AAGT,SAAK,oBAAmB,KAAK,IAAI,IAAI,IAAI;AACzC,QAAI,IAAI;AACN,SAAG,IAAI,IAAI;AACX,SAAG,IAAI,CAAC,IAAI;AACZ,aAAO;AAAA;AAGT,SAAK,IAAI,oBAAmB,GAAG,GAAG,GAAG;AACrC,QAAI,CAAC,oBAAmB,KAAK,IAAI,IAAI;AACnC,0BAAmB,KAAK,IAAI,GAAG,IAAI;AAAA;AAErC,wBAAmB,KAAK,IAAI,GAAI,IAAI,GAAG;AACvC,WAAO;AAAA;AAAA,EAaT,6BAA6B;AAC3B,SAAK,EAAE,YAAY,KAAK,GAAG,CAAE,GAAG,KAAK,GAAG,GAAG,KAAK;AAAA;AAAA,EAG3C,SAAS;AACd,UAAM,QAAQ,oBAAmB,KAAK,IAAI,KAAK;AAC/C,QAAI,OAAO;AACT,YAAM,OAAO,KAAK;AAClB,UAAI,MAAM,SAAS,GAAG;AACpB,4BAAmB,KAAK,OAAO,KAAK;AAAA;AAAA;AAIxC,UAAM,QAAQ,oBAAmB,KAAK,IAAI,KAAK;AAC/C,QAAI,OAAO;AACT,YAAM,OAAO,KAAK;AAClB,UAAI,MAAM,SAAS,GAAG;AACpB,4BAAmB,KAAK,OAAO,KAAK;AAAA;AAAA;AAIxC,UAAM;AAAA;AAAA;AAhEH;AACmB,AADnB,mBACmB,OAAO,IAAI;AAmE9B,aAAM,qBAAqB,mBAAmB;AAE9C,aAAM,SAAS,CAAC,GAAa,MAClC,mBAAmB,GAAG,GAAG,GAAG;AAEvB,8BAAqB,WAAW;AAAA,EAc7B,YACG,QACA,OACT;AACA;AAHS;AACA;AAGT,SAAK,UAAU,KACb,OAAO,WACP,OAAO,WACP,MAAM,WACN,MAAM;AAAA;AAAA,SAnBH,OAAO,QAAgB,OAAe;AAC3C,QAAI,QAAO,KAAK,IAAI,QAAQ;AAC1B,cAAO,KAAK,IAAI,OAAQ;AAAA;AAG1B,UAAM,IAAI,IAAI,QAAO,QAAQ;AAC7B,YAAO,KAAK,IAAI,OAAO;AACvB,WAAO;AAAA;AAAA,EAgBT,6BAA6B;AAC3B,SAAK,OAAO,UAAU,YAAY,KAAK,MAAM;AAC7C,SAAK,OAAO,UAAU,YAAY,KAAK,MAAM;AAC7C,SAAK,OAAO,QAAQ,KAAK;AAAA;AAAA,EAGpB,SAAS;AACd,YAAO,KAAK,OAAO,KAAK;AACxB,UAAM;AAAA;AAAA;AAnCH;AAEmB,AAFnB,OAEmB,OAAO,IAAI;AAqC9B,aAAM,SAAS,OAAO;AAEtB,mCAA0B,WAAW;AAAA,EAoBlC,YACG,GACA,GACT;AACA;AAHS;AACA;AAIT,UAAM,KAAK,IAAI,SAAS,MAAM,GAAG;AACjC,SAAK,oBAAoB,KAAK;AAC9B,SAAK,WAAW,GAAG;AAEnB,UAAM,KAAK,IAAI,MAAM,MAAM,GAAG;AAC9B,SAAK,oBAAoB,KAAK;AAC9B,SAAK,QAAQ,GAAG;AAEhB,SAAK,UAAU,KACb,EAAE,WACF,EAAE,WACF,EAAE,WACF,EAAE,WACF,KAAK,UACL,KAAK;AAAA;AAAA,SArCF,OAAO,GAAW,GAAW;AAClC,QAAI,KAAK,aAAY,KAAK,IAAI,IAAI,IAAI;AACtC,QAAI,IAAI;AACN,aAAO;AAAA;AAGT,SAAK,IAAI,aAAY,GAAG;AACxB,QAAI,CAAC,aAAY,KAAK,IAAI,IAAI;AAC5B,mBAAY,KAAK,IAAI,GAAG,IAAI;AAAA;AAE9B,iBAAY,KAAK,IAAI,GAAI,IAAI,GAAG;AAChC,WAAO;AAAA;AAAA,EA8BF,SAAS;AACd,UAAM,QAAQ,aAAY,KAAK,IAAI,KAAK;AACxC,UAAM,OAAO,KAAK;AAClB,QAAI,MAAM,SAAS,GAAG;AACpB,mBAAY,KAAK,OAAO,KAAK;AAAA;AAE/B,UAAM;AAAA;AAAA;AAlDH;AACmB,AADnB,YACmB,OAAO,IAAI;AAqD9B,aAAM,cAAc,YAAY;AAEhC,6BAAsB,WAAW;AAAA,SAC/B,OAAO,MAAkB,IAA8B;AAC5D,WAAO,IAAI,QAAQ,MAAM;AAAA;AAAA,EAKnB,YAAY,MAAkB,IAA8B;AAClE;AACA,UAAM,KAAK,IAAI,UAAU,MAAM,MAAM;AACrC,SAAK,oBAAoB,KAAK;AAC9B,SAAK,SAAS,GAAG;AACjB,SAAK,UAAU,KAAK,GAAG,MAAM,KAAK;AAAA;AAAA;AAI/B,aAAM,UAAU,QAAQ;AAmB/B,IAAI,oBAAkD;AAEtD,8BAA8B,MAAyC;AACrE,MAAI,mBAAmB;AACrB,WAAO;AAAA;AAIT,OAAK,QAAQ;AAAA,IACX,MAAM;AAAA,IACN,WAAW;AAAA,IACX,GAAG,QAAQ;AACT,aAAO;AAAA;AAAA;AAIX,aAAW,aAAY,SAAS,KAAK;AACnC,cAAS,OAAO,CAAE,aAAa,MAAM,mBAAmB,IAAI;AAAA;AAI9D,QAAM,oBAAoB,CAAC,GAAG,WAAW,KAAK,OAC5C,gBAAc,CAAC,WAAW;AAI5B,aAAW,cAAc,mBAAmB;AAC1C,eAAW;AAAA;AAGb,sBAAoB,gBAAgB;AACpC,eAAa,YAAY;AACzB,MAAI,WAAW,GAAG,kBAAkB;AAEpC,SAAO;AAAA;AAGT,yBACE,mBACuB;AAMvB,QAAM,WAAW,IAAI;AACrB,aAAW,cAAc,mBAAmB;AAC1C,UAAM,cAAc,CAAC;AACrB,UAAM,sBAAsB,CAAC,GAAG,WAAW;AAC3C,QAAI,kBAAkB,WAAW;AACjC,eAAW,WAAW,UAAU;AAC9B,UAAI,CAAC,KAAK,QAAQ,QAAQ,iBAAiB,kBAAkB;AAC3D;AAAA;AAGF,kBAAY,KAAK,GAAG,QAAQ;AAC5B,iBAAW,OAAO,QAAQ,qBAAqB;AAC7C,YAAI,MAAM;AAAA;AAKZ,wBAAkB,IAAI,IACpB,CAAC,GAAG,iBAAiB,GAAG,QAAQ,iBAAiB,IAC/C,OAAK,EAAE;AAIX,eAAS,OAAO;AAAA;AAElB,aAAS,IAAI,CAAE,aAAa,qBAAqB;AAAA;AAEnD,SAAO,KAAK,IAAI,UAAU,CAAC,CAAE,aAAa,yBACxC,uBAAuB,aAAa;AAAA;AAIxC,gCACE,aACA,qBACkB;AAClB,QAAM,SAAS,cAAc,aAAa;AAE1C,QAAM,YAAY,IAAI;AACtB,aAAW,cAAc,aAAa;AACpC,eAAW,aAAY,WAAW,WAAW;AAC3C,UAAI,CAAC,OAAO,IAAI,UAAS,oBAAoB;AAC3C,kBAAU,IAAI,UAAS;AAAA;AAAA;AAAA;AAK7B,QAAM,yBAAyB,IAAI;AACnC,aAAW,OAAO,qBAAqB;AACrC,eAAW,aAAY,IAAI,cAAc;AACvC,UAAI,CAAC,OAAO,IAAI,UAAS,oBAAoB;AAC3C,+BAAuB,IAAI,UAAS;AAAA;AAAA;AAAA;AAK1C,QAAM,yBAAyB,IAAI;AACnC,aAAW,OAAO,qBAAqB;AACrC,eAAW,aAAY,IAAI,WAAW;AACpC,UAAI,CAAC,uBAAuB,IAAI,UAAS,oBAAoB;AAC3D;AAAA;AAGF,YAAM,IAAI,uBAAuB,IAAI,UAAS,sBAAsB;AACpE,6BAAuB,IAAI,UAAS,mBAAmB,IAAI;AAAA;AAAA;AAI/D,QAAM,gBAAgB,IAAI;AAC1B,aAAW,CAAC,WAAU,UAAU,uBAAuB,WAAW;AAChE,QAAI,UAAU,GAAG;AACf,oBAAc,IAAI,UAAS;AAAA;AAAA;AAI/B,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,WAAW,MAAM,KAAK;AAAA,IACtB;AAAA;AAAA;AAIJ,mCAAmC;AACjC,sBAAoB;AAAA;AAGf,sBAAe,MAAkB;AACtC,QAAM,WAAW,qBAAqB;AACtC,aAAW,WAAW,UAAU;AAC9B,iBAAa;AAAA;AAAA;AAIjB,sBAAsB,SAA2B;AAC/C,QAAM,CAAE,aAAa,qBAAqB,aAAc;AACxD,MAAI,CAAE,iBAAkB;AAExB,MAAI,YAAY,WAAW,GAAG;AAE5B;AAAA;AAGF,QAAM,SAAS,cAAc,aAAa;AAI1C,QAAM,qBAAqB,sBAAsB;AACjD,aAAW,MAAM,aAAa;AAC5B,QACE,cAAc,eACd,mBAAmB,IAAI,GAAG,EAAE,sBAC5B,mBAAmB,IAAI,GAAG,EAAE,oBAC5B;AACA,iBAAW,KAAK,aAAa;AAC3B,YACE,aAAa,YACZ,GAAE,SAAS,0BAA0B,GAAG,aACvC,EAAE,SAAS,0BAA0B,GAAG,SAC1C;AAEA,YAAE,QAAQ,EAAE,SAAS;AAAA;AAAA;AAAA;AAAA;AAQ7B,MAAI,YAAY;AAChB,aAAW,MAAM,aAAa;AAC5B,QACE,cAAc,eACd,GAAG,MAAM,eACT,cAAc,IAAI,GAAG,SAAS,oBAC9B;AACA,kBAAY;AACZ,aAAO,IAAI,GAAG,SAAS;AAAA;AAAA;AAG3B,MAAI,WAAW;AACb,oBAAgB,IAAI,IAClB,CAAC,GAAG,eAAe,OAAO,QAAM,CAAC,OAAO,IAAI,GAAG;AAAA;AAOnD,QAAM,SAAmB;AACzB,QAAM,SAAS,IAAI;AACnB,aAAW,aAAY,WAAW;AAChC,QACE,UAAS,uBACT,CAAC,OAAO,IAAI,cACZ,CAAC,cAAc,IAAI,YACnB;AACA,aAAO,IAAI,WAAU,OAAO;AAC5B,aAAO,KAAK,UAAS;AAAA;AAAA;AAMzB,6BAA2B,WAAqB;AAC9C,QAAI,QAAQ;AACZ,eAAW,OAAO,qBAAqB;AACrC,YAAM,SAAS,IAAI,UAAU,IAAI,eAAY;AAC3C,cAAM,CAAE,GAAG,KAAM,UAAS;AAC1B,oBAAW,UAAS;AACpB,cAAM,KAAK,OAAO,IAAI;AACtB,eAAS,SAAO,SAAY,UAAS,QAAQ,UAAU,OAAO,KAAK;AAAA;AAErE,eAAS,KAAK,IAAI,IAAI,SAAS,QAAQ,QAAQ,gBAAgB;AAAA;AAEjE,WAAO;AAAA;AAGT,MAAI,OAAO,WAAW,GAAG;AAGvB,sBAAkB;AAClB;AAAA;AAGF,MAAI;AACJ,MAAI;AACF,aAAS,SAAS,mBAAmB,QAAQ,KAAO;AAAA,WAC7C,GAAP;AACA,YAAQ,IACN,uBACA,GACA,4BACA,SACA,eACA;AAEF,QAAI,WAAW,KAAK;AACpB,UAAM;AAAA;AAIR,eAAa,gBAAgB;AAC7B,eAAa,wBAAwB,CAAC,aAA2B;AAC/D,QAAI,CAAC,UAAU;AACb,iBAAW,IAAI;AAAA;AAEjB,aAAS,IAAI,OAAO;AACpB,WAAO;AAAA;AAET,MAAI,CAAC,UAAU,OAAO,SAAS,SAAS,UAAU;AAUhD;AAAA;AAIF,QAAM,UAAU,OAAO;AACvB,aAAW,aAAY,WAAW;AAChC,QACE,UAAS,uBACT,CAAC,OAAO,IAAI,cACZ,CAAC,cAAc,IAAI,YACnB;AACA,gBAAS,QAAQ,QAAQ;AAAA;AAAA;AAAA;AAK/B,uBACE,aACA,qBACA;AACA,QAAM,SAAS,IAAI;AACnB,SAAO,MAAM;AACX,UAAM,eAAe,OAAO;AAI5B,eAAW,cAAc,aAAa;AACpC,UAAI,sBAAsB,QAAQ;AAChC,mBAAW,gBAAgB;AAAA;AAAA;AAG/B,eAAW,cAAc,aAAa;AACpC,UAAI,sBAAsB,aAAa;AACrC,mBAAW,gBAAgB;AAAA;AAAA;AAK/B,eAAW,cAAc,aAAa;AACpC,UACE,CAAE,uBAAsB,UAAU,sBAAsB,cACxD;AACA,mBAAW,gBAAgB;AAAA;AAAA;AAK/B,eAAW,OAAO,qBAAqB;AACrC,UAAI,gBAAgB;AAAA;AAGtB,QAAI,OAAO,SAAS,cAAc;AAChC;AAAA;AAAA;AAGJ,SAAO;AAAA;AAGT,+BAA+B,aAA2B;AACxD,QAAM,qBAAqB,IAAI;AAC/B,aAAW,cAAc,aAAa;AACpC,QAAI,sBAAsB,QAAQ;AAChC,yBAAmB,IAAI,WAAW,OAAO;AAAA;AAAA;AAG7C,SAAO;AAAA;",
  "names": []
}
