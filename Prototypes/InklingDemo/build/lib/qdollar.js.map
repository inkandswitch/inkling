{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/InkbaseV2/src/lib/qdollar.ts"],
  "sourcesContent": ["// @ts-nocheck\n\n/**\n * The $Q Super-Quick Recognizer (JavaScript version)\n *\n * Javascript version:\n *\n *  Nathan Magrofuoco\n *  Universite Catholique de Louvain\n *  Louvain-la-Neuve, Belgium\n *  nathan.magrofuoco@uclouvain.be\n *\n * Original $Q authors (C# version):\n *\n *  Radu-Daniel Vatavu, Ph.D.\n *  University Stefan cel Mare of Suceava\n *  Suceava 720229, Romania\n *  radu.vatavu@usm.ro\n *\n *  Lisa Anthony, Ph.D.\n *  Department of CISE\n *  University of Florida\n *  Gainesville, FL, USA 32611\n *  lanthony@cise.ufl.edu\n *\n *  Jacob O. Wobbrock, Ph.D.\n *  The Information School | DUB Group\n *  University of Washington\n *  Seattle, WA, USA 98195-2840\n *  wobbrock@uw.edu\n *\n * The academic publication for the $Q recognizer, and what should be\n * used to cite it, is:\n *\n *    Vatavu, R.-D., Anthony, L. and Wobbrock, J.O. (2018). $Q: A super-quick,\n *    articulation-invariant stroke-gesture recognizer for low-resource devices.\n *    Proceedings of the ACM Conference on Human-Computer Interaction with Mobile\n *    Devices and Services (MobileHCI '18). Barcelona, Spain (September 3-6, 2018).\n *    New York: ACM Press. Article No. 23.\n *    https://dl.acm.org/citation.cfm?id=3229434.3229465\n *\n * This software is distributed under the \"New BSD License\" agreement:\n *\n * Copyright (c) 2018-2019, Nathan Magrofuoco, Jacob O. Wobbrock, Radu-Daniel Vatavu,\n * and Lisa Anthony. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *    * Redistributions of source code must retain the above copyright\n *      notice, this list of conditions and the following disclaimer.\n *    * Redistributions in binary form must reproduce the above copyright\n *      notice, this list of conditions and the following disclaimer in the\n *      documentation and/or other materials provided with the distribution.\n *    * Neither the names of the University Stefan cel Mare of Suceava,\n *      University of Washington, nor University of Florida, nor the names of its\n *      contributors may be used to endorse or promote products derived from this\n *      software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL Radu-Daniel Vatavu OR Lisa Anthony\n * OR Jacob O. Wobbrock BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT\n * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n**/\n//\n// Point class\n//\nfunction Point(x, y, id) // constructor\n{\n\tthis.X = x;\n\tthis.Y = y;\n\tthis.ID = id;  // stroke ID to which this point belongs (1,2,3,etc.)\n\tthis.IntX = 0; // for indexing into the LUT\n\tthis.IntY = 0; // for indexing into the LUT\n}\n\nfunction PointFromStorage(x, y, id, intX, intY) // constructor\n{\n\tthis.X = x;\n\tthis.Y = y;\n\tthis.ID = id;  // stroke ID to which this point belongs (1,2,3,etc.)\n\tthis.IntX = intX; // for indexing into the LUT\n\tthis.IntY = intY; // for indexing into the LUT\n}\n//\n// PointCloud class\n//\nfunction PointCloud(name, points) // constructor\n{\n\tthis.Name = name;\n\tthis.Points = Resample(points, NumPoints);\n\tthis.Points = Scale(this.Points);\n\tthis.Points = TranslateTo(this.Points, Origin);\n\tthis.Points = MakeIntCoords(this.Points); // fills in (IntX, IntY) values\n\tthis.LUT = ComputeLUT(this.Points);\n}\n\nfunction PointCloudFromStorage(name, points){\n\tthis.Name = name\n\tthis.Points = points\n\tthis.LUT = ComputeLUT(this.Points);\n}\n//\n// Result class\n//\nfunction Result(name, score, ms) // constructor\n{\n\tthis.Name = name;\n\tthis.Score = score;\n\tthis.Time = ms;\n}\n//\n// QDollarRecognizer constants\n//\nconst NumPointClouds = 16;\nconst NumPoints = 32;\nconst Origin = new Point(0,0,0);\nconst MaxIntCoord = 1024; // (IntX, IntY) range from [0, MaxIntCoord - 1]\nconst LUTSize = 64; // default size of the lookup table is 64 x 64\nconst LUTScaleFactor = MaxIntCoord / LUTSize; // used to scale from (IntX, IntY) to LUT\n//\n// QDollarRecognizer class\n//\nfunction QDollarRecognizer() // constructor\n{\n\t//\n\t// one predefined point-cloud for each gesture\n\t//\n\tthis.PointClouds = [\n\t];\n\n\t// this.PointClouds = new Array(NumPointClouds);\n\t// this.PointClouds[0] = new PointCloud(\"T\", new Array(\n\t// \tnew Point(30,7,1),new Point(103,7,1),\n\t// \tnew Point(66,7,2),new Point(66,87,2)\n\t// ));\n\t// this.PointClouds[1] = new PointCloud(\"N\", new Array(\n\t// \tnew Point(177,92,1),new Point(177,2,1),\n\t// \tnew Point(182,1,2),new Point(246,95,2),\n\t// \tnew Point(247,87,3),new Point(247,1,3)\n\t// ));\n\t// this.PointClouds[2] = new PointCloud(\"D\", new Array(\n\t// \tnew Point(345,9,1),new Point(345,87,1),\n\t// \tnew Point(351,8,2),new Point(363,8,2),new Point(372,9,2),new Point(380,11,2),new Point(386,14,2),new Point(391,17,2),new Point(394,22,2),new Point(397,28,2),new Point(399,34,2),new Point(400,42,2),new Point(400,50,2),new Point(400,56,2),new Point(399,61,2),new Point(397,66,2),new Point(394,70,2),new Point(391,74,2),new Point(386,78,2),new Point(382,81,2),new Point(377,83,2),new Point(372,85,2),new Point(367,87,2),new Point(360,87,2),new Point(355,88,2),new Point(349,87,2)\n\t// ));\n\t// this.PointClouds[3] = new PointCloud(\"P\", new Array(\n\t// \tnew Point(507,8,1),new Point(507,87,1),\n\t// \tnew Point(513,7,2),new Point(528,7,2),new Point(537,8,2),new Point(544,10,2),new Point(550,12,2),new Point(555,15,2),new Point(558,18,2),new Point(560,22,2),new Point(561,27,2),new Point(562,33,2),new Point(561,37,2),new Point(559,42,2),new Point(556,45,2),new Point(550,48,2),new Point(544,51,2),new Point(538,53,2),new Point(532,54,2),new Point(525,55,2),new Point(519,55,2),new Point(513,55,2),new Point(510,55,2)\n\t// ));\n\t// this.PointClouds[4] = new PointCloud(\"X\", new Array(\n\t// \tnew Point(30,146,1),new Point(106,222,1),\n\t// \tnew Point(30,225,2),new Point(106,146,2)\n\t// ));\n\t// this.PointClouds[5] = new PointCloud(\"H\", new Array(\n\t// \tnew Point(188,137,1),new Point(188,225,1),\n\t// \tnew Point(188,180,2),new Point(241,180,2),\n\t// \tnew Point(241,137,3),new Point(241,225,3)\n\t// ));\n\t// this.PointClouds[6] = new PointCloud(\"I\", new Array(\n\t// \tnew Point(371,149,1),new Point(371,221,1),\n\t// \tnew Point(341,149,2),new Point(401,149,2),\n\t// \tnew Point(341,221,3),new Point(401,221,3)\n\t// ));\n\t// this.PointClouds[7] = new PointCloud(\"exclamation\", new Array(\n\t// \tnew Point(526,142,1),new Point(526,204,1),\n\t// \tnew Point(526,221,2)\n\t// ));\n\t// this.PointClouds[8] = new PointCloud(\"line\", new Array(\n\t// \tnew Point(12,347,1),new Point(119,347,1)\n\t// ));\n\t// this.PointClouds[9] = new PointCloud(\"five-point star\", new Array(\n\t// \tnew Point(177,396,1),new Point(223,299,1),new Point(262,396,1),new Point(168,332,1),new Point(278,332,1),new Point(184,397,1)\n\t// ));\n\t// this.PointClouds[10] = new PointCloud(\"null\", new Array(\n\t// \tnew Point(382,310,1),new Point(377,308,1),new Point(373,307,1),new Point(366,307,1),new Point(360,310,1),new Point(356,313,1),new Point(353,316,1),new Point(349,321,1),new Point(347,326,1),new Point(344,331,1),new Point(342,337,1),new Point(341,343,1),new Point(341,350,1),new Point(341,358,1),new Point(342,362,1),new Point(344,366,1),new Point(347,370,1),new Point(351,374,1),new Point(356,379,1),new Point(361,382,1),new Point(368,385,1),new Point(374,387,1),new Point(381,387,1),new Point(390,387,1),new Point(397,385,1),new Point(404,382,1),new Point(408,378,1),new Point(412,373,1),new Point(416,367,1),new Point(418,361,1),new Point(419,353,1),new Point(418,346,1),new Point(417,341,1),new Point(416,336,1),new Point(413,331,1),new Point(410,326,1),new Point(404,320,1),new Point(400,317,1),new Point(393,313,1),new Point(392,312,1),\n\t// \tnew Point(418,309,2),new Point(337,390,2)\n\t// ));\n\t// this.PointClouds[11] = new PointCloud(\"arrowhead\", new Array(\n\t// \tnew Point(506,349,1),new Point(574,349,1),\n\t// \tnew Point(525,306,2),new Point(584,349,2),new Point(525,388,2)\n\t// ));\n\t// this.PointClouds[12] = new PointCloud(\"pitchfork\", new Array(\n\t// \tnew Point(38,470,1),new Point(36,476,1),new Point(36,482,1),new Point(37,489,1),new Point(39,496,1),new Point(42,500,1),new Point(46,503,1),new Point(50,507,1),new Point(56,509,1),new Point(63,509,1),new Point(70,508,1),new Point(75,506,1),new Point(79,503,1),new Point(82,499,1),new Point(85,493,1),new Point(87,487,1),new Point(88,480,1),new Point(88,474,1),new Point(87,468,1),\n\t// \tnew Point(62,464,2),new Point(62,571,2)\n\t// ));\n\t// this.PointClouds[13] = new PointCloud(\"six-point star\", new Array(\n\t// \tnew Point(177,554,1),new Point(223,476,1),new Point(268,554,1),new Point(183,554,1),\n\t// \tnew Point(177,490,2),new Point(223,568,2),new Point(268,490,2),new Point(183,490,2)\n\t// ));\n\t// this.PointClouds[14] = new PointCloud(\"asterisk\", new Array(\n\t// \tnew Point(325,499,1),new Point(417,557,1),\n\t// \tnew Point(417,499,2),new Point(325,557,2),\n\t// \tnew Point(371,486,3),new Point(371,571,3)\n\t// ));\n\t// this.PointClouds[15] = new PointCloud(\"half-note\", new Array(\n\t// \tnew Point(546,465,1),new Point(546,531,1),\n\t// \tnew Point(540,530,2),new Point(536,529,2),new Point(533,528,2),new Point(529,529,2),new Point(524,530,2),new Point(520,532,2),new Point(515,535,2),new Point(511,539,2),new Point(508,545,2),new Point(506,548,2),new Point(506,554,2),new Point(509,558,2),new Point(512,561,2),new Point(517,564,2),new Point(521,564,2),new Point(527,563,2),new Point(531,560,2),new Point(535,557,2),new Point(538,553,2),new Point(542,548,2),new Point(544,544,2),new Point(546,540,2),new Point(546,536,2)\n\t// ));\n\n\n\t//\n\t// The $Q Point-Cloud Recognizer API begins here -- 3 methods: Recognize(), AddGesture(), DeleteUserGestures()\n\t//\n\n\t// Marcel added this function\n\tthis.RecognizeStrokes = function(strokes)\n\t{\n\t\tlet points = [];\n\t\tfor(const [i, stroke] of strokes.entries()) {\n\t\t\tfor(const point of stroke) {\n\t\t\t\tpoints.push(new Point(point.x, point.y, i));\n\t\t\t}\n\t\t}\n\n\t\treturn this.Recognize(points);\n\t}\n\n\t// Marcel added this function\n\tthis.RecognizeSorted = function(points) {\n\t\tvar candidate = new PointCloud(\"\", points);\n\t\tvar b = +Infinity;\n\t\tvar matches = this.PointClouds.map(pointCloud=>{\n\t\t\treturn {\n\t\t\t\tscore: CloudMatch(candidate, pointCloud, b),\n\t\t\t\tname: pointCloud.Name\n\t\t\t}\n\t\t}).sort((a, b)=>{\n\t\t\treturn a.score - b.score\n\t\t})\n\n\t\treturn matches\n\t}\n\n\tthis.Recognize = function(points)\n\t{\n\t\tvar t0 = Date.now();\n\t\tvar candidate = new PointCloud(\"\", points);\n\n\t\tvar u = -1;\n\t\tvar b = +Infinity;\n\t\tfor (var i = 0; i < this.PointClouds.length; i++) // for each point-cloud template\n\t\t{\n\t\t\tvar d = CloudMatch(candidate, this.PointClouds[i], b);\n\t\t\tif (d < b) {\n\t\t\t\tb = d; // best (least) distance\n\t\t\t\tu = i; // point-cloud index\n\t\t\t}\n\t\t}\n\t\tvar t1 = Date.now();\n\t\treturn (u == -1) ? new Result(\"No match.\", 0.0, t1-t0) : new Result(this.PointClouds[u].Name, b > 1.0 ? 1.0 / b : 1.0, t1-t0);\n\t}\n\n\t// Marcel added this function\n\tthis.AddGestureLoad = function(name, strokes)\n\t{\n\t\tlet points = [];\n\t\tfor(const [i, stroke] of strokes.entries()) {\n\t\t\tfor(const point of stroke) {\n\t\t\t\tpoints.push(new Point(point.x, point.y, i));\n\t\t\t}\n\t\t}\n\n\t\treturn this.AddGesture(name, points);\n\t}\n\n\t// Marcel added this function\n\tthis.AddGestureStrokes = function(name, strokes)\n\t{\n\t\tlet convertedPoints = [];\n\t\tfor(let i = 0; i<strokes.length; i++) {\n\t\t\tconst points = strokes[i];\n\t\t\tfor(const point of points) {\n\t\t\t\tconvertedPoints.push(new Point(point.x, point.y, i));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn this.AddGesture(name, convertedPoints);\n\t}\n\n\tthis.AddGesture = function(name, points)\n\t{\n\t\tthis.PointClouds[this.PointClouds.length] = new PointCloud(name, points);\n\t\tvar num = 0;\n\t\tfor (var i = 0; i < this.PointClouds.length; i++) {\n\t\t\tif (this.PointClouds[i].Name == name)\n\t\t\t\tnum++;\n\t\t}\n\t\treturn num;\n\t}\n\tthis.DeleteUserGestures = function()\n\t{\n\t\tthis.PointClouds.length = NumPointClouds; // clears any beyond the original set\n\t\treturn NumPointClouds;\n\t}\n}\n//\n// Private helper functions from here on down\n//\nfunction CloudMatch(candidate, template, minSoFar)\n{\n\tvar n = candidate.Points.length;\n\tvar step = Math.floor(Math.pow(n, 0.5));\n\n\tvar LB1 = ComputeLowerBound(candidate.Points, template.Points, step, template.LUT);\n\tlet LB2 = ComputeLowerBound(template.Points, candidate.Points, step, candidate.LUT);\n\n\tfor (var i = 0, j = 0; i < n; i += step, j++) {\n\t\tif (LB1[j] < minSoFar)\n\t\t\tminSoFar = Math.min(minSoFar, CloudDistance(candidate.Points, template.Points, i, minSoFar));\n\t\tif (LB2[j] < minSoFar)\n\t\t\tminSoFar = Math.min(minSoFar, CloudDistance(template.Points, candidate.Points, i, minSoFar));\n\t}\n\treturn minSoFar;\n}\nfunction CloudDistance(pts1, pts2, start, minSoFar)\n{\n\tvar n = pts1.length;\n\tvar unmatched = new Array(); // indices for pts2 that are not matched\n\tfor (var j = 0; j < n; j++)\n\t\tunmatched[j] = j;\n\tvar i = start;  // start matching with point 'start' from pts1\n\tvar weight = n; // weights decrease from n to 1\n\tvar sum = 0.0;  // sum distance between the two clouds\n\tdo\n\t{\n\t\tvar u = -1;\n\t\tvar b = +Infinity;\n\t\tfor (var j = 0; j < unmatched.length; j++)\n\t\t{\n\t\t\tvar d = SqrEuclideanDistance(pts1[i], pts2[unmatched[j]]);\n\t\t\tif (d < b) {\n\t\t\t\tb = d;\n\t\t\t\tu = j;\n\t\t\t}\n\t\t}\n\t\tunmatched.splice(u, 1); // remove item at index 'u'\n\t\tsum += weight * b;\n\t\tif (sum >= minSoFar)\n\t\t\treturn sum; // early abandoning\n\t\tweight--;\n\t\ti = (i + 1) % n;\n\t} while (i != start);\n\treturn sum;\n}\nfunction ComputeLowerBound(pts1, pts2, step, LUT)\n{\n\tvar n = pts1.length;\n\tvar LB = new Array(Math.floor(n / step) + 1);\n\tvar SAT = new Array(n);\n\tLB[0] = 0.0;\n\tfor (var i = 0; i < n; i++)\n\t{\n\t\tvar x = Math.round(pts1[i].IntX / LUTScaleFactor);\n\t\tvar y = Math.round(pts1[i].IntY / LUTScaleFactor);\n\t\tvar index = LUT[x][y];\n\t\tvar d = SqrEuclideanDistance(pts1[i], pts2[index]);\n\t\tSAT[i] = (i == 0) ? d : SAT[i - 1] + d;\n\t\tLB[0] += (n - i) * d;\n\t}\n\tfor (var i = step, j = 1; i < n; i += step, j++)\n\t\tLB[j] = LB[0] + i * SAT[n-1] - n * SAT[i-1];\n\treturn LB;\n}\nfunction Resample(points, n)\n{\n\tvar I = PathLength(points) / (n - 1); // interval length\n\tvar D = 0.0;\n\tvar newpoints = new Array(points[0]);\n\tfor (var i = 1; i < points.length; i++)\n\t{\n\t\tif (points[i].ID == points[i-1].ID)\n\t\t{\n\t\t\tvar d = EuclideanDistance(points[i-1], points[i]);\n\t\t\tif ((D + d) >= I)\n\t\t\t{\n\t\t\t\tvar qx = points[i-1].X + ((I - D) / d) * (points[i].X - points[i-1].X);\n\t\t\t\tvar qy = points[i-1].Y + ((I - D) / d) * (points[i].Y - points[i-1].Y);\n\t\t\t\tvar q = new Point(qx, qy, points[i].ID);\n\t\t\t\tnewpoints[newpoints.length] = q; // append new point 'q'\n\t\t\t\tpoints.splice(i, 0, q); // insert 'q' at position i in points s.t. 'q' will be the next i\n\t\t\t\tD = 0.0;\n\t\t\t}\n\t\t\telse D += d;\n\t\t}\n\t}\n\tif (newpoints.length == n - 1) // sometimes we fall a rounding-error short of adding the last point, so add it if so\n\t\tnewpoints[newpoints.length] = new Point(points[points.length - 1].X, points[points.length - 1].Y, points[points.length - 1].ID);\n\treturn newpoints;\n}\nfunction Scale(points)\n{\n\tvar minX = +Infinity, maxX = -Infinity, minY = +Infinity, maxY = -Infinity;\n\tfor (var i = 0; i < points.length; i++) {\n\t\tminX = Math.min(minX, points[i].X);\n\t\tminY = Math.min(minY, points[i].Y);\n\t\tmaxX = Math.max(maxX, points[i].X);\n\t\tmaxY = Math.max(maxY, points[i].Y);\n\t}\n\tvar size = Math.max(maxX - minX, maxY - minY);\n\tvar newpoints = new Array();\n\tfor (var i = 0; i < points.length; i++) {\n\t\tvar qx = (points[i].X - minX) / size;\n\t\tvar qy = (points[i].Y - minY) / size;\n\t\tnewpoints[newpoints.length] = new Point(qx, qy, points[i].ID);\n\t}\n\treturn newpoints;\n}\nfunction TranslateTo(points, pt) // translates points' centroid to pt\n{\n\tvar c = Centroid(points);\n\tvar newpoints = new Array();\n\tfor (var i = 0; i < points.length; i++) {\n\t\tvar qx = points[i].X + pt.X - c.X;\n\t\tvar qy = points[i].Y + pt.Y - c.Y;\n\t\tnewpoints[newpoints.length] = new Point(qx, qy, points[i].ID);\n\t}\n\treturn newpoints;\n}\nfunction Centroid(points)\n{\n\tvar x = 0.0, y = 0.0;\n\tfor (var i = 0; i < points.length; i++) {\n\t\tx += points[i].X;\n\t\ty += points[i].Y;\n\t}\n\tx /= points.length;\n\ty /= points.length;\n\treturn new Point(x, y, 0);\n}\nfunction PathLength(points) // length traversed by a point path\n{\n\tvar d = 0.0;\n\tfor (var i = 1; i < points.length; i++) {\n\t\tif (points[i].ID == points[i-1].ID)\n\t\t\td += EuclideanDistance(points[i-1], points[i]);\n\t}\n\treturn d;\n}\nfunction MakeIntCoords(points)\n{\n\tfor (var i = 0; i < points.length; i++) {\n\t\tpoints[i].IntX = Math.round((points[i].X + 1.0) / 2.0 * (MaxIntCoord - 1));\n\t\tpoints[i].IntY = Math.round((points[i].Y + 1.0) / 2.0 * (MaxIntCoord - 1));\n\t}\n\treturn points;\n}\nfunction ComputeLUT(points)\n{\n\tvar LUT = new Array();\n\tfor (var i = 0; i < LUTSize; i++)\n\t\tLUT[i] = new Array();\n\n\tfor (var x = 0; x < LUTSize; x++)\n\t{\n\t\tfor (var y = 0; y < LUTSize; y++)\n\t\t{\n\t\t\tvar u = -1;\n\t\t\tvar b = +Infinity;\n\t\t\tfor (var i = 0; i < points.length; i++)\n\t\t\t{\n\t\t\t\tvar row = Math.round(points[i].IntX / LUTScaleFactor);\n\t\t\t\tvar col = Math.round(points[i].IntY / LUTScaleFactor);\n\t\t\t\tvar d = ((row - x) * (row - x)) + ((col - y) * (col - y));\n\t\t\t\tif (d < b) {\n\t\t\t\t\tb = d;\n\t\t\t\t\tu = i;\n\t\t\t\t}\n\t\t\t}\n      \t\tLUT[x][y] = u;\n    \t}\n\t}\n  \treturn LUT;\n}\nfunction SqrEuclideanDistance(pt1, pt2)\n{\n\tvar dx = pt2.X - pt1.X;\n\tvar dy = pt2.Y - pt1.Y;\n\treturn (dx * dx + dy * dy);\n}\nfunction EuclideanDistance(pt1, pt2)\n{\n\tvar s = SqrEuclideanDistance(pt1, pt2);\n\treturn Math.sqrt(s);\n}\n\nexport default QDollarRecognizer"],
  "mappings": "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",
  "names": []
}
