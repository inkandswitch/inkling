{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/InkbaseV2/src/lib/spreadsheet.ts"],
  "sourcesContent": ["import * as ohm from 'ohm-js';\n\nconst spreadsheetGrammar = ohm.grammar(String.raw`\n\nSpreadsheet {\n  Properties\n    = Property*\n\n  Property\n    = name Edges Formula\n\n  Edges\n    = edges Edge*  -- edges\n    |              -- none\n\n  Edge\n    = dir Value\n\n  Formula\n    = Exp\n\n  Exp\n    = IfExp\n\n  IfExp\n    = if EqExp then EqExp else IfExp  -- if\n    | EqExp\n\n  EqExp\n    = RelExp \"=\" RelExp  -- eq\n    | RelExp\n\n  RelExp\n    = AddExp (\"<=\" | \"<\" | \">=\" | \">\") AddExp  -- rel\n    | AddExp\n\n  AddExp\n    = AddExp (\"+\" | \"-\") MulExp  -- add\n    | MulExp\n\n  MulExp\n    = MulExp (\"*\" | \"/\" | \"%\") PropExp  -- mul\n    | PropExp\n\n  PropExp\n    = dir+ name  -- prop\n    | UnExp\n\n  UnExp\n    = \"-\" CallExp  -- neg\n    | CallExp\n\n  CallExp\n    = name \"(\" ListOf<Exp, \",\"> \")\"  -- call\n    | PriExp\n\n  PriExp\n    = \"(\" Exp \")\"  -- paren\n    | Value\n\n  Value\n    = number\n    | string\n\n  // lexical rules\n\n  dir  (a direction)\n    = \"\u2190\"  -- left\n    | \"\u2192\"  -- right\n    | \"\u2191\"  -- up\n    | \"\u2193\"  -- down\n    | \"\u2022\"  -- here\n\n  number  (a number literal)\n    = digit* \".\" digit+  -- fract\n    | digit+             -- whole\n\n  string  (a string literal)\n    = \"\\\"\" (~\"\\\"\" ~\"\\n\" any)* \"\\\"\"\n\n  name  (a name)\n    = ~keyword letter alnum*\n\n  edges = \"edges\" ~alnum\n  if = \"if\" ~alnum\n  then = \"then\" ~alnum\n  else = \"else\" ~alnum\n  keyword = edges | if | then | else\n\n}\n\n`);\n\nconst NOT_AVAILABLE = 'n/a';\n\ntype Value = number | string;\n\ninterface Property {\n  name: string;\n  formula(cell: Cell): Value;\n  edgeValues?: Record<string, Value>;\n}\n\nclass Cell {\n  readonly neighbors = new Map<string, Cell>();\n  readonly propertyValues = new Map<string, Value>();\n\n  constructor(\n    readonly spreadsheet: Spreadsheet,\n    value?: Value\n  ) {\n    if (value !== undefined) {\n      this.set('value', value);\n    }\n  }\n\n  connect(name: string, that: Cell): this {\n    this.neighbors.set(name, that);\n    return this;\n  }\n\n  set(propertyName: string, value: Value): this {\n    this.propertyValues.set(propertyName, value);\n    return this;\n  }\n\n  get(path: string[], propertyName: string): Value {\n    let cell: Cell | undefined = this;\n    for (const name of path) {\n      cell = cell.neighbors.get(name);\n      if (!cell) {\n        return this.spreadsheet.getEdgeValue(name, propertyName);\n      }\n    }\n    const value = cell.propertyValues.get(propertyName);\n    if (value !== undefined) {\n      return value;\n    } else {\n      throw NOT_AVAILABLE;\n    }\n  }\n\n  compute(property: Property) {\n    if (this.propertyValues.has(property.name)) {\n      // already computed it!\n      return false;\n    }\n\n    try {\n      this.propertyValues.set(property.name, property.formula(this));\n      return true;\n    } catch (e) {\n      if (e !== NOT_AVAILABLE) {\n        throw e;\n      } else {\n        return false;\n      }\n    }\n  }\n\n  toJSON(): Record<string, Value> {\n    const obj = {} as Record<string, Value>;\n    for (const [name, value] of this.propertyValues.entries()) {\n      obj[name] = value;\n    }\n    return obj;\n  }\n}\n\nclass Spreadsheet {\n  static semantics = spreadsheetGrammar\n    .createSemantics()\n    .addOperation('parse', {\n      Properties(ps) {\n        const properties = {} as Record<string, Property>;\n        for (const p of ps.children) {\n          const property = p.parse();\n          properties[property.name] = property;\n        }\n        return properties;\n      },\n      Property(name, edges, formula) {\n        return {\n          name: name.parse(),\n          edgeValues: edges.parse(),\n          formula: formula.parse(),\n        };\n      },\n      Edges_edges(_edges, edges) {\n        const edgeValues = {} as Record<string, Value>;\n        for (const edgeNode of edges.children) {\n          const edge = edgeNode.parse();\n          edgeValues[edge.name] = edge.value;\n        }\n        return edgeValues;\n      },\n      Edges_none() {\n        return {};\n      },\n      Edge(name, value) {\n        return {\n          name: name.parse(),\n          value: value.parse(),\n        };\n      },\n      Formula(exp) {\n        const fnSource = `cell => ${exp.parse()}`;\n        // console.log(fnSource);\n        return eval(fnSource);\n      },\n      IfExp_if(_if, cond, _then, trueBranch, _else, falseBranch) {\n        return `(${cond.parse()} ? ${trueBranch.parse()} : ${falseBranch.parse()})`;\n      },\n      EqExp_eq(a, _eq, b) {\n        return `(${a.parse()} === ${b.parse()})`;\n      },\n      RelExp_rel(a, op, b) {\n        return `(${a.parse()} ${op.sourceString} ${b.parse()})`;\n      },\n      AddExp_add(a, op, b) {\n        return `(${a.parse()} ${op.sourceString} ${b.parse()})`;\n      },\n      MulExp_mul(a, op, b) {\n        return `(${a.parse()} ${op.sourceString} ${b.parse()})`;\n      },\n      PropExp_prop(names, propertyName) {\n        return `cell.get([${names\n          .parse()\n          .map((name: string) => JSON.stringify(name))\n          .join(', ')}], ${JSON.stringify(propertyName.parse())})`;\n      },\n      UnExp_neg(_minusSign, exp) {\n        return `(-${exp.parse()})`;\n      },\n      CallExp_call(funcName, _openParen, args, _closeParen) {\n        return `cell.spreadsheet.callBuiltinFn(${JSON.stringify(\n          funcName.parse()\n        )}, ${args.children.map(arg => arg.parse()).join(', ')})`;\n      },\n      PriExp_paren(_openParen, exp, _closeParen) {\n        return `(${exp.parse()})`;\n      },\n      name(_firstLetter, _rest) {\n        return this.sourceString;\n      },\n      dir(_name) {\n        return this.sourceString;\n      },\n      number(_) {\n        return parseFloat(this.sourceString);\n      },\n      string(_openQuote, _meat, _closeQuote) {\n        return this.sourceString;\n      },\n\n      EmptyListOf() {\n        return [];\n      },\n      NonemptyListOf(x, _commas, xs) {\n        return [x.parse(), ...xs.parse()];\n      },\n      _iter(...children) {\n        return children.map(child => child.parse());\n      },\n      _terminal() {\n        return this.sourceString;\n      },\n    });\n\n  static parse(properties: string): Record<string, Property> {\n    const m = spreadsheetGrammar.match(properties);\n    if (m.failed()) {\n      console.log(m.message);\n      throw new Error(\n        'failed to parse spreadsheet formulas -- see console for details'\n      );\n    }\n    return Spreadsheet.semantics(m).parse();\n  }\n\n  readonly properties: Record<string, Property>;\n  readonly rows: Cell[][];\n\n  constructor(cellValues: (Value | undefined)[][], properties: string) {\n    this.properties = Spreadsheet.parse(properties);\n    console.log(properties);\n    // console.log(this.properties);\n\n    this.rows = cellValues.map(row => row.map(value => new Cell(this, value)));\n    for (let row = 0; row < this.rows.length; row++) {\n      for (let col = 0; col < this.rows[row].length; col++) {\n        const here = this.getCell(row, col)!;\n        const up = this.getCell(row - 1, col);\n        const down = this.getCell(row + 1, col);\n        const left = this.getCell(row, col - 1);\n        const right = this.getCell(row, col + 1);\n        here.connect('\u2022', here);\n        if (up) {\n          here.connect('\u2191', up);\n        }\n        if (down) {\n          here.connect('\u2193', down);\n        }\n        if (left) {\n          here.connect('\u2190', left);\n        }\n        if (right) {\n          here.connect('\u2192', right);\n        }\n      }\n    }\n  }\n\n  private getCell(rowIdx: number, colIdx: number) {\n    if (rowIdx < 0 || rowIdx >= this.rows.length) {\n      return null;\n    }\n    const row = this.rows[rowIdx];\n    if (colIdx < 0 || colIdx >= row.length) {\n      return null;\n    }\n    return row[colIdx];\n  }\n\n  compute(options?: Partial<{ maxIterations: number; showResult: boolean }>) {\n    const { maxIterations = 1_000, showResult = true } = options ?? {};\n    let n = 0;\n    while (n++ < maxIterations) {\n      let didSomething = false;\n      for (const row of this.rows) {\n        for (const cell of row) {\n          for (const property of Object.values(this.properties)) {\n            didSomething = cell.compute(property) || didSomething;\n          }\n        }\n      }\n      if (!didSomething) {\n        break;\n      }\n    }\n    if (showResult) {\n      console.log(this.getCellValues());\n    }\n    console.log('done in', n, 'iterations');\n  }\n\n  getEdgeValue(name: string, propertyName: string): Value {\n    const property = this.properties[propertyName];\n    if (\n      !property ||\n      !property.edgeValues ||\n      property.edgeValues[name] === undefined\n    ) {\n      throw NOT_AVAILABLE;\n    }\n    return property.edgeValues[name];\n  }\n\n  callBuiltinFn(name: string, ...args: Value[]) {\n    switch (name) {\n      case 'min':\n        return Math.min(...(args as number[]));\n      case 'max':\n        return Math.max(...(args as number[]));\n      default:\n        throw new Error('unsupported function: ' + name);\n    }\n  }\n\n  getCellValues(): Record<string, Value>[][] {\n    return this.rows.map(row => row.map(cell => cell.toJSON()));\n  }\n}\n\nconsole.log('--- squares ---');\nconst squares = new Spreadsheet(\n  [\n    [1, undefined],\n    [2, undefined],\n    [3, undefined],\n    [4, undefined],\n    [5, undefined],\n  ],\n  String.raw`\n    value\n      \u2190value * \u2190value\n  `\n);\nsquares.compute();\n\nconsole.log('--- habit tracker ---');\nconst habitTracker = new Spreadsheet(\n  [['x', 'x', '', 'x', 'x', 'x']],\n  String.raw`\n    n\n      edges\n        \u2190 0\n        \u2192 0\n      if \u2022value = \"x\"\n      then \u2190n + 1\n      else 0\n\n    subscript\n      if \u2022n > \u2192n\n      then \"\" + \u2022n\n      else \"\"\n  `\n);\nhabitTracker.compute();\n\nconsole.log('--- wave ---');\nconst wave = new Spreadsheet(\n  [\n    [1, 2, 3, 4], //\n    [5, 6, 7, 8], //\n    [9, 10, 11, 12], //\n    [13, 14, 15, 16], //\n  ],\n  String.raw`\n    acc\n      edges\n        \u2191 0\n        \u2190 0\n      \u2022value + \u2191acc + \u2190acc\n\n    subscript\n      \u2022acc\n  `\n);\nwave.compute();\n"],
  "mappings": "AAAA;AAEA,MAAM,qBAAqB,IAAI,QAAQ,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2F9C,MAAM,gBAAgB;AAUtB,WAAW;AAAA,EAIT,YACW,aACT,OACA;AAFS;AAJF,qBAAY,IAAI;AAChB,0BAAiB,IAAI;AAM5B,QAAI,UAAU,QAAW;AACvB,WAAK,IAAI,SAAS;AAAA;AAAA;AAAA,EAItB,QAAQ,MAAc,MAAkB;AACtC,SAAK,UAAU,IAAI,MAAM;AACzB,WAAO;AAAA;AAAA,EAGT,IAAI,cAAsB,OAAoB;AAC5C,SAAK,eAAe,IAAI,cAAc;AACtC,WAAO;AAAA;AAAA,EAGT,IAAI,MAAgB,cAA6B;AAC/C,QAAI,OAAyB;AAC7B,eAAW,QAAQ,MAAM;AACvB,aAAO,KAAK,UAAU,IAAI;AAC1B,UAAI,CAAC,MAAM;AACT,eAAO,KAAK,YAAY,aAAa,MAAM;AAAA;AAAA;AAG/C,UAAM,QAAQ,KAAK,eAAe,IAAI;AACtC,QAAI,UAAU,QAAW;AACvB,aAAO;AAAA,WACF;AACL,YAAM;AAAA;AAAA;AAAA,EAIV,QAAQ,UAAoB;AAC1B,QAAI,KAAK,eAAe,IAAI,SAAS,OAAO;AAE1C,aAAO;AAAA;AAGT,QAAI;AACF,WAAK,eAAe,IAAI,SAAS,MAAM,SAAS,QAAQ;AACxD,aAAO;AAAA,aACA,GAAP;AACA,UAAI,MAAM,eAAe;AACvB,cAAM;AAAA,aACD;AACL,eAAO;AAAA;AAAA;AAAA;AAAA,EAKb,SAAgC;AAC9B,UAAM,MAAM;AACZ,eAAW,CAAC,MAAM,UAAU,KAAK,eAAe,WAAW;AACzD,UAAI,QAAQ;AAAA;AAEd,WAAO;AAAA;AAAA;AAIX,2BAAkB;AAAA,SAoGT,MAAM,YAA8C;AACzD,UAAM,IAAI,mBAAmB,MAAM;AACnC,QAAI,EAAE,UAAU;AACd,cAAQ,IAAI,EAAE;AACd,YAAM,IAAI,MACR;AAAA;AAGJ,WAAO,aAAY,UAAU,GAAG;AAAA;AAAA,EAMlC,YAAY,YAAqC,YAAoB;AACnE,SAAK,aAAa,aAAY,MAAM;AACpC,YAAQ,IAAI;AAGZ,SAAK,OAAO,WAAW,IAAI,SAAO,IAAI,IAAI,WAAS,IAAI,KAAK,MAAM;AAClE,aAAS,MAAM,GAAG,MAAM,KAAK,KAAK,QAAQ,OAAO;AAC/C,eAAS,MAAM,GAAG,MAAM,KAAK,KAAK,KAAK,QAAQ,OAAO;AACpD,cAAM,OAAO,KAAK,QAAQ,KAAK;AAC/B,cAAM,KAAK,KAAK,QAAQ,MAAM,GAAG;AACjC,cAAM,OAAO,KAAK,QAAQ,MAAM,GAAG;AACnC,cAAM,OAAO,KAAK,QAAQ,KAAK,MAAM;AACrC,cAAM,QAAQ,KAAK,QAAQ,KAAK,MAAM;AACtC,aAAK,QAAQ,UAAK;AAClB,YAAI,IAAI;AACN,eAAK,QAAQ,UAAK;AAAA;AAEpB,YAAI,MAAM;AACR,eAAK,QAAQ,UAAK;AAAA;AAEpB,YAAI,MAAM;AACR,eAAK,QAAQ,UAAK;AAAA;AAEpB,YAAI,OAAO;AACT,eAAK,QAAQ,UAAK;AAAA;AAAA;AAAA;AAAA;AAAA,EAMlB,QAAQ,QAAgB,QAAgB;AAC9C,QAAI,SAAS,KAAK,UAAU,KAAK,KAAK,QAAQ;AAC5C,aAAO;AAAA;AAET,UAAM,MAAM,KAAK,KAAK;AACtB,QAAI,SAAS,KAAK,UAAU,IAAI,QAAQ;AACtC,aAAO;AAAA;AAET,WAAO,IAAI;AAAA;AAAA,EAGb,QAAQ,SAAmE;AACzE,UAAM,CAAE,gBAAgB,KAAO,aAAa,QAAS,WAAW;AAChE,QAAI,IAAI;AACR,WAAO,MAAM,eAAe;AAC1B,UAAI,eAAe;AACnB,iBAAW,OAAO,KAAK,MAAM;AAC3B,mBAAW,QAAQ,KAAK;AACtB,qBAAW,YAAY,OAAO,OAAO,KAAK,aAAa;AACrD,2BAAe,KAAK,QAAQ,aAAa;AAAA;AAAA;AAAA;AAI/C,UAAI,CAAC,cAAc;AACjB;AAAA;AAAA;AAGJ,QAAI,YAAY;AACd,cAAQ,IAAI,KAAK;AAAA;AAEnB,YAAQ,IAAI,WAAW,GAAG;AAAA;AAAA,EAG5B,aAAa,MAAc,cAA6B;AACtD,UAAM,WAAW,KAAK,WAAW;AACjC,QACE,CAAC,YACD,CAAC,SAAS,cACV,SAAS,WAAW,UAAU,QAC9B;AACA,YAAM;AAAA;AAER,WAAO,SAAS,WAAW;AAAA;AAAA,EAG7B,cAAc,SAAiB,MAAe;AAC5C,YAAQ;AAAA,WACD;AACH,eAAO,KAAK,IAAI,GAAI;AAAA,WACjB;AACH,eAAO,KAAK,IAAI,GAAI;AAAA;AAEpB,cAAM,IAAI,MAAM,2BAA2B;AAAA;AAAA;AAAA,EAIjD,gBAA2C;AACzC,WAAO,KAAK,KAAK,IAAI,SAAO,IAAI,IAAI,UAAQ,KAAK;AAAA;AAAA;AAzMrD;AACS,AADT,YACS,YAAY,mBAChB,kBACA,aAAa,SAAS;AAAA,EACrB,WAAW,IAAI;AACb,UAAM,aAAa;AACnB,eAAW,KAAK,GAAG,UAAU;AAC3B,YAAM,WAAW,EAAE;AACnB,iBAAW,SAAS,QAAQ;AAAA;AAE9B,WAAO;AAAA;AAAA,EAET,SAAS,MAAM,OAAO,SAAS;AAC7B,WAAO;AAAA,MACL,MAAM,KAAK;AAAA,MACX,YAAY,MAAM;AAAA,MAClB,SAAS,QAAQ;AAAA;AAAA;AAAA,EAGrB,YAAY,QAAQ,OAAO;AACzB,UAAM,aAAa;AACnB,eAAW,YAAY,MAAM,UAAU;AACrC,YAAM,OAAO,SAAS;AACtB,iBAAW,KAAK,QAAQ,KAAK;AAAA;AAE/B,WAAO;AAAA;AAAA,EAET,aAAa;AACX,WAAO;AAAA;AAAA,EAET,KAAK,MAAM,OAAO;AAChB,WAAO;AAAA,MACL,MAAM,KAAK;AAAA,MACX,OAAO,MAAM;AAAA;AAAA;AAAA,EAGjB,QAAQ,KAAK;AACX,UAAM,WAAW,WAAW,IAAI;AAEhC,WAAO,KAAK;AAAA;AAAA,EAEd,SAAS,KAAK,MAAM,OAAO,YAAY,OAAO,aAAa;AACzD,WAAO,IAAI,KAAK,aAAa,WAAW,aAAa,YAAY;AAAA;AAAA,EAEnE,SAAS,GAAG,KAAK,GAAG;AAClB,WAAO,IAAI,EAAE,eAAe,EAAE;AAAA;AAAA,EAEhC,WAAW,GAAG,IAAI,GAAG;AACnB,WAAO,IAAI,EAAE,WAAW,GAAG,gBAAgB,EAAE;AAAA;AAAA,EAE/C,WAAW,GAAG,IAAI,GAAG;AACnB,WAAO,IAAI,EAAE,WAAW,GAAG,gBAAgB,EAAE;AAAA;AAAA,EAE/C,WAAW,GAAG,IAAI,GAAG;AACnB,WAAO,IAAI,EAAE,WAAW,GAAG,gBAAgB,EAAE;AAAA;AAAA,EAE/C,aAAa,OAAO,cAAc;AAChC,WAAO,aAAa,MACjB,QACA,IAAI,CAAC,SAAiB,KAAK,UAAU,OACrC,KAAK,WAAW,KAAK,UAAU,aAAa;AAAA;AAAA,EAEjD,UAAU,YAAY,KAAK;AACzB,WAAO,KAAK,IAAI;AAAA;AAAA,EAElB,aAAa,UAAU,YAAY,MAAM,aAAa;AACpD,WAAO,kCAAkC,KAAK,UAC5C,SAAS,aACL,KAAK,SAAS,IAAI,SAAO,IAAI,SAAS,KAAK;AAAA;AAAA,EAEnD,aAAa,YAAY,KAAK,aAAa;AACzC,WAAO,IAAI,IAAI;AAAA;AAAA,EAEjB,KAAK,cAAc,OAAO;AACxB,WAAO,KAAK;AAAA;AAAA,EAEd,IAAI,OAAO;AACT,WAAO,KAAK;AAAA;AAAA,EAEd,OAAO,GAAG;AACR,WAAO,WAAW,KAAK;AAAA;AAAA,EAEzB,OAAO,YAAY,OAAO,aAAa;AACrC,WAAO,KAAK;AAAA;AAAA,EAGd,cAAc;AACZ,WAAO;AAAA;AAAA,EAET,eAAe,GAAG,SAAS,IAAI;AAC7B,WAAO,CAAC,EAAE,SAAS,GAAG,GAAG;AAAA;AAAA,EAE3B,SAAS,UAAU;AACjB,WAAO,SAAS,IAAI,WAAS,MAAM;AAAA;AAAA,EAErC,YAAY;AACV,WAAO,KAAK;AAAA;AAAA;AA6GpB,QAAQ,IAAI;AACZ,MAAM,UAAU,IAAI,YAClB;AAAA,EACE,CAAC,GAAG;AAAA,EACJ,CAAC,GAAG;AAAA,EACJ,CAAC,GAAG;AAAA,EACJ,CAAC,GAAG;AAAA,EACJ,CAAC,GAAG;AAAA,GAEN,OAAO;AAAA;AAAA;AAAA;AAKT,QAAQ;AAER,QAAQ,IAAI;AACZ,MAAM,eAAe,IAAI,YACvB,CAAC,CAAC,KAAK,KAAK,IAAI,KAAK,KAAK,OAC1B,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeT,aAAa;AAEb,QAAQ,IAAI;AACZ,MAAM,OAAO,IAAI,YACf;AAAA,EACE,CAAC,GAAG,GAAG,GAAG;AAAA,EACV,CAAC,GAAG,GAAG,GAAG;AAAA,EACV,CAAC,GAAG,IAAI,IAAI;AAAA,EACZ,CAAC,IAAI,IAAI,IAAI;AAAA,GAEf,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWT,KAAK;",
  "names": []
}
