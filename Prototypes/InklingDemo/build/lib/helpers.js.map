{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/InkbaseV2/src/lib/helpers.ts"],
  "sourcesContent": ["import Line from './line';\nimport { Position } from './types';\nimport Vec from './vec';\n\n/**\n * Assigns a value to one of the properties on `window` to make it available\n * for debugging via the console. If `valueOrValueFn` is a function, it calls\n * that function w/ the old value for the property and stores the result.\n * Otherwise it stores the value.\n */\nexport function forDebugging<T>(\n  property: string,\n  valueOrValueFn: T | ((oldValue?: T) => T)\n) {\n  let value: T;\n  if (typeof valueOrValueFn === 'function') {\n    const valueFn = valueOrValueFn as (oldValue?: T) => T;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const oldValue = (window as any)[property] as T | undefined;\n    value = valueFn(oldValue);\n  } else {\n    value = valueOrValueFn;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (window as any)[property] = value;\n}\n\nlet nextId = 0;\nexport function generateId() {\n  return nextId++;\n}\n\nexport function onEveryFrame(update: (dt: number, time: number) => void) {\n  // Set this to the number of updates you'd like to run per second.\n  // Should be at least as high as the device frame rate to ensure smooth motion.\n  // Must not be modified at runtime, because it's used to calculate elapsed time.\n  const updatesPerSecond = 60;\n\n  // You CAN change this at runtime for slow-mo / speed-up effects, eg for debugging.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (window as any).timeScale ||= 1;\n\n  // Internal state\n  let lastRafTime: number;\n  let accumulatedTime = 0; // Time is added to this by RAF, and consumed by running updates\n  let elapsedUpdates = 0; // How many updates have we run \u2014 used to measure elapsed time\n  const secondsPerUpdate = 1 / updatesPerSecond;\n\n  function frame(ms: number) {\n    const currentRafTime = ms / 1000;\n    const deltaRafTime = currentRafTime - lastRafTime;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    accumulatedTime += deltaRafTime * (window as any).timeScale;\n\n    while (accumulatedTime > secondsPerUpdate) {\n      accumulatedTime -= secondsPerUpdate;\n      elapsedUpdates++;\n      update(secondsPerUpdate, elapsedUpdates * secondsPerUpdate);\n    }\n\n    lastRafTime = currentRafTime;\n\n    requestAnimationFrame(frame);\n  }\n\n  requestAnimationFrame(ms => {\n    lastRafTime = ms / 1000;\n    requestAnimationFrame(frame);\n  });\n}\n\n// A debug view of an object's properties. Clearing is useful when debugging a single object at 60hz.\nexport function debugTable(obj: {}, clear = true) {\n  if (clear) {\n    // eslint-disable-next-line node/no-unsupported-features/node-builtins\n    console.clear();\n  }\n  // eslint-disable-next-line node/no-unsupported-features/node-builtins\n  console.table(objectWithSortedKeys(obj));\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Obj = Record<string, any>;\n\n// My kingdom for a standard library that includes a key-sorted Map.\nexport function objectWithSortedKeys(obj: Obj) {\n  const newObj: Obj = {};\n  for (const k of Object.keys(obj).sort()) {\n    newObj[k] = obj[k];\n  }\n  return newObj;\n}\n\nexport const notNull = <T>(x: T | null): x is T => !!x;\nexport const notUndefined = <T>(x: T | undefined): x is T => !!x;\n\nexport function toDegrees(radians: number) {\n  return (radians * 180) / Math.PI;\n}\n\n// this is O(n^2), but there is a O(n * log(n)) solution\n// that we can use if this ever becomes a bottleneck\n// https://www.baeldung.com/cs/most-distant-pair-of-points\nexport function farthestPair<P extends Position>(points: P[]): [P, P] {\n  let maxDist = -Infinity;\n  let mdp1: P | null = null;\n  let mdp2: P | null = null;\n  for (const p1 of points) {\n    for (const p2 of points) {\n      const d = Vec.dist(p1, p2);\n      if (d > maxDist) {\n        mdp1 = p1;\n        mdp2 = p2;\n        maxDist = d;\n      }\n    }\n  }\n  return [mdp1!, mdp2!];\n}\n\nexport function forEach<T extends WeakKey>(\n  xs: WeakRef<T>[],\n  fn: (x: T, idx: number, xs: WeakRef<T>[]) => void\n) {\n  xs.forEach((wr, idx) => {\n    const x = wr.deref();\n    if (x !== undefined) {\n      fn(x, idx, xs);\n    }\n  });\n}\n\nexport function makeIterableIterator<T, S extends T>(\n  iterables: Iterable<T>[],\n  pred: (t: T) => t is S\n): IterableIterator<S>;\nexport function makeIterableIterator<T>(\n  iterables: Iterable<T>[],\n  pred?: (t: T) => boolean\n): IterableIterator<T>;\nexport function makeIterableIterator<T>(\n  iterables: Iterable<T>[],\n  pred: (t: T) => boolean = _t => true\n) {\n  function* generator() {\n    for (const ts of iterables) {\n      for (const t of ts) {\n        if (!pred || pred(t)) {\n          yield t;\n        }\n      }\n    }\n  }\n  return generator();\n}\n\nexport function removeOne<T>(set: Set<T>): T | undefined {\n  for (const element of set) {\n    set.delete(element);\n    return element;\n  }\n  return undefined;\n}\n\n// Sorted Set\n// Guarantees unique items, and allows resorting of items when iterating\nexport class SortedSet<T> {\n  constructor(private readonly items: T[] = []) {}\n\n  static fromSet<T>(set: Set<T>) {\n    return new SortedSet(Array.from(set));\n  }\n\n  add(item: T) {\n    for (const o of this.items) {\n      if (o === item) {\n        return;\n      }\n    }\n\n    this.items.push(item);\n  }\n\n  moveItemToFront(item: T) {\n    // find old position\n    const oldIndex = this.items.indexOf(item);\n    if (oldIndex === -1) {\n      return;\n    }\n\n    // Remove item from old position\n    const oldItem = this.items.splice(oldIndex, 1)[0];\n\n    // Add it back to front\n    this.items.unshift(oldItem);\n  }\n\n  get(index: number) {\n    return this.items[index];\n  }\n\n  size() {\n    return this.items.length;\n  }\n\n  [Symbol.iterator]() {\n    let index = -1;\n    const data = this.items;\n\n    return {\n      next: () => ({ value: data[++index], done: !(index in data) }),\n    };\n  }\n}\n\n/** Helper functions for dealing with `Set`s. */\nexport const sets = {\n  overlap<T>(s1: Set<T>, s2: Set<T>) {\n    for (const x of s1) {\n      if (s2.has(x)) {\n        return true;\n      }\n    }\n    return false;\n  },\n  union<T>(s1: Set<T>, s2: Set<T>) {\n    return new Set<T>([...s1, ...s2]);\n  },\n  map<S, T>(s: Set<S>, fn: (x: S) => T) {\n    return new Set([...s].map(fn));\n  },\n};\n\nexport function distanceToPath(pos: Position, points: Position[]) {\n  switch (points.length) {\n    case 0:\n      return null;\n    case 1:\n      return Vec.dist(pos, points[0]);\n    default: {\n      // This is probably *very* slow\n      let minDist = Infinity;\n      for (let idx = 0; idx < points.length - 1; idx++) {\n        const p1 = points[idx];\n        const p2 = points[idx + 1];\n        minDist = Math.min(minDist, Line.distToPoint(Line(p1, p2), pos));\n      }\n      return minDist;\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
