{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/InkbaseV2/src/lib/line.ts"],
  "sourcesContent": ["// Line\n// This is a collection of functions related to line segments written by Marcel with help of ChatGPT\n\nimport { isZero } from './math';\nimport { Position } from './types';\nimport Vec from './vec';\n\ninterface Line {\n  a: Position;\n  b: Position;\n}\n\nfunction Line(a: Position, b: Position): Line {\n  return { a, b };\n}\n\nexport default Line;\n\nLine.len = (l: Line) => Vec.dist(l.a, l.b);\n\nLine.directionVec = (l: Line) => Vec.normalize(Vec.sub(l.b, l.a));\n\n// Returns intersection if the line segments overlap, or null if they don't\nLine.intersect = (l1: Line, l2: Line): Position | null => {\n  const { a: p1, b: p2 } = l1;\n  const { a: q1, b: q2 } = l2;\n\n  const dx1 = p2.x - p1.x;\n  const dy1 = p2.y - p1.y;\n  const dx2 = q2.x - q1.x;\n  const dy2 = q2.y - q1.y;\n\n  const determinant = dx1 * dy2 - dy1 * dx2;\n  if (determinant === 0) {\n    // The lines are parallel or coincident\n    return null;\n  }\n\n  const dx3 = p1.x - q1.x;\n  const dy3 = p1.y - q1.y;\n\n  const t = (dx3 * dy2 - dy3 * dx2) / determinant;\n  const u = (dx1 * dy3 - dy1 * dx3) / determinant;\n\n  if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n    // The segments intersect at a point\n    const intersectionX = p1.x + t * dx1;\n    const intersectionY = p1.y + t * dy1;\n    return { x: intersectionX, y: intersectionY };\n  }\n\n  // The segments do not intersect\n  return null;\n};\n\n// Always returns intersection point even if the line segments don't overlap\nLine.intersectAnywhere = (l1: Line, l2: Line): Position | null => {\n  const { a: p1, b: p2 } = l1;\n  const { a: q1, b: q2 } = l2;\n\n  const dx1 = p2.x - p1.x;\n  const dy1 = p2.y - p1.y;\n  const dx2 = q2.x - q1.x;\n  const dy2 = q2.y - q1.y;\n\n  const determinant = dx1 * dy2 - dy1 * dx2;\n\n  if (determinant === 0) {\n    // The lines are parallel or coincident\n    return null;\n  }\n\n  const dx3 = p1.x - q1.x;\n  const dy3 = p1.y - q1.y;\n\n  const t = (dx3 * dy2 - dy3 * dx2) / determinant;\n  // Alex commented out this line b/c that variable was never used. Bug?\n  // const u = (dx1 * dy3 - dy1 * dx3) / determinant;\n\n  const intersectionX = p1.x + t * dx1;\n  const intersectionY = p1.y + t * dy1; // should u be used here instead of t?\n\n  return { x: intersectionX, y: intersectionY };\n};\n\n// Get point along slope\n// TODO: make this work for vertical lines, too\nLine.getYforX = (line: Line, x: number): number => {\n  // Extract the coordinates of points a and b\n  const { a, b } = line;\n  const { x: x1, y: y1 } = a;\n  const { x: x2, y: y2 } = b;\n\n  // Calculate the slope of the line\n  const slope = (y2 - y1) / (x2 - x1);\n\n  // Calculate the y-coordinate for the given x-coordinate\n  const y = slope * (x - x1) + y1;\n\n  return y;\n};\n\n// Get point along slope\n// TODO: make this work for vertical lines, too\nLine.getXforY = (line: Line, y: number) => {\n  // Extract the coordinates of points a and b\n  const { a, b } = line;\n  const { x: x1, y: y1 } = a;\n  const { x: x2, y: y2 } = b;\n\n  // Calculate the slope of the line\n  const slope = (y2 - y1) / (x2 - x1);\n\n  // Calculate the x-coordinate for the given y-coordinate\n  const x = (y - y1) / slope + x1;\n\n  return x;\n};\n\nLine.distToPoint = (line: Line, point: Position) =>\n  Vec.dist(point, Line.closestPoint(line, point));\n\nLine.closestPoint = (line: Line, point: Position, strict = true) => {\n  const { a, b } = line;\n\n  // Calculate vector AB and AP\n  const AB = Vec.sub(b, a);\n  const AP = Vec.sub(point, a);\n\n  // Special case for when a === b, w/o which we get NaNs.\n  if (isZero(AB.x) && isZero(AB.y)) {\n    return a;\n  }\n\n  // Calculate the projection of AP onto AB\n  const projection = Vec.dot(AP, AB) / Vec.dot(AB, AB);\n\n  // Check if the projection is outside the line segment\n  if (strict && projection <= 0) {\n    return a;\n  } else if (strict && projection >= 1) {\n    return b;\n  } else {\n    return Vec.add(a, Vec.mulS(AB, projection));\n  }\n};\n\nLine.spreadPointsAlong = (line: Line, n: number) => {\n  const segLength = Line.len(line) / n;\n  const offsetSeg = Vec.mulS(Line.directionVec(line), segLength);\n  const points: Position[] = [];\n  for (let i = 0; i < n; i++) {\n    points.push(Vec.add(line.a, Vec.mulS(offsetSeg, i)));\n  }\n  return points;\n};\n"],
  "mappings": "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",
  "names": []
}
