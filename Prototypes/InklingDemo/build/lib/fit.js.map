{
  "version": 3,
  "sources": ["/Users/admin/Work/Inkling/InkbaseV2/src/lib/fit.ts"],
  "sourcesContent": ["import Arc from './arc';\nimport Line from './line';\nimport { Position } from './types';\nimport Vec from './vec';\n\n// tslint:disable:variable-name\n\nexport interface LineFit {\n  type: 'line';\n  line: Line;\n  fitness: number;\n  length: number;\n}\n\nfunction line(stroke: Position[]): LineFit | null {\n  if (stroke.length === 0) {\n    return null;\n  }\n\n  const line = Line(Vec.clone(stroke[0]), Vec.clone(stroke[stroke.length - 1]));\n\n  let totalDist = 0;\n  for (let i = 1; i < stroke.length - 1; i++) {\n    totalDist += Line.distToPoint(line, stroke[i]);\n  }\n\n  const length = Line.len(line);\n\n  return {\n    type: 'line',\n    line,\n    length,\n    fitness: length === 0 ? 1 : totalDist / length,\n  };\n}\n\nexport interface ArcFit {\n  type: 'arc';\n  arc: Arc;\n  fitness: number;\n  length: number;\n}\n\nfunction arc(points: Position[]): ArcFit | null {\n  if (points.length < 3) {\n    return null;\n  }\n\n  const simplified = innerTriangle(points);\n  const [a, b, c] = simplified;\n\n  if (!b) {\n    return null;\n  }\n\n  const { x: x1, y: y1 } = a;\n  const { x: x2, y: y2 } = b;\n  const { x: x3, y: y3 } = c;\n\n  const D = 2 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));\n  const centerX =\n    ((x1 * x1 + y1 * y1) * (y2 - y3) +\n      (x2 * x2 + y2 * y2) * (y3 - y1) +\n      (x3 * x3 + y3 * y3) * (y1 - y2)) /\n    D;\n  const centerY =\n    ((x1 * x1 + y1 * y1) * (x3 - x2) +\n      (x2 * x2 + y2 * y2) * (x1 - x3) +\n      (x3 * x3 + y3 * y3) * (x2 - x1)) /\n    D;\n  const radius = Math.sqrt(\n    (x1 - centerX) * (x1 - centerX) + (y1 - centerY) * (y1 - centerY)\n  );\n\n  const startAngle = Math.atan2(y1 - centerY, x1 - centerX);\n  const endAngle = Math.atan2(y3 - centerY, x3 - centerX);\n\n  // Compute winding order\n  const ab = Vec.sub(a, b);\n  const bc = Vec.sub(b, c);\n  const clockwise = Vec.cross(ab, bc) > 0;\n\n  const arc = Arc(\n    Vec(centerX, centerY),\n    radius,\n    startAngle,\n    endAngle,\n    clockwise\n  );\n\n  // Compute fitness\n  const arcDist = Arc.len(arc);\n\n  let totalDist = 0;\n  for (const p of points) {\n    totalDist += Arc.distToPointCircle(arc, p);\n  }\n\n  return {\n    type: 'arc',\n    arc,\n    fitness: totalDist / arcDist,\n    length: arcDist,\n  };\n}\n\nfunction innerTriangle(points: Position[]): [Position, Position, Position] {\n  const start = points[0];\n  const end = points[points.length - 1];\n\n  let largestDistance = -1;\n  let farthestIndex = -1;\n\n  for (let i = 0; i < points.length; i++) {\n    const point = points[i];\n    const dist = Line.distToPoint(Line(start, end), point);\n    if (dist > largestDistance) {\n      largestDistance = dist;\n      farthestIndex = i;\n    }\n  }\n\n  return [start, points[farthestIndex], end];\n}\n\ninterface Circle {\n  center: Position;\n  radius: number;\n  startAngle: number;\n  endAngle: number;\n  clockwise: boolean;\n}\n\nexport interface CircleFit {\n  type: 'circle';\n  circle: Circle;\n  fitness: number;\n}\n\nfunction circle(points: Position[]): CircleFit | null {\n  if (points.length < 3) {\n    return null;\n  }\n\n  // Do a basic circular regression\n  const n = points.length;\n  let sumX = 0;\n  let sumY = 0;\n  let sumX2 = 0;\n  let sumY2 = 0;\n  let sumXY = 0;\n  let sumX3 = 0;\n  let sumY3 = 0;\n  let sumXY2 = 0;\n  let sumX2Y = 0;\n\n  for (const point of points) {\n    const { x, y } = point;\n    sumX += x;\n    sumY += y;\n    sumX2 += x * x;\n    sumY2 += y * y;\n    sumXY += x * y;\n    sumX3 += x * x * x;\n    sumY3 += y * y * y;\n    sumXY2 += x * y * y;\n    sumX2Y += x * x * y;\n  }\n\n  const C = n * sumX2 - sumX * sumX;\n  const D = n * sumXY - sumX * sumY;\n  const E = n * sumX3 + n * sumXY2 - (sumX2 + sumY2) * sumX;\n  const G = n * sumY2 - sumY * sumY;\n  const H = n * sumX2Y + n * sumY3 - (sumX2 + sumY2) * sumY;\n\n  const a = (H * D - E * G) / (C * G - D * D);\n  const b = (H * C - E * D) / (D * D - G * C);\n  const c = -(a * sumX + b * sumY + sumX2 + sumY2) / n;\n\n  // Construct circle\n  const center = Vec(-a / 2, -b / 2);\n  const radius = Math.sqrt(center.x * center.x + center.y * center.y - c);\n\n  // Compute angles\n  const startAngle = Math.atan2(points[0].y - center.y, points[0].x - center.x);\n  const endAngle = Math.atan2(\n    points[points.length - 1].y - center.y,\n    points[points.length - 1].x - center.x\n  );\n\n  // Determine winding order\n  // Compute winding order\n  const ab = Vec.sub(points[0], points[1]);\n  const bc = Vec.sub(points[1], points[2]);\n  const clockwise = Vec.cross(ab, bc) > 0;\n\n  const circle = { center, radius, startAngle, endAngle, clockwise };\n\n  // check fitness\n  let totalDist = 0;\n  for (const p of points) {\n    totalDist += Arc.distToPointCircle(circle, p);\n  }\n  const circumference = 2 * Math.PI * radius;\n  const fitness = totalDist / circumference;\n\n  return { type: 'circle', circle, fitness };\n}\n\nexport default {\n  line,\n  arc,\n  circle,\n};\n"],
  "mappings": "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",
  "names": []
}
