{
  "version": 3,
  "sources": ["../build/engine.js", "../build/canvas.js", "../build/lib/relax-pk.js", "../build/lib/math.js", "../build/lib/vec.js", "../build/lib/line.js", "../build/_snowpack/pkg/ohm-js.js", "../build/parser.js", "../build/draw_snap.js", "../build/main.js"],
  "sourcesContent": ["let eventQueue = {\n    pencil: [], // only one pencil - so a list of events\n    touches: {}, // map by touch id to a list of events\n};\n\nwindow.nativeEvent = (eventState, touches) => {\n    Object.entries(touches).forEach(([touchId, points]) => {\n        points.forEach((point) => {\n            if (point.type === \"pencil\") {\n                eventQueue.pencil.push({\n                    // there's more data in `point` that we're ignoring here\n                    type: eventState,\n                    x: point.x,\n                    y: point.y,\n                });\n            } else {\n                if (!eventQueue.touches[touchId]) {\n                    eventQueue.touches[touchId] = [];\n                }\n\n                eventQueue.touches[touchId].push({\n                    type: eventState,\n                    x: point.x,\n                    y: point.y,\n                    timestamp: point.timestamp\n                });\n            }\n        });\n    });\n};\n\n\nlet callback = null\nfunction frame(){\n    callback(eventQueue)\n\n    eventQueue.pencil = []\n    eventQueue.touches = {}\n\n    window.requestAnimationFrame(frame);\n}\n\nexport default (cb) => {\n    callback = cb\n    window.requestAnimationFrame(frame);\n}", "class Canvas {\n    constructor(dom, cb){\n        // SETUP CANVAS\n        this.canvas = document.createElement(\"canvas\")\n        dom.appendChild(this.canvas)\n        const dpr = window.devicePixelRatio\n        let bounds = dom.getBoundingClientRect()\n        this.canvas.width = bounds.width * dpr\n        this.canvas.height = bounds.height * dpr\n        this.ctx = this.canvas.getContext(\"2d\")\n        this.ctx.scale(dpr, dpr)\n\n        // this.canvas.addEventListener(\"touchstart\", e=>e.preventDefault(), false)\n\n        this.callback = cb\n        cb(this.ctx)\n    }\n\n    render(){\n        this.callback(this.ctx)\n    }\n\n}\n\nexport default Canvas", "/**\n * Optimizations that I haven't implemented yet:\n * - equality constraints should be special,\n *   maybe we can keep track of the equivalence between the points,\n *   and keep a map from point -> delta\n *   and every time a delta is applied, we can apply it to all of them (or something)\n * - keep track of \"dirty\" dependencies, that way we don't have to do any work\n *   in calculateDeltas() if nothing has changed.\n *   (similar to Fisher's Continuously Evaluating Expression)\n * - fixed point and var constraints can get baked into knowns set?\n *   (would need to recompute it when a constraint changes, which could be messy)\n */\n\nconst PROPAGATE_KNOWNS = true;\n\n// -------\n\n// inteface Delta {\n//   curb(knowns: { xs, ys, vs }): void;\n//   isSignificant(epsilon: number): boolean;\n//   apply(rho: number): void;\n// }\n\n// -------\n\nexport class Var {\n  constructor(value) {\n    this.value = value;\n  }\n\n  toString() {\n    return `var(${this.value})`;\n  }\n}\n\nclass VarDelta {\n  constructor(v, amount, constraint) {\n    this.v = v;\n    this.amount = amount;\n    this.constraint = constraint;\n  }\n\n  toString() {\n    return `${this.v} += ${this.amount} from ${this.constraint}`;\n  }\n\n  curb(knowns) {\n    if (knowns.vars.has(this.v)) {\n      this.amount = 0;\n    }\n  }\n\n  isSignificant(epsilon) {\n    return Math.abs(this.amount) > epsilon;\n  }\n\n  apply(rho) {\n    this.v.value += this.amount * rho;\n  }\n\n  draw(_rc) {\n    // TODO\n  }\n}\n\n// -------\n\nexport class Point {\n  constructor(x, y, optColor) {\n    this.x = x;\n    this.y = y;\n    if (optColor != null) {\n      this.color = optColor;\n    }\n  }\n\n  toString() {\n    return `(${this.x.toFixed(1)}, ${this.y.toFixed(1)})`;\n  }\n\n  contains(p, rc) {\n    const distSquared =\n      Math.pow(p.x - this.x, 2) + Math.pow(p.y - this.y, 2);\n    return Math.pow(rc.pointRadius, 2) >= distSquared;\n  }\n\n  onClick(rc) {\n    console.log('' + this);\n    for (const t of relax.things) {\n      if (t.involves != null && t.involves(this)) {\n        console.log('* ' + t);\n      }\n    }\n  }\n\n  plus(that) {\n    return new Point(\n      this.x + that.x,\n      this.y + that.y\n    );\n  }\n\n  minus(that) {\n    return new Point(\n      this.x - that.x,\n      this.y - that.y\n    );\n  }\n\n  magnitude() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  distanceTo(that) {\n    return this.minus(that).magnitude();\n  }\n\n  scaledBy(m) {\n    return new Point(\n      this.x * m,\n      this.y * m\n    );\n  }\n\n  rotatedBy(theta) {\n    const t = theta * Math.PI / 180;\n    const c = Math.cos(t);\n    const s = Math.sin(t);\n    return new Point(\n      this.x * c - this.y * s,\n      this.x * s + this.y * c\n    );\n  }\n\n  rotatedAroundBy(axis, theta) {\n    return axis.plus(this.minus(axis).rotatedBy(theta));\n  }\n\n  angleWithXAxis() {\n    return Math.atan2(this.y, this.x) * 180 / Math.PI;\n  }\n\n  angleWithYAxis() {\n    return this.angleWithXAxis() - 90;\n  }\n\n  normalized() {\n    return this.scaledBy(1 / this.magnitude());\n  }\n\n  dot(that) {\n    return this.x * that.x + this.y * that.y;\n  }\n\n  clone() {\n    return new Point(this.x, this.y);\n  }\n\n  draw(rc) {\n    const oldFillStyle = rc.ctxt.fillStyle;\n    rc.ctxt.fillStyle = this.isSelected ? 'yellow' : this.color ?? 'cornflowerblue';\n    rc.ctxt.beginPath();\n    rc.ctxt.arc(rc.toScreenX(this.x), rc.toScreenY(this.y), rc.pointRadius, 0, 2 * Math.PI);\n    rc.ctxt.closePath();\n    rc.ctxt.fill();\n    if (this.selectionIndices && this.selectionIndices.length > 0) {\n      rc.drawSelectionIndices(this);\n    }\n    rc.ctxt.fillStyle = oldFillStyle;\n  }\n}\n\nclass PointDelta {\n  constructor(p, amount, constraint) {\n    this.p = p;\n    this.amount = amount;\n    this.constraint = constraint;\n  }\n\n  toString() {\n    return `${this.p} += ${this.amount} from ${this.constraint}`;\n  }\n\n  curb(knowns) {\n    if (knowns.xs.has(this.p)) {\n      this.amount.x = 0;\n    }\n    if (knowns.ys.has(this.p)) {\n      this.amount.y = 0;\n    }\n  }\n\n  isSignificant(epsilon) {\n    return this.amount.magnitude() > epsilon;\n  }\n\n  apply(rho) {\n    const d = this.amount.scaledBy(rho);\n    this.p.x += d.x;\n    this.p.y += d.y;\n  }\n\n  draw(rc) {\n    const p1 = this.p;\n    const p2 = p1.plus(this.amount);\n\n    const x1 = rc.toScreenX(p1.x);\n    const y1 = rc.toScreenY(p1.y);\n    const x2 = rc.toScreenX(p2.x);\n    const y2 = rc.toScreenY(p2.y);\n    if (Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)) < 0.5) {\n      return;\n    }\n\n    const ctxt = rc.ctxt;\n    const origStrokeStyle = ctxt.strokeStyle;\n    ctxt.strokeStyle = 'rgba(255,0,0,0.5)'\n    ctxt.beginPath();\n\n    ctxt.moveTo(x1, y1);\n    ctxt.lineTo(x2, y2);\n\n    const headSize = rc.pointRadius * 0.8;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const angle = Math.atan2(dy, dx);\n    ctxt.lineTo(x2 - headSize * Math.cos(angle - Math.PI / 6), y2 - headSize * Math.sin(angle - Math.PI / 6));\n    ctxt.moveTo(x2, y2);\n    ctxt.lineTo(x2 - headSize * Math.cos(angle + Math.PI / 6), y2 - headSize * Math.sin(angle + Math.PI / 6));\n\n    ctxt.closePath();\n    ctxt.stroke();\n    ctxt.strokeStyle = origStrokeStyle;\n  }\n}\n\n// -------\n\nclass Line {\n  constructor(p1, p2, optColor) {\n    this.p1 = p1;\n    this.p2 = p2;\n    if (optColor != null) {\n      this.color = optColor;\n    }\n  }\n\n  toString() {\n    return `Line(${this.p1}, ${this.p2})`;\n  }\n\n  involves(thing) {\n    return thing === this.p1 || thing === this.p2;\n  }\n\n  draw(rc) {\n    const oldLineWidth = rc.ctxt.lineWidth;\n    const oldStrokeStyle = rc.ctxt.strokeStyle;\n    rc.ctxt.beginPath();\n    rc.ctxt.moveTo(rc.toScreenX(this.p1.x), rc.toScreenY(this.p1.y));\n    rc.ctxt.lineWidth = 3;\n    rc.ctxt.strokeStyle = this.color ?? 'rgba(0,0,0,0.15)';\n    rc.ctxt.lineTo(rc.toScreenX(this.p2.x), rc.toScreenY(this.p2.y));\n    rc.ctxt.closePath();\n    rc.ctxt.stroke();\n    rc.ctxt.lineWidth = oldLineWidth;\n    rc.ctxt.strokeStyle = oldStrokeStyle;\n  }\n}\n\n// -------\n\n// interface Thing {\n//   involves(Thing): boolean; // optional\n//   contains(Point, Canvas): boolean; // optional\n//   beforeTick(Relax); // optional\n//   propagateKnowns(knowns: { xs, ys, vars }): boolean; // optional\n//   calculateDeltas(knowns: { xs, ys, vars }): Delta[]; // optional\n//   afterTick(Relax); // optional\n//   drawUnder(Canvas); // optional\n//   drawOver(Canvas); // optional\n// }\n\n// -------\n\nexport default class Relax {\n  rho = 0.25;\n  epsilon = 0.001;\n  things = new Set();\n  points = new Set();\n  lines = new Set();\n\n  add(thing) {\n    this.things.add(thing);\n    if (thing instanceof Point) {\n      this.points.add(thing);\n    } else if (thing instanceof Line) {\n      this.lines.add(thing);\n    }\n    return this;\n  }\n\n  find(thingPred) {\n    for (const t of this.things) {\n      if (thingPred(t)) {\n        return t;\n      }\n    }\n    return null;\n  }\n\n  findAll(thingPred) {\n    const ans = [];\n    for (const t of this.things) {\n      if (thingPred(t)) {\n        ans.push(t);\n      }\n    }\n    return ans;\n  }\n\n  remove(unwantedThing) {\n    this.things.delete(unwantedThing);\n    if (unwantedThing instanceof Point) {\n      this.points.delete(unwantedThing);\n    } else if (unwantedThing instanceof Line) {\n      this.lines.delete(unwantedThing);\n    }\n    // TODO: also remove things involving unwantedThing?\n    return this;\n  }\n\n  clear() {\n    this.things.clear();\n    this.points.clear();\n    this.lines.clear();\n    return this;\n  }\n\n  // Every time a thing actually does something, we break out of the loop and start over.\n  // This ensures that the non-finger constraints get their say first.\n  // (Which avoids weirdness \"in the middle\".)\n  propagateKnowns(knowns) {\n    while (true) {\n      let didSomething = false;\n      for (const t of this.things) {\n        if (t.propagateKnowns != null && t.propagateKnowns(knowns)) {\n          didSomething = true;\n          break;\n        }\n      }\n      if (!didSomething) {\n        break;\n      }\n    }\n  }\n\n  runOneIteration() {\n    for (const t of this.things) {\n      if (t.beforeTick != null) {\n        t.beforeTick(this);\n      }\n    }\n\n    const knowns = { xs: new Set(), ys: new Set(), vars: new Set() };\n    if (PROPAGATE_KNOWNS) {\n      this.propagateKnowns(knowns);\n    }\n\n    const allDeltas = [];\n    for (const t of this.things) {\n      if (t.calculateDeltas == null) {\n        continue;\n      }\n      const deltas = t.calculateDeltas(knowns);\n      for (const d of deltas) {\n        d.curb(knowns);\n      }\n      if (deltas.some(d => d.isSignificant(this.epsilon))) {\n        allDeltas.push(...deltas);\n      }\n    }\n\n    let ans;\n    if (allDeltas.length > 0) {\n      for (const d of allDeltas) {\n        d.apply(this.rho);\n      }\n      ans = true;\n    } else {\n      ans = false;\n    }\n\n    for (const t of this.things) {\n      if (t.afterTick != null) {\n        ans = t.afterTick(this) || ans;\n      }\n    }\n\n    return ans;\n  }\n\n  iterateForUpToMillis(\n    milliseconds,\n    beforeEachIterationFn,\n    afterEachIterationFn\n  ) {\n    let count = 0;\n    const t0 = Date.now();\n    Time.nowSeconds = t0 / 1_000;\n    while (Date.now() - t0  < milliseconds) {\n      if (beforeEachIterationFn) {\n        beforeEachIterationFn(count + 1);\n      }\n      const changedSomething = this.runOneIteration(t0);\n      if (afterEachIterationFn) {\n        afterEachIterationFn(count + 1);\n      }\n      if (changedSomething) {\n        count++;\n      } else {\n        break;\n      }\n    }\n    return count;\n  }\n}\n\n// -------\n\nexport class FixedVar {\n  constructor(v, wanted) {\n    this.v = v;\n    this.wanted = wanted;\n  }\n\n  involves(_thing) {\n    return false;\n  }\n\n  propagateKnowns(knowns) {\n    if (!knowns.vars.has(this.v)) {\n      this.v.value = this.wanted;\n      knowns.vars.add(this.v);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  calculateDeltas(_knowns) {\n    return [new VarDelta(this.v, this.wanted - this.v.value, this)];\n  }\n\n\n  toString() {\n    return `FixedVar(${this.v}, ${this.wanted})`;\n  }\n}\n\nexport class VarEquals {\n  constructor(...vs) {\n    this.vs = vs;\n  }\n\n  involves(thing) {\n    return this.vs.includes(thing);\n  }\n\n  propagateKnowns(knowns) {\n    const kv = this.vs.find(v => knowns.vars.has(v));\n    if (kv == null) {\n      return false;\n    }\n\n    let ans = false;\n    for (const v of this.vs) {\n      if (!knowns.vars.has(v)) {\n        v.value = kv.value;\n        knowns.vars.add(v);\n        ans = true;\n      }\n    }\n    return ans;\n  }\n\n  calculateDeltas(_knowns) {\n    const m = avg(...this.vs.map(v => v.value));\n    return this.vs.map(v => new VarDelta(v, m - v.value, this));\n  }\n\n\n  toString() {\n    return `VarEquals(${this.vs})`;\n  }\n}\n\nexport class FixedPoint {\n  constructor(p, wanted) {\n    this.p = p;\n    this.wanted = wanted;\n  }\n\n  involves(thing) {\n    return thing === this.p;\n  }\n\n  propagateKnowns(knowns) {\n    let ans = false;\n    if (!knowns.xs.has(this.p)) {\n      this.p.x = this.wanted.x;\n      knowns.xs.add(this.p);\n      ans = true;\n    }\n    if (!knowns.ys.has(this.p)) {\n      this.p.y = this.wanted.y;\n      knowns.ys.add(this.p);\n      ans = true;\n    }\n    return ans;\n  }\n\n  calculateDeltas(_knowns) {\n    return [new PointDelta(this.p, this.wanted.minus(this.p), this)];\n  }\n\n  toString() {\n    return `FixedPoint(${this.p}, ${this.wanted})`;\n  }\n\n  drawOver(rc) {\n    const ctxt = rc.ctxt;\n    const origFillStyle = ctxt.fillStyle;\n    ctxt.fillStyle = 'black';\n    ctxt.beginPath();\n    ctxt.arc(\n      rc.toScreenX(this.wanted.x),\n      rc.toScreenY(this.wanted.y),\n      rc.pointRadius * 0.4,\n      0,\n      2 * Math.PI\n    );\n    ctxt.closePath();\n    ctxt.fill();\n    ctxt.fillStyle = origFillStyle;\n  }\n}\n\nclass ManyPointConstraint {\n  constructor(ps) {\n    this.ps = ps;\n  }\n\n  involves(thing) {\n    return this.ps.includes(thing);\n  }\n\n  propagateKnowns(_knowns) {\n    throw new Error('subclass responsibility');\n  }\n\n  calculateDeltas(_knowns) {\n    throw new Error('subclass responsibility');\n  }\n\n  toString() {\n    return `${this.constructor.name}(${this.ps.join(', ')})`;\n  }\n}\n\nexport class Horizontal extends ManyPointConstraint {\n  constructor(...ps) {\n    super(ps);\n  }\n\n  propagateKnowns(knowns) {\n    const knownY = this.ps.find(p => knowns.ys.has(p))?.y;\n    if (knownY == null) {\n      return false;\n    }\n    let ans = false;\n    for (const p of this.ps) {\n      if (!knowns.ys.has(p)) {\n        p.y = knownY;\n        knowns.ys.add(p);\n        ans = true;\n      }\n    }\n    return ans;\n  }\n\n  calculateDeltas(_knowns) {\n    const avgY = this.ps.map(p => p.y).reduce((a, b) => a + b) / this.ps.length;\n    return this.ps.map(p => new PointDelta(p, new Point(0, avgY - p.y), this));\n  }\n\n  drawUnder(rc) {\n    if (!rc.showConstraints) {\n      return;\n    }\n\n    const ctxt = rc.ctxt;\n    const avgY = this.ps.map(p => p.y).reduce((a, b) => a + b) / this.ps.length;\n\n    const origGlobalAlpha = ctxt.globalAlpha;\n    ctxt.globalAlpha = 0.125;\n    const arr = [5, 10];\n    ctxt.setLineDash(arr);\n    ctxt.beginPath();\n    ctxt.moveTo(0, rc.toScreenY(avgY));\n    ctxt.lineTo(rc.canvas.width, rc.toScreenY(avgY));\n    ctxt.closePath();\n    ctxt.stroke();\n    ctxt.globalAlpha = origGlobalAlpha;\n    ctxt.setLineDash([]);\n  }\n}\n\nexport class Vertical extends ManyPointConstraint {\n  constructor(...ps) {\n    super(ps);\n  }\n\n  propagateKnowns(knowns) {\n    const knownX = this.ps.find(p => knowns.xs.has(p))?.x;\n    if (knownX == null) {\n      return false;\n    }\n    let ans = false;\n    for (const p of this.ps) {\n      if (!knowns.xs.has(p)) {\n        p.x = knownX;\n        knowns.xs.add(p);\n        ans = true;\n      }\n    }\n    return ans;\n  }\n\n  calculateDeltas(_knowns) {\n    const avgX = this.ps.map(p => p.x).reduce((a, b) => a + b) / this.ps.length;\n    return this.ps.map(p => new PointDelta(p, new Point(avgX - p.x, 0), this));\n  }\n\n  drawUnder(rc) {\n    if (!rc.showConstraints) {\n      return;\n    }\n\n    const ctxt = rc.ctxt;\n    const avgX = this.ps.map(p => p.x).reduce((a, b) => a + b) / this.ps.length;\n\n    const origGlobalAlpha = ctxt.globalAlpha;\n    ctxt.globalAlpha = 0.125;\n    ctxt.setLineDash([5, 10]);\n    ctxt.beginPath();\n    ctxt.moveTo(rc.toScreenX(avgX), 0);\n    ctxt.lineTo(rc.toScreenX(avgX), rc.canvas.height);\n    ctxt.closePath();\n    ctxt.stroke();\n    ctxt.globalAlpha = origGlobalAlpha;\n    ctxt.setLineDash([]);\n  }\n}\n\nclass TwoPointConstraint {\n  constructor(p1, p2) {\n    this.p1 = p1;\n    this.p2 = p2;\n  }\n\n  involves(thing) {\n    return thing === this.p1 || thing === this.p2;\n  }\n\n  propagateKnowns(_knowns) {\n    throw new Error('subclass responsibility');\n  }\n\n  calculateDeltas(_knowns) {\n    throw new Error('subclass responsibility');\n  }\n\n  toString() {\n    return `${this.constructor.name}(${this.p1}, ${this.p2})`;\n  }\n}\n\n// TODO: make optMinAmount into a variable\nclass Above extends TwoPointConstraint {\n  constructor(p1, p2, optMinAmount) {\n    super(p1, p2);\n    this.minAmount = optMinAmount == null ? 0 : optMinAmount;\n  }\n\n  propagateKnowns(_knowns) {\n    // this is an inequality, so we can't determine p2 from p1 and vice-versa\n    return false;\n  }\n\n  calculateDeltas(_knowns) {\n    const dy = this.p1.y - this.minAmount - this.p2.y;\n    return dy > 0\n      ? []\n      : [\n        new PointDelta(this.p1, new Point(0, -dy / 2), this),\n        new PointDelta(this.p2, new Point(0, dy / 2), this)\n      ];\n  }\n\n  toString() {\n    return `Above(${this.p1}, ${this.p2}, ${this.minAmount})`;\n  }\n}\n\nexport class Length extends TwoPointConstraint {\n  constructor(p1, p2, length) {\n    super(p1, p2);\n    this.length = length;\n  }\n\n  beforeTick(relax) {\n    delete this.fixedLengthConstraint;\n    for (const t of relax.things) {\n      if (t instanceof FixedVar && t.v === this.length) {\n        this.fixedLengthConstraint = t;\n      }\n    }\n  }\n\n  propagateKnowns(knowns) {\n    if (\n      !knowns.vars.has(this.length) &&\n      knowns.xs.has(this.p1) && knowns.ys.has(this.p1) &&\n      knowns.xs.has(this.p2) && knowns.ys.has(this.p2)\n    ) {\n      this.length.value = this.p1.distanceTo(this.p2);\n      knowns.vars.add(this.length);\n      return true;\n    } else {\n      // if we know p1 and length, p2 could be anywhere along a circle\n      // same for p2 and length.\n      return false;\n    }\n    // TODO: If we know length, p1.x, p1.y, and p2.x we still can't\n    // tell what p2.y should be (b/c there are two possible values).\n    // Should think about coming up with a *directional* `Length`\n    // constraint that doesn't have this problem.\n  }\n\n  calculateDeltas(_knowns) {\n    // TODO: if this.length is known, don't generate a delta for it\n    // TODO: if this.length and one of the points is known, only generate delta for other point\n    // etc.\n    const v12 = this.p2.minus(this.p1);\n    const actualLength = v12.magnitude();\n    const diff = (actualLength - this.length.value) / 3;\n    const e12 = v12.normalized();\n    return [\n      new VarDelta(this.length, diff, this),\n      new PointDelta(this.p1, e12.scaledBy(diff), this),\n      new PointDelta(this.p2, e12.scaledBy(-diff), this)\n    ];\n  }\n\n  toString() {\n    return `Length(${this.p1}, ${this.p2}, ${this.length})`;\n  }\n\n  contains(p, rc) {\n    if (!rc.showConstraints) {\n      return false;\n    }\n\n    const xIsIn =\n      this.p1.x - 10 < p.x && p.x < this.p2.x + 10 ||\n      this.p2.x - 10 < p.x && p.x < this.p1.x + 10;\n\n    const yIsIn =\n      this.p1.y - 10 < p.y && p.y < this.p2.y + 10 ||\n      this.p2.y - 10 < p.y && p.y < this.p1.y + 10;\n\n    return xIsIn && yIsIn;\n  }\n\n  onClick(rc) {\n    if (this.fixedLengthConstraint != null) {\n      rc.remove(this.fixedLengthConstraint);\n    } else {\n      rc.addThing(new FixedVar(this.length, this.length.value));\n    }\n  }\n\n  drawOver(rc) {\n    if (!rc.showConstraints) {\n      return;\n    }\n\n    const ctxt = rc.ctxt;\n    const origLineWidth = ctxt.lineWidth;\n    const origStrokeStyle = ctxt.strokeStyle;\n    const origFillStyle = ctxt.fillStyle;\n    const origFont = ctxt.font;\n    const origTextAlign = ctxt.textAlign;\n    const origTextBaseline = ctxt.textBaseline;\n\n    ctxt.lineWidth = 1;\n    ctxt.strokeStyle = ctxt.fillStyle = 'rgba(0,0,255,0.2)';\n    ctxt.beginPath();\n\n    const angle = Math.atan2(this.p2.y - this.p1.y, this.p2.x - this.p1.x);\n    const dist = 20;\n    const p1x = this.p1.x - dist * Math.cos(angle + Math.PI / 2);\n    const p1y = this.p1.y - dist * Math.sin(angle + Math.PI / 2);\n    const p2x = this.p2.x - dist * Math.cos(angle + Math.PI / 2);\n    const p2y = this.p2.y - dist * Math.sin(angle + Math.PI / 2);\n\n    const textCenterX = rc.toScreenX((p1x + p2x) / 2 - dist / 2 * Math.cos(angle + Math.PI / 2));\n    const textCenterY = rc.toScreenY((p1y + p2y) / 2 - dist / 2 * Math.sin(angle + Math.PI / 2));\n\n    ctxt.moveTo(\n      rc.toScreenX(p1x + 5 * Math.cos(angle + Math.PI / 2)),\n      rc.toScreenY(p1y + 5 * Math.sin(angle + Math.PI / 2))\n    );\n    ctxt.lineTo(\n      rc.toScreenX(p1x - 5 * Math.cos(angle + Math.PI / 2)),\n      rc.toScreenY(p1y - 5 * Math.sin(angle + Math.PI / 2))\n    );\n\n    ctxt.moveTo(rc.toScreenX(p1x), rc.toScreenY(p1y));\n    ctxt.lineTo(rc.toScreenX(p2x), rc.toScreenY(p2y));\n\n    ctxt.moveTo(\n      rc.toScreenX(p2x + 5 * Math.cos(angle + Math.PI / 2)),\n      rc.toScreenY(p2y + 5 * Math.sin(angle + Math.PI / 2))\n    );\n    ctxt.lineTo(\n      rc.toScreenX(p2x - 5 * Math.cos(angle + Math.PI / 2)),\n      rc.toScreenY(p2y - 5 * Math.sin(angle + Math.PI / 2))\n    );\n\n    ctxt.closePath();\n    ctxt.stroke();\n\n    ctxt.textAlign = 'center';\n    ctxt.textBaseline = 'middle';\n    ctxt.font = '14pt PT-sans';\n    ctxt.fillStyle = this.fixedLengthConstraint != null ? 'rgba(0,0,255,0.4)' : 'rgba(255,0,0,0.4)';\n    ctxt.fillText(Math.round(this.length.value), textCenterX, textCenterY);\n\n    ctxt.lineWidth = origLineWidth;\n    ctxt.strokeStyle = origStrokeStyle;\n    ctxt.fillStyle = origFillStyle;\n    ctxt.font = origFont;\n    ctxt.textAlign = origTextAlign;\n    ctxt.textBaseline = origTextBaseline;\n  }\n}\n\nexport class MinLength extends TwoPointConstraint {\n  constructor(p1, p2, length) {\n    super(p1, p2);\n    this.length = length;\n  }\n\n  propagateKnowns(_knowns) {\n    return false;\n  }\n\n  calculateDeltas(_knowns) {\n    const v12 = this.p2.minus(this.p1);\n    const actualLength = v12.magnitude();\n    if (actualLength >= this.length) {\n      return [];\n    }\n\n    const diff = (actualLength - this.length) / 2;\n    const e12 = v12.normalized();\n    return [\n      new PointDelta(this.p1, e12.scaledBy(diff), this),\n      new PointDelta(this.p2, e12.scaledBy(-diff), this)\n    ];\n  }\n\n  toString() {\n    return `MinLength(${this.p1}, ${this.p2}, ${this.length})`;\n  }\n}\n\nclass PointEquals extends TwoPointConstraint {\n  constructor(p1, p2) {\n    super(p1, p2);\n  }\n\n  propagateKnowns(knowns) {\n    let ans = false;\n\n    // xs\n    if (knowns.xs.has(this.p1) && !knowns.xs.has(this.p2)) {\n      this.p2.x = this.p1.x;\n      knowns.xs.add(this.p2);\n      ans = true;\n    } else if (knowns.xs.has(this.p2) && !knowns.xs.has(this.p1)) {\n      this.p1.x = this.p2.x;\n      knowns.xs.add(this.p1);\n      ans = true;\n    }\n\n    // ys\n    if (knowns.ys.has(this.p1) && !knowns.ys.has(this.p2)) {\n      this.p2.y = this.p1.y;\n      knowns.ys.add(this.p2);\n      ans = true;\n    } else if (knowns.ys.has(this.p2) && !knowns.ys.has(this.p1)) {\n      this.p1.y = this.p2.y;\n      knowns.ys.add(this.p1);\n      ans = true;\n    }\n\n    return ans;\n  }\n\n  calculateDeltas(_knowns) {\n    const diff = this.p2.minus(this.p1);\n    return [\n      new PointDelta(this.p1, diff.scaledBy(0.5), this),\n      new PointDelta(this.p2, diff.scaledBy(-0.5), this)\n    ];\n  }\n}\n\nclass ThreePointConstraint {\n  constructor(p1, p2, p3) {\n    this.p1 = p1;\n    this.p2 = p2;\n    this.p3 = p3;\n  }\n\n  involves(thing) {\n    return thing === this.p1 || thing === this.p2 || thing === this.p3;\n  }\n\n  propagateKnowns(_knowns) {\n    throw new Error('subclass responsibility');\n  }\n\n  calculateDeltas(_knowns) {\n    throw new Error('subclass responsibility');\n  }\n\n  toString() {\n    return `${this.constructor.name}(${this.p1}, ${this.p2}, ${this.p3})`;\n  }\n}\n\nclass FourPointConstraint {\n  constructor(p1, p2, p3, p4) {\n    this.p1 = p1;\n    this.p2 = p2;\n    this.p3 = p3;\n    this.p4 = p4;\n  }\n\n  involves(thing) {\n    return thing === this.p1 || thing === this.p2 || thing === this.p3 || thing === this.p4;\n  }\n\n  propagateKnowns(_knowns) {\n    throw new Error('subclass responsibility');\n  }\n\n  calculateDeltas(_knowns) {\n    throw new Error('subclass responsibility');\n  }\n\n  toString() {\n    return `${this.constructor.name}(${this.p1}, ${this.p2}, ${this.p3}, ${this.p4})`;\n  }\n}\n\n// Orientation constraint, i.e., \"Maintain angle between p1->p2 and p3->p4 at theta.\"\nexport class Orientation extends FourPointConstraint {\n  constructor(l1p1, l1p2, l2p1, l2p2, theta) {\n    super(l1p1, l1p2, l2p1, l2p2);\n    this.theta = theta;\n  }\n\n  propagateKnowns(_knowns) {\n    return false;\n  }\n\n  calculateDeltas(_knowns) {\n    const v12 = this.p2.minus(this.p1);\n    const a12 = Math.atan2(v12.y, v12.x);\n    const m12 = this.p1.plus(this.p2).scaledBy(0.5);\n\n    const v34 = this.p4.minus(this.p3);\n    const a34 = Math.atan2(v34.y, v34.x);\n    const m34 = this.p3.plus(this.p4).scaledBy(0.5);\n\n    const currTheta = (a12 - a34 + 2 * Math.PI) % (2 * Math.PI);\n    const dTheta = (this.theta - currTheta) % (2 * Math.PI);\n    // TODO: figure out why setting dTheta to 1/2 times this value (as shown in the paper\n    // and seems to make sense) results in jumpy/unstable behavior.\n\n    return [\n      new PointDelta(this.p1, this.p1.rotatedAroundBy(m12, dTheta).minus(this.p1), this),\n      new PointDelta(this.p2, this.p2.rotatedAroundBy(m12, dTheta).minus(this.p2), this),\n      new PointDelta(this.p3, this.p3.rotatedAroundBy(m34, -dTheta).minus(this.p3), this),\n      new PointDelta(this.p4, this.p4.rotatedAroundBy(m34, -dTheta).minus(this.p4), this),\n    ];\n  }\n\n  currTheta() {\n    const v12 = this.p2.minus(this.p1);\n    const a12 = Math.atan2(v12.y, v12.x);\n\n    const v34 = this.p4.minus(this.p3);\n    const a34 = Math.atan2(v34.y, v34.x);\n\n    return a12 - a34;\n  }\n}\n\n// p1 + p2 = p3\nclass PointPlus extends ThreePointConstraint {\n  constructor(p1, p2, p3) {\n    super(p1, p2, p3);\n  }\n\n  propagateKnowns(knowns) {\n    let ans = false;\n\n    // xs\n    if (knowns.xs.has(this.p1) && knowns.xs.has(this.p2) && !knowns.xs.has(this.p3)) {\n      this.p3.x = this.p1.x + this.p2.x;\n      knowns.xs.add(this.p3);\n      ans = true;\n    } else if (knowns.xs.has(this.p1) && knowns.xs.has(this.p3) && !knowns.xs.has(this.p2)) {\n      this.p2.x = this.p3.x - this.p1.x;\n      knowns.xs.add(this.p2);\n      ans = true;\n    } else if (knowns.xs.has(this.p2) && knowns.xs.has(this.p3) && !knowns.xs.has(this.p1)) {\n      this.p1.x = this.p3.x - this.p2.x;\n      knowns.xs.add(this.p1);\n      ans = true;\n    }\n\n    // ys\n    if (knowns.ys.has(this.p1) && knowns.ys.has(this.p2) && !knowns.ys.has(this.p3)) {\n      this.p3.y = this.p1.y + this.p2.y;\n      knowns.ys.add(this.p3);\n      ans = true;\n    } else if (knowns.ys.has(this.p1) && knowns.ys.has(this.p3) && !knowns.ys.has(this.p2)) {\n      this.p2.y = this.p3.y - this.p1.y;\n      knowns.ys.add(this.p2);\n      ans = true;\n    } else if (knowns.ys.has(this.p2) && knowns.ys.has(this.p3) && !knowns.ys.has(this.p1)) {\n      this.p1.y = this.p3.y - this.p2.y;\n      knowns.ys.add(this.p1);\n      ans = true;\n    }\n\n    return ans;\n  }\n\n  calculateDeltas(_knowns) {\n    const dx = this.p3.x - (this.p1.x + this.p2.x);\n    const dy = this.p3.y - (this.p1.y + this.p2.y);\n    return [\n      new PointDelta(this.p1, new Point(+dx / 3, +dy / 3), this),\n      new PointDelta(this.p2, new Point(+dx / 3, +dy / 3), this),\n      new PointDelta(this.p3, new Point(-dx / 3, -dy / 3), this)\n    ];\n  }\n\n  drawOver(rc) {\n    if (!rc.showConstraints) {\n      return;\n    }\n\n    const avgX = avg(this.p1.x, this.p2.x, this.p3.x);\n    const avgY = avg(this.p1.y, this.p2.y, this.p3.y);\n\n    const equalsX = avgX - 10;\n    const plusX = avgX + 10;\n\n    const ctxt = rc.ctxt;\n    const origLineWidth = ctxt.lineWidth;\n    const origStrokeStyle = ctxt.strokeStyle;\n    const origFillStyle = ctxt.fillStyle;\n    const origFont = ctxt.font;\n    const origTextAlign = ctxt.textAlign;\n    const origTextBaseline = ctxt.textBaseline;\n\n    ctxt.lineWidth = 1;\n    ctxt.strokeStyle = ctxt.fillStyle = 'rgba(255,255,0,1)';\n    ctxt.beginPath();\n\n    ctxt.moveTo(rc.toScreenX(plusX), rc.toScreenY(avgY));\n    ctxt.lineTo(rc.toScreenX(this.p1.x), rc.toScreenY(this.p1.y));\n    ctxt.moveTo(rc.toScreenX(plusX), rc.toScreenY(avgY));\n    ctxt.lineTo(rc.toScreenX(this.p2.x), rc.toScreenY(this.p2.y));\n    ctxt.moveTo(rc.toScreenX(equalsX), rc.toScreenY(avgY));\n    ctxt.lineTo(rc.toScreenX(this.p3.x), rc.toScreenY(this.p3.y));\n\n    ctxt.closePath();\n    ctxt.stroke();\n\n    ctxt.textAlign = 'center';\n    ctxt.textBaseline = 'middle';\n    ctxt.font = '14pt PT-sans';\n    ctxt.fillStyle = 'black';\n    ctxt.fillText('+', rc.toScreenX(plusX), rc.toScreenY(avgY));\n    ctxt.fillText('=', rc.toScreenX(equalsX), rc.toScreenY(avgY));\n\n    ctxt.lineWidth = origLineWidth;\n    ctxt.strokeStyle = origStrokeStyle;\n    ctxt.fillStyle = origFillStyle;\n    ctxt.font = origFont;\n    ctxt.textAlign = origTextAlign;\n    ctxt.textBaseline = origTextBaseline;\n  }\n}\n\n// p1 * n = p2\nclass PointTimes extends TwoPointConstraint {\n  constructor(p1, n, p2) {\n    super(p1, p2);\n    this.n = n;\n  }\n\n  propagateKnowns(knowns) {\n    let ans = false;\n\n    // xs\n    if (knowns.xs.has(this.p1) && knowns.vars.has(this.n) && !knowns.xs.has(this.p2)) {\n      this.p2.x = this.p1.x * this.n.value;\n      knowns.xs.add(this.p2);\n      ans = true;\n    } else if (knowns.xs.has(this.p1) && knowns.xs.has(this.p2) && !knowns.vars.has(this.n)) {\n      this.n.value = this.p2.x / this.p1.x;\n      knowns.vars.add(this.n);\n      ans = true;\n    } else if (knowns.vars.has(this.n) && knowns.xs.has(this.p2) && !knowns.xs.has(this.p1)) {\n      this.p1.x = this.p2.x / this.n.value;\n      knowns.xs.add(this.p1);\n      ans = true;\n    }\n\n    // ys\n    if (knowns.ys.has(this.p1) && knowns.vars.has(this.n) && !knowns.ys.has(this.p2)) {\n      this.p2.y = this.p1.y * this.n.value;\n      knowns.ys.add(this.p2);\n      ans = true;\n    } else if (knowns.ys.has(this.p1) && knowns.ys.has(this.p2) && !knowns.vars.has(this.n)) {\n      this.n.value = this.p2.y / this.p1.y;\n      knowns.vars.add(this.n);\n      ans = true;\n    } else if (knowns.vars.has(this.n) && knowns.ys.has(this.p2) && !knowns.ys.has(this.p1)) {\n      this.p1.y = this.p2.y / this.n.value;\n      knowns.ys.add(this.p1);\n      ans = true;\n    }\n\n    return ans;\n  }\n\n  // TODO: change n, too!\n  calculateDeltas(_knowns) {\n    const xDiff = this.p2.x - this.n.value * this.p1.x;\n    const yDiff = this.p2.y - this.n.value * this.p1.y;\n    return [\n      new PointDelta(this.p1, new Point(+xDiff / 2 / this.n.value, +yDiff / 2 / this.n.value), this),\n      new PointDelta(this.p2, new Point(-xDiff / 2, -yDiff / 2), this)\n    ];\n  }\n}\n\n// -------\n\nclass Time {\n  constructor(v) {\n    this.v = v;\n  }\n\n  propagateKnowns(knowns) {\n    if (!knowns.vars.has(this.v)) {\n      this.v.value = Time.nowSeconds;\n      knowns.vars.add(this.v);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  calculateDeltas(_knowns) {\n    const diff = Time.nowSeconds - this.v.value;\n    return [new VarDelta(this.v, diff, this)];\n  }\n}\n\n// -------\n\nclass Clock extends TwoPointConstraint {\n  constructor(p1, p2, length, speed, nowSeconds) {\n    super(p1, p2);\n    this.length = length;\n    this.speed = speed;\n    this.nowSeconds = nowSeconds;\n  }\n\n  propagateKnowns(knowns) {\n    if (!knowns.vars.has(this.nowSeconds)) {\n      return false;\n    }\n\n    const theta = this.calculateTheta(this.nowSeconds.value);\n    let ans = false;\n\n    // xs\n    if (knowns.xs.has(this.p1) && !knowns.xs.has(this.p2)) {\n      this.p2.x = this.p1.x + this.length * Math.cos(theta);\n      knowns.xs.add(this.p2);\n      ans = true;\n    }\n\n    // xs\n    if (knowns.ys.has(this.p1) && !knowns.ys.has(this.p2)) {\n      this.p2.y = this.p1.y + this.length * Math.sin(theta);\n      knowns.ys.add(this.p2);\n      ans = true;\n    }\n\n    return ans;\n  }\n\n  calculateDeltas(_knowns) {\n    const theta = this.calculateTheta(this.nowSeconds.value);\n    const wantedX = this.p1.x + this.length * Math.cos(theta);\n    const wantedY = this.p1.y + this.length * Math.sin(theta);\n    return [\n      new PointDelta(\n        this.p2,\n        new Point(\n          wantedX - this.p2.x,\n          wantedY - this.p2.y\n        ),\n        this\n      )\n    ];\n  }\n\n  calculateTheta(seconds) {\n    return -seconds / (60 / this.speed) * 2 * Math.PI;\n  }\n}\n\n// -------\n\nclass PropertyPicker {\n  constructor(p, property, v) {\n    if (property !== 'x' && property !== 'y') {\n      throw new Error('PropertyPicker only supports x and y');\n    }\n    this.p = p;\n    this.property = property;\n    this.v = v;\n  }\n\n  involves(thing) {\n    return thing === this.p || thing === this.v;\n  }\n\n  propagateKnowns(knowns) {\n    if (this.property === 'x') {\n      if (knowns.xs.has(this.p) && !knowns.vars.has(this.v)) {\n        this.v.value = this.p.x;\n        knowns.vars.add(this.v);\n        return true;\n      } else if (knowns.vars.has(this.v) && !knowns.xs.has(this.p)) {\n        this.p.x = this.v.value;\n        knowns.xs.add(this.p);\n        return true;\n      }\n    } else if (this.property === 'y') {\n      if (knowns.ys.has(this.p) && !knowns.vars.has(this.v)) {\n        this.v.value = this.p.y;\n        knowns.vars.add(this.v);\n        return true;\n      } else if (knowns.vars.has(this.v) && !knowns.ys.has(this.p)) {\n        this.p.y = this.v.value;\n        knowns.ys.add(this.p);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  calculateDeltas(_knowns) {\n    if (this.property === 'x') {\n      const diff = this.v.value - this.p.x;\n      return [\n        new PointDelta(this.p, new Point(diff / 2, 0), this),\n        new VarDelta(this.v, -diff / 2, this)\n      ];\n    } else if (this.property === 'y') {\n      const diff = this.v.value - this.p.y;\n      return [\n        new PointDelta(this.p, new Point(0, diff / 2), this),\n        new VarDelta(this.v, -diff / 2, this)\n      ];\n    } else {\n      throw new Error('impossible');\n    }\n  }\n}\n\n// -------\n\nexport class SpreadsheetCell extends Var {\n  epsilon = 0.1;\n  tinyDelta = 0.000001;\n  maxIterations = 100;\n\n  constructor(inputs /* { xs, ys, vars } */, computeValueFn) {\n    super(0);\n    this.inputs = inputs;\n    this.computeValueFn = computeValueFn;\n  }\n\n  toString() {\n    return `SpreadsheetCell(${this.value}, ${this.computeValueFn.toString().substring(6)})`;\n  }\n\n  involves(thing) {\n    // TODO: this isn't always right, e.g., in the slider example\n    return this.inputs.xs?.includes(thing)\n      || this.inputs.ys?.includes(thing)\n      || this.inputs.vars?.includes(thing);\n  }\n\n  propagateKnowns(knowns) {\n    if (\n      !knowns.vars.has(this) &&\n      this.allKnown(this.inputs.xs, knowns.xs) &&\n      this.allKnown(this.inputs.ys, knowns.ys) &&\n      this.allKnown(this.inputs.vars, knowns.vars)\n    ) {\n      this.value = this.computeValue();\n      knowns.vars.add(this);\n      return true;\n    } else {\n      // TODO: use relaxation if result is known and all but one of the inputs are known\n     return false;\n    }\n  }\n\n  allKnown(inputs, knowns) {\n    return inputs == null || inputs.every(input => knowns.has(input));\n  }\n\n  // Note: this method changes the values of the inputs.\n  // It is the caller's responsibility to snapshot their values before calling this\n  // method, and restore their values afterwards.\n  currentValueHasNoSolution(realKnowns) {\n    const knowns = {\n      vars: {\n        has: (v) => {\n          return v === this || realKnowns.vars?.has(v);\n        }\n      },\n      xs: {\n        has: (p) => {\n          return realKnowns.xs?.has(p);\n        }\n      },\n      ys: {\n        has: (p) => {\n          return realKnowns.ys?.has(p);\n        }\n      }\n    };\n    const error = this.relax(knowns);\n    return error > this.epsilon;\n  }\n\n  relax(knowns) {\n    let idx = 0, error;\n    while (true) {\n      error = this.calculateError();\n      if (idx++ >= this.maxIterations || error <= this.epsilon) {\n        break;\n      }\n\n      let numNonZeroDeltaAmounts = 0;\n      const calculateDeltaAmounts = (things, property, knowns) => {\n        if (things == null) {\n          return null;\n        }\n        const deltaAmounts = [];\n        for (const thing of things) {\n          if (knowns && knowns.has(thing)) {\n            deltaAmounts.push(0);\n            continue;\n          }\n          const m = this.derivativeOfErrorWrt(thing, property);\n          const b = error - m * thing[property];\n          const newValue = -b / m;\n          const deltaAmount = isFinite(newValue) ? newValue - thing[property] : 0;\n          if (deltaAmount !== 0) {\n            numNonZeroDeltaAmounts++;\n          }\n          deltaAmounts.push(deltaAmount);\n        }\n\n        return deltaAmounts;\n      };\n\n      const deltaAmounts = {\n        xs: calculateDeltaAmounts(this.inputs.xs, 'x', knowns.xs),\n        ys: calculateDeltaAmounts(this.inputs.ys, 'y', knowns.ys),\n        vars: calculateDeltaAmounts(this.inputs.vars, 'value', knowns.vars),\n        self: calculateDeltaAmounts([this], 'value', knowns.vars)[0]\n      };\n\n      if (numNonZeroDeltaAmounts === 0) {\n        error = this.calculateError();\n        break;\n      }\n\n      deltaAmounts.xs?.forEach((dx, idx) => this.inputs.xs[idx].x += dx / numNonZeroDeltaAmounts);\n      deltaAmounts.ys?.forEach((dy, idx) => this.inputs.ys[idx].y += dy / numNonZeroDeltaAmounts);\n      deltaAmounts.vars?.forEach((dv, idx) => this.inputs.vars[idx].value += dv / numNonZeroDeltaAmounts);\n      this.value += deltaAmounts.self / numNonZeroDeltaAmounts;\n    }\n    return error;\n  }\n\n  calculateDeltas(knowns) {\n    const snapshot = this.snapshotInputs();\n    const origValue = this.value;\n    const restoreState = () => {\n      this.restoreInputs(snapshot);\n      this.value = origValue;\n    }\n\n    const noSolution = this.currentValueHasNoSolution(knowns);\n    restoreState();\n    if (noSolution) {\n      // Don't mess around b/c that will result in jank!\n      return [];\n    }\n\n    const error = this.relax(knowns);\n    if (error > this.epsilon) {\n      // Didn't find a good solution, so we'll just try to fix the output.\n      if (knowns.vars?.has(this)) {\n        // ... but if we're not allowed to change the output, just give up.\n        restoreState();\n        return [];\n      } else {\n        const newValue = this.computeValue();\n        restoreState();\n        return [new VarDelta(this, newValue - this.value, this)];\n      }\n    }\n    \n    const newValues = {\n      self: this.value,\n      xs: this.inputs.xs?.map(p => p.x),\n      ys: this.inputs.ys?.map(p => p.y),\n      vars: this.inputs.vars?.map(v => v.value)\n    };\n    restoreState();\n    const deltas = [new VarDelta(this, newValues.self - this.value, this)];\n    if (newValues.xs) {\n      deltas.push(\n        ...newValues.xs.map(\n          (newValue, idx) =>\n            new PointDelta(\n              this.inputs.xs[idx],\n              new Point(newValue - this.inputs.xs[idx].x, 0),\n              this\n            )\n        )\n      );\n    }\n    if (newValues.ys) {\n      deltas.push(\n        ...newValues.ys.map(\n          (newValue, idx) =>\n            new PointDelta(\n              this.inputs.ys[idx],\n              new Point(0, newValue - this.inputs.ys[idx].y),\n              this\n            )\n        )\n      );\n    }\n    if (newValues.vars) {\n      deltas.push(\n        ...newValues.vars.map(\n          (newValue, idx) =>\n            new VarDelta(\n              this.inputs.vars[idx],\n              newValue - this.inputs.vars[idx].value,\n              this\n            )\n        )\n      );\n    }\n    return deltas;\n  }\n\n  derivativeOfErrorWrt(thing, property) {\n    const origValue = thing[property];\n\n    const calcDerivative = (x0, x1) => {\n      thing[property] = x0;\n      const y0 = this.calculateError();\n      thing[property] = x1;\n      const y1 = this.calculateError();\n      thing[property] = origValue;\n      return (y1 - y0) / (x1 - x0);\n    }\n\n    let m = calcDerivative(origValue - this.tinyDelta, origValue + this.tinyDelta);\n    if (Math.abs(m) < this.tinyDelta) {\n      m = calcDerivative(origValue, origValue + this.tinyDelta);\n    }\n    if (Math.abs(m) < this.tinyDelta) {\n      m = calcDerivative(origValue - this.tinyDelta, origValue);\n    }\n    return m;\n  }\n\n  calculateError() {\n    return Math.abs(this.computeValue() - this.value);\n  }\n\n  computeValue(setValue) {\n    const v = this.computeValueFn();\n    if (setValue) {\n      this.value = v;\n    }\n    return v;\n  }\n\n  snapshotInputs() {\n    return {\n      xs: this.inputs.xs?.map(p => p.x),\n      ys: this.inputs.ys?.map(p => p.y),\n      vars: this.inputs.vars?.map(v => v.value)\n    };\n  }\n\n  restoreInputs(snapshot) {\n    this.inputs.xs?.forEach((p, idx) => {\n      p.x = snapshot.xs[idx];\n    });\n    this.inputs.ys?.forEach((p, idx) => {\n      p.y = snapshot.ys[idx];\n    });\n    this.inputs.vars?.forEach((v, idx) => v.value = snapshot.vars[idx]);\n  }\n}\n\n// -------\n\nclass MidPoint extends ThreePointConstraint {\n  constructor(p1, pm, p3, optFract) {\n    super(p1, pm, p3);\n    const fract = optFract ?? 0.5;\n    const pmX = new SpreadsheetCell(\n      { xs: [p1, p3] },\n      () =>  p1.x + fract * (p3.x - p1.x)\n    );\n    const pmY = new SpreadsheetCell(\n      { ys: [p1, p3] },\n      () => p1.y +fract * (p3.y - p1.y)\n    );\n    this.constraints = [\n      pmX, new PropertyPicker(pm, 'x', pmX),\n      pmY, new PropertyPicker(pm, 'y', pmY)\n    ];\n  }\n\n  propagateKnowns(knowns) {\n    let ans = false;\n    for (const c of this.constraints) {\n      ans = c.propagateKnowns(knowns) || ans;\n    }\n    return ans;\n  }\n\n  calculateDeltas(knowns) {\n    return this.constraints.flatMap(c => c.calculateDeltas(knowns));\n  }\n}\n\nfunction avg(...xs) {\n  return xs.reduce((a, b) => a + b) / xs.length;\n}\n", "// Math\n// The JS Math APIs aren't great. Here's a few extras that are nice to have.\n\nexport const TAU = Math.PI * 2;\n\nexport const isZero = (v) => {\n  return Number.EPSILON > Math.abs(v);\n};\n\nexport const isNonZero = (v) => {\n  return !Math.zero(v);\n};\n\nexport const avg = (a, b) => {\n  return (a + b) / 2;\n};\n\nexport const clip = (v, min = 0, max = 1) => {\n  return Math.min(Math.max(min, v), max);\n};\n\nexport const lerpN = (input, outputMin = 0, outputMax = 1, doClip = false) => {\n  input *= outputMax - outputMin;\n  input += outputMin;\n  if (doClip) input = clip(input, outputMin, outputMax);\n  return input;\n};\n\n// Prettier really screwed this one up, alas.\n// The args should be: input, inputMin, inputMax, outputMin, outputMax, doClip\nexport const lerp = (i, im = 0, iM = 1, om = 0, oM = 1, doClip = true) => {\n  if (im == iM) return om; // Avoids a divide by zero\n  if (im > iM) [im, iM, om, oM] = [iM, im, oM, om];\n  if (doClip) i = clip(i, im, iM);\n  i -= im;\n  i /= iM - im;\n  return lerpN(i, om, oM, false);\n};\n\nexport const rand = (min = -1, max = 1) => {\n  return lerpN(Math.random(), min, max);\n};\n\nexport const randInt = (min, max) => {\n  return Math.round(rand(min, max));\n};\n\nexport const roundTo = (input, precision) => {\n  // Using the reciprocal avoids floating point errors. Eg: 3/10 is fine, but 3*0.1 is wrong.\n  p = 1 / precision;\n  return Math.round(input * p) / p;\n};\n\nexport const easeInOut = (t) => {\n  let ease = (t) => Math.pow(t, 3);\n  if (t < 0.5) return lerp(ease(t * 2), 0, 1, 0, 0.5);\n  else return lerp(ease((1 - t) * 2), 1, 0, 0.5, 1);\n};", "// Vec\n// This is a port of (part of) Ivan's homemade CoffeeScript vector library.\n\nimport { Point as RPoint } from './relax-pk.js';\nimport { isZero, roundTo, clip } from \"./math.js\";\n\n// Constructors ///////////////////////////////////////////////////////////////\n\nconst Vec = (x = 0, y = 0) => {\n  return new RPoint(x, y);\n};\nexport default Vec;\n\nVec.clone = (v) => {\n  return Vec(v.x, v.y);\n};\n\nVec.fromRectXY = (r) => {\n  return Vec(r.x, r.y);\n};\n\nVec.fromRectWH = (r) => {\n  return Vec(r.w, r.h);\n};\n\nVec.fromRectRB = (r) => {\n  return Vec(r.x + r.w, r.y + r.h);\n};\n\nVec.of = (s) => {\n  return Vec(s, s);\n};\n\nVec.random = (scale = 1) => {\n  return Vec.Smul(\n    scale,\n    Vec.complement(Vec.Smul(2, Vec(Math.random(), Math.random())))\n  );\n};\n\nVec.toA = (v) => {\n  return [v.x, v.y];\n};\n\nVec.polar = (angle, length) => {\n  const angleInRadians = (angle * Math.PI) / 180;\n  return Vec(\n    length * Math.cos(angleInRadians),\n    length * Math.sin(angleInRadians)\n  );\n}\n\n// Static Vectors /////////////////////////////////////////////////////////////\n\nVec.x = Object.freeze(Vec(1));\nVec.y = Object.freeze(Vec(0, 1));\nVec.zero = Object.freeze(Vec());\n\n// FP /////////////////////////////////////////////////////////////////////////\n\nVec.map = (f, v) => {\n  return Vec(f(v.x), f(v.y));\n};\n\nVec.map2 = (f, a, b) => {\n  return Vec(f(a.x, b.x), f(a.y, b.y));\n};\n\nVec.reduce = (f, v) => {\n  return f(v.x, v.y);\n};\n\n// Vector Algebra /////////////////////////////////////////////////////////////\n\n// Not really cross product, but close enough\nVec.cross = (a, b) => {\n  return a.x * b.y - a.y * b.x\n};\n\nVec.project = (a, b) => {\n  return Vec.mulS(b, Vec.dot(a, b) / Vec.len2(b));\n};\n\nVec.reject = (a, b) => {\n  return Vec.sub(a, Vec.project(a, b));\n};\n\nVec.scalarProjection = (p, a, b) => {\n  let ap = Vec.sub(p, a)\n  let ab = Vec.normalize(Vec.sub(b, a))\n  let f = Vec.mulS(ab,  Vec.dot(ap, ab))\n  return Vec.add(a, f)\n}\n\n// Piecewise Vector Arithmetic ////////////////////////////////////////////////\n\nVec.add = (a, b) => {\n  return Vec(a.x + b.x, a.y + b.y);\n};\n\nVec.div = (a, b) => {\n  return Vec(a.x / b.x, a.y / b.y);\n};\n\nVec.mul = (a, b) => {\n  return Vec(a.x * b.x, a.y * b.y);\n};\n\nVec.sub = (a, b) => {\n  return Vec(a.x - b.x, a.y - b.y);\n};\n\n// Vector-Scalar Arithmetic ///////////////////////////////////////////////////\n\nVec.addS = (v, s) => {\n  return Vec.add(v, Vec.of(s));\n};\n\nVec.divS = (v, s) => {\n  return Vec.div(v, Vec.of(s));\n};\n\nVec.mulS = (v, s) => {\n  return Vec.mul(v, Vec.of(s));\n};\n\nVec.subS = (v, s) => {\n  return Vec.sub(v, Vec.of(s));\n};\n\n// Scalar-Vector Arithmetic ///////////////////////////////////////////////////\n\nVec.Sadd = (s, v) => {\n  return Vec.add(Vec.of(s), v);\n};\n\nVec.Sdiv = (s, v) => {\n  return Vec.div(Vec.of(s), v);\n};\n\nVec.Smul = (s, v) => {\n  return Vec.mul(Vec.of(s), v);\n};\n\nVec.Ssub = (s, v) => {\n  return Vec.sub(Vec.of(s), v);\n};\n\n// Measurement ////////////////////////////////////////////////////////////////\n\nVec.dist = (a, b) => {\n  return Vec.len(Vec.sub(a, b));\n};\n\n// Strongly recommend using Vec.dist instead of Vec.dist2 (distance-squared)\nVec.dist2 = (a, b) => {\n  return Vec.len2(Vec.sub(a, b));\n};\n\nVec.dot = (a, b) => {\n  return a.x * b.x + a.y * b.y;\n};\n\nVec.equal = (a, b) => {\n  return isZero(Vec.dist2(a, b));\n};\n\n// Strongly recommend using Vec.len instead of Vec.len2 (length-squared)\nVec.len2 = (v) => {\n  return Vec.dot(v, v);\n};\n\nVec.len = (v) => {\n  return Math.sqrt(Vec.dot(v, v));\n};\n\n// Rounding ///////////////////////////////////////////////////////////////////\n\nVec.ceil = (v) => {\n  return Vec.map(Math.ceil, v);\n};\n\nVec.floor = (v) => {\n  return Vec.map(Math.floor, v);\n};\n\nVec.round = (v) => {\n  return Vec.map(Math.round, v);\n};\n\nVec.roundTo = (v, s) => {\n  return Vec.map2(roundTo, v, Vec.of(s));\n};\n\n// Variations ///////////////////////////////////////////////////////////////////\n\nVec.complement = (v) => {\n  return Vec.Ssub(1, v);\n};\n\nVec.half = (v) => {\n  return Vec.divS(v, 2);\n};\n\nVec.normalize = (v) => {\n  return Vec.divS(v, Vec.len(v));\n};\n\nVec.recip = (v) => {\n  return Vec.Sdiv(1, v);\n};\n\n// Prettier really screwed this one up, alas.\n// The args should be: input, inputMin, inputMax, outputMin, outputMax\nVec.renormalize = (v, im, iM, om, oM) => {\n  return Vec.add(\n    Vec.mul(Vec.div(Vec.sub(v, im), Vec.sub(iM, im)), Vec.sub(oM, om)),\n    om\n  );\n};\n\n// Combinations ///////////////////////////////////////////////////////////////////\n\nVec.avg = (a, b) => {\n  return Vec.half(Vec.add(a, b));\n};\n\nVec.lerp = (a, b, t) => {\n  return Vec.add(a, Vec.Smul(t, Vec.sub(b, a)));\n};\n\nVec.max = (a, b) => {\n  return Vec.map2(Math.max, a, b);\n};\n\nVec.min = (a, b) => {\n  return Vec.map2(Math.min, a, b);\n};\n\n// Reflections ///////////////////////////////////////////////////////////////////\n\nVec.abs = (v) => {\n  return Vec.map(Math.abs, v);\n};\n\nVec.invert = (v) => {\n  return Vec(-v.x, -v.y);\n};\n\nVec.invertX = (v) => {\n  return Vec(-v.x, v.y);\n};\n\nVec.invertY = (v) => {\n  return Vec(v.x, -v.y);\n};\n\n// Rotation & angles ///////////////////////////////////////////////////////////\n\n\n// 90 degrees clockwise\nVec.rotate90CW = (v)=>{\n  return Vec(v.y, -v.x);\n}\n\n// 90 degrees counter clockwise\nVec.rotate90CCW = (v)=>{\n  return Vec(-v.y, v.x);\n}\n\nVec.angle = (v) =>{\n  var angleInRadians = Math.atan2(v.y, v.x);\n  var angleInDegrees = ((angleInRadians * 180) / Math.PI)\n  if (angleInDegrees < 0) {\n    angleInDegrees += 360;\n  }\n  return angleInDegrees;\n}\n\nVec.angleBetween = (a, b) => {\n  // Calculate the dot product of the two vectors\n  const dotProduct = Vec.dot(a, b);\n\n  // Calculate the magnitudes of the two vectors\n  const magnitudeA = Vec.len(a);\n  const magnitudeB = Vec.len(b);\n\n  // Calculate the angle between the vectors using the dot product and magnitudes\n  const angleInRadians = Math.acos(dotProduct / (magnitudeA * magnitudeB));\n\n  // Convert the angle from radians to degrees\n  const angleInDegrees = (angleInRadians * 180) / Math.PI;\n\n  return angleInDegrees;\n}\n\nVec.angleBetweenClockwise = (a, b) => {\n  const dP = Vec.dot(a, b);\n  const cP = Vec.cross(a, b);\n\n  let angle = Math.atan2(dP, cP);\n\n  // Convert the angle from radians to degrees\n  let angleInDegrees = angle * (180 / Math.PI);\n  if (angleInDegrees < 0) {\n    angleInDegrees = 360 + angleInDegrees;\n  }\n\n  return angleInDegrees;\n}", "// Line\n// This is a collection of functions related to line segments written by Marcel with help of ChatGPT\n\nimport Vec from \"./vec.js\"\n\nconst Line = (a, b) =>{\n    return {a, b}\n}\nexport default Line\n\nLine.len = (l)=>{\n    return Vec.dist(l.a, l.b)\n}\n\n// Returns intersection if the line segments overlap, or null if they don't\nLine.intersect = (l1, l2) =>{\n    const { a: p1, b: p2 } = l1;\n    const { a: q1, b: q2 } = l2;\n\n    const dx1 = p2.x - p1.x;\n    const dy1 = p2.y - p1.y;\n    const dx2 = q2.x - q1.x;\n    const dy2 = q2.y - q1.y;\n\n    const determinant = dx1 * dy2 - dy1 * dx2;\n\n    if (determinant === 0) {\n        // The lines are parallel or coincident\n        return null;\n    }\n\n    const dx3 = p1.x - q1.x;\n    const dy3 = p1.y - q1.y;\n\n    const t = (dx3 * dy2 - dy3 * dx2) / determinant;\n    const u = (dx1 * dy3 - dy1 * dx3) / determinant;\n\n    if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n        // The segments intersect at a point\n        const intersectionX = p1.x + t * dx1;\n        const intersectionY = p1.y + t * dy1;\n        return { x: intersectionX, y: intersectionY };\n    }\n\n    // The segments do not intersect\n    return null;\n}\n\n// Always returns intersection point even if the line segments don't overlap\nLine.intersectAnywhere = (l1, l2) =>{\n    const { a: p1, b: p2 } = l1;\n    const { a: q1, b: q2 } = l2;\n  \n    const dx1 = p2.x - p1.x;\n    const dy1 = p2.y - p1.y;\n    const dx2 = q2.x - q1.x;\n    const dy2 = q2.y - q1.y;\n  \n    const determinant = dx1 * dy2 - dy1 * dx2;\n  \n    if (determinant === 0) {\n      // The lines are parallel or coincident\n      return null;\n    }\n  \n    const dx3 = p1.x - q1.x;\n    const dy3 = p1.y - q1.y;\n  \n    const t = (dx3 * dy2 - dy3 * dx2) / determinant;\n    const u = (dx1 * dy3 - dy1 * dx3) / determinant;\n  \n    const intersectionX = p1.x + t * dx1;\n    const intersectionY = p1.y + t * dy1;\n  \n    return { x: intersectionX, y: intersectionY };\n}\n\n// Get point along slope\nLine.getYforX = (line, x) => {\n    // Extract the coordinates of points a and b\n    const { a, b } = line;\n    const { x: x1, y: y1 } = a;\n    const { x: x2, y: y2 } = b;\n    \n    // Calculate the slope of the line\n    const slope = (y2 - y1) / (x2 - x1);\n    \n    // Calculate the y-coordinate for the given x-coordinate\n    const y = slope * (x - x1) + y1;\n    \n    return y;\n}\n\n// Get point along slope\nLine.getXforY = (line, y) => {\n    // Extract the coordinates of points a and b\n    const { a, b } = line;\n    const { x: x1, y: y1 } = a;\n    const { x: x2, y: y2 } = b;\n\n    // Calculate the slope of the line\n    const slope = (y2 - y1) / (x2 - x1);\n\n    // Calculate the x-coordinate for the given y-coordinate\n    const x = (y - y1) / slope + x1;\n\n    return x;\n}\n\n\nLine.distToPoint = (line, point) => {\n    const { a, b } = line;\n\n    // Calculate vector AB and AP\n    const AB = Vec.sub(b, a);\n    const AP = Vec.sub(point, a);\n  \n    // Calculate the projection of AP onto AB\n    const projection = Vec.dot(AP, AB) / Vec.dot(AB, AB);\n  \n    // Check if the projection is outside the line segment\n    if (projection <= 0) {\n        // Closest point is A\n        return Vec.len(AP);\n    } else if (projection >= 1) {\n        // Closest point is B\n        return Vec.dist(point, b);\n    } else {\n        // Closest point is between A and B\n        const closestPoint = Vec.add(a, Vec.mulS(AB, projection));\n        return Vec.dist(point, closestPoint);\n    }\n}", "// --------------------------------------------------------------------\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nfunction abstract(optMethodName) {\n  const methodName = optMethodName || '';\n  return function() {\n    throw new Error(\n        'this method ' +\n        methodName +\n        ' is abstract! ' +\n        '(it has no implementation in class ' +\n        this.constructor.name +\n        ')',\n    );\n  };\n}\n\nfunction assert(cond, message) {\n  if (!cond) {\n    throw new Error(message || 'Assertion failed');\n  }\n}\n\n// Define a lazily-computed, non-enumerable property named `propName`\n// on the object `obj`. `getterFn` will be called to compute the value the\n// first time the property is accessed.\nfunction defineLazyProperty(obj, propName, getterFn) {\n  let memo;\n  Object.defineProperty(obj, propName, {\n    get() {\n      if (!memo) {\n        memo = getterFn.call(this);\n      }\n      return memo;\n    },\n  });\n}\n\nfunction clone(obj) {\n  if (obj) {\n    return Object.assign({}, obj);\n  }\n  return obj;\n}\n\nfunction repeatFn(fn, n) {\n  const arr = [];\n  while (n-- > 0) {\n    arr.push(fn());\n  }\n  return arr;\n}\n\nfunction repeatStr(str, n) {\n  return new Array(n + 1).join(str);\n}\n\nfunction repeat(x, n) {\n  return repeatFn(() => x, n);\n}\n\nfunction getDuplicates(array) {\n  const duplicates = [];\n  for (let idx = 0; idx < array.length; idx++) {\n    const x = array[idx];\n    if (array.lastIndexOf(x) !== idx && duplicates.indexOf(x) < 0) {\n      duplicates.push(x);\n    }\n  }\n  return duplicates;\n}\n\nfunction copyWithoutDuplicates(array) {\n  const noDuplicates = [];\n  array.forEach(entry => {\n    if (noDuplicates.indexOf(entry) < 0) {\n      noDuplicates.push(entry);\n    }\n  });\n  return noDuplicates;\n}\n\nfunction isSyntactic(ruleName) {\n  const firstChar = ruleName[0];\n  return firstChar === firstChar.toUpperCase();\n}\n\nfunction isLexical(ruleName) {\n  return !isSyntactic(ruleName);\n}\n\nfunction padLeft(str, len, optChar) {\n  const ch = optChar || ' ';\n  if (str.length < len) {\n    return repeatStr(ch, len - str.length) + str;\n  }\n  return str;\n}\n\n// StringBuffer\n\nfunction StringBuffer() {\n  this.strings = [];\n}\n\nStringBuffer.prototype.append = function(str) {\n  this.strings.push(str);\n};\n\nStringBuffer.prototype.contents = function() {\n  return this.strings.join('');\n};\n\nconst escapeUnicode = str => String.fromCodePoint(parseInt(str, 16));\n\nfunction unescapeCodePoint(s) {\n  if (s.charAt(0) === '\\\\') {\n    switch (s.charAt(1)) {\n      case 'b':\n        return '\\b';\n      case 'f':\n        return '\\f';\n      case 'n':\n        return '\\n';\n      case 'r':\n        return '\\r';\n      case 't':\n        return '\\t';\n      case 'v':\n        return '\\v';\n      case 'x':\n        return escapeUnicode(s.slice(2, 4));\n      case 'u':\n        return s.charAt(2) === '{' ?\n          escapeUnicode(s.slice(3, -1)) :\n          escapeUnicode(s.slice(2, 6));\n      default:\n        return s.charAt(1);\n    }\n  } else {\n    return s;\n  }\n}\n\n// Helper for producing a description of an unknown object in a safe way.\n// Especially useful for error messages where an unexpected type of object was encountered.\nfunction unexpectedObjToString(obj) {\n  if (obj == null) {\n    return String(obj);\n  }\n  const baseToString = Object.prototype.toString.call(obj);\n  try {\n    let typeName;\n    if (obj.constructor && obj.constructor.name) {\n      typeName = obj.constructor.name;\n    } else if (baseToString.indexOf('[object ') === 0) {\n      typeName = baseToString.slice(8, -1); // Extract e.g. \"Array\" from \"[object Array]\".\n    } else {\n      typeName = typeof obj;\n    }\n    return typeName + ': ' + JSON.stringify(String(obj));\n  } catch (e) {\n    return baseToString;\n  }\n}\n\nvar common = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  abstract: abstract,\n  assert: assert,\n  defineLazyProperty: defineLazyProperty,\n  clone: clone,\n  repeatFn: repeatFn,\n  repeatStr: repeatStr,\n  repeat: repeat,\n  getDuplicates: getDuplicates,\n  copyWithoutDuplicates: copyWithoutDuplicates,\n  isSyntactic: isSyntactic,\n  isLexical: isLexical,\n  padLeft: padLeft,\n  StringBuffer: StringBuffer,\n  unescapeCodePoint: unescapeCodePoint,\n  unexpectedObjToString: unexpectedObjToString\n});\n\n// These are just categories that are used in ES5/ES2015.\n// The full list of Unicode categories is here: http://www.fileformat.info/info/unicode/category/index.htm.\nconst UnicodeCategories = {\n  // Letters\n  Lu: /\\p{Lu}/u,\n  Ll: /\\p{Ll}/u,\n  Lt: /\\p{Lt}/u,\n  Lm: /\\p{Lm}/u,\n  Lo: /\\p{Lo}/u,\n\n  // Numbers\n  Nl: /\\p{Nl}/u,\n  Nd: /\\p{Nd}/u,\n\n  // Marks\n  Mn: /\\p{Mn}/u,\n  Mc: /\\p{Mc}/u,\n\n  // Punctuation, Connector\n  Pc: /\\p{Pc}/u,\n\n  // Separator, Space\n  Zs: /\\p{Zs}/u,\n\n  // These two are not real Unicode categories, but our useful for Ohm.\n  // L is a combination of all the letter categories.\n  // Ltmo is a combination of Lt, Lm, and Lo.\n  L: /\\p{Letter}/u,\n  Ltmo: /\\p{Lt}|\\p{Lm}|\\p{Lo}/u,\n};\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n// General stuff\n\nclass PExpr {\n  constructor() {\n    if (this.constructor === PExpr) {\n      throw new Error(\"PExpr cannot be instantiated -- it's abstract\");\n    }\n  }\n\n  // Set the `source` property to the interval containing the source for this expression.\n  withSource(interval) {\n    if (interval) {\n      this.source = interval.trimmed();\n    }\n    return this;\n  }\n}\n\n// Any\n\nconst any = Object.create(PExpr.prototype);\n\n// End\n\nconst end = Object.create(PExpr.prototype);\n\n// Terminals\n\nclass Terminal extends PExpr {\n  constructor(obj) {\n    super();\n    this.obj = obj;\n  }\n}\n\n// Ranges\n\nclass Range extends PExpr {\n  constructor(from, to) {\n    super();\n    this.from = from;\n    this.to = to;\n    // If either `from` or `to` is made up of multiple code units, then\n    // the range should consume a full code point, not a single code unit.\n    this.matchCodePoint = from.length > 1 || to.length > 1;\n  }\n}\n\n// Parameters\n\nclass Param extends PExpr {\n  constructor(index) {\n    super();\n    this.index = index;\n  }\n}\n\n// Alternation\n\nclass Alt extends PExpr {\n  constructor(terms) {\n    super();\n    this.terms = terms;\n  }\n}\n\n// Extend is an implementation detail of rule extension\n\nclass Extend extends Alt {\n  constructor(superGrammar, name, body) {\n    const origBody = superGrammar.rules[name].body;\n    super([body, origBody]);\n\n    this.superGrammar = superGrammar;\n    this.name = name;\n    this.body = body;\n  }\n}\n\n// Splice is an implementation detail of rule overriding with the `...` operator.\nclass Splice extends Alt {\n  constructor(superGrammar, ruleName, beforeTerms, afterTerms) {\n    const origBody = superGrammar.rules[ruleName].body;\n    super([...beforeTerms, origBody, ...afterTerms]);\n\n    this.superGrammar = superGrammar;\n    this.ruleName = ruleName;\n    this.expansionPos = beforeTerms.length;\n  }\n}\n\n// Sequences\n\nclass Seq extends PExpr {\n  constructor(factors) {\n    super();\n    this.factors = factors;\n  }\n}\n\n// Iterators and optionals\n\nclass Iter extends PExpr {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n}\n\nclass Star extends Iter {}\nclass Plus extends Iter {}\nclass Opt extends Iter {}\n\nStar.prototype.operator = '*';\nPlus.prototype.operator = '+';\nOpt.prototype.operator = '?';\n\nStar.prototype.minNumMatches = 0;\nPlus.prototype.minNumMatches = 1;\nOpt.prototype.minNumMatches = 0;\n\nStar.prototype.maxNumMatches = Number.POSITIVE_INFINITY;\nPlus.prototype.maxNumMatches = Number.POSITIVE_INFINITY;\nOpt.prototype.maxNumMatches = 1;\n\n// Predicates\n\nclass Not extends PExpr {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n}\n\nclass Lookahead extends PExpr {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n}\n\n// \"Lexification\"\n\nclass Lex extends PExpr {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n}\n\n// Rule application\n\nclass Apply extends PExpr {\n  constructor(ruleName, args = []) {\n    super();\n    this.ruleName = ruleName;\n    this.args = args;\n  }\n\n  isSyntactic() {\n    return isSyntactic(this.ruleName);\n  }\n\n  // This method just caches the result of `this.toString()` in a non-enumerable property.\n  toMemoKey() {\n    if (!this._memoKey) {\n      Object.defineProperty(this, '_memoKey', {value: this.toString()});\n    }\n    return this._memoKey;\n  }\n}\n\n// Unicode character\n\nclass UnicodeChar extends PExpr {\n  constructor(category) {\n    super();\n    this.category = category;\n    this.pattern = UnicodeCategories[category];\n  }\n}\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction createError(message, optInterval) {\n  let e;\n  if (optInterval) {\n    e = new Error(optInterval.getLineAndColumnMessage() + message);\n    e.shortMessage = message;\n    e.interval = optInterval;\n  } else {\n    e = new Error(message);\n  }\n  return e;\n}\n\n// ----------------- errors about intervals -----------------\n\nfunction intervalSourcesDontMatch() {\n  return createError(\"Interval sources don't match\");\n}\n\n// ----------------- errors about grammars -----------------\n\n// Grammar syntax error\n\nfunction grammarSyntaxError(matchFailure) {\n  const e = new Error();\n  Object.defineProperty(e, 'message', {\n    enumerable: true,\n    get() {\n      return matchFailure.message;\n    },\n  });\n  Object.defineProperty(e, 'shortMessage', {\n    enumerable: true,\n    get() {\n      return 'Expected ' + matchFailure.getExpectedText();\n    },\n  });\n  e.interval = matchFailure.getInterval();\n  return e;\n}\n\n// Undeclared grammar\n\nfunction undeclaredGrammar(grammarName, namespace, interval) {\n  const message = namespace ?\n    `Grammar ${grammarName} is not declared in namespace '${namespace}'` :\n    'Undeclared grammar ' + grammarName;\n  return createError(message, interval);\n}\n\n// Duplicate grammar declaration\n\nfunction duplicateGrammarDeclaration(grammar, namespace) {\n  return createError('Grammar ' + grammar.name + ' is already declared in this namespace');\n}\n\nfunction grammarDoesNotSupportIncrementalParsing(grammar) {\n  return createError(`Grammar '${grammar.name}' does not support incremental parsing`);\n}\n\n// ----------------- rules -----------------\n\n// Undeclared rule\n\nfunction undeclaredRule(ruleName, grammarName, optInterval) {\n  return createError(\n      'Rule ' + ruleName + ' is not declared in grammar ' + grammarName,\n      optInterval,\n  );\n}\n\n// Cannot override undeclared rule\n\nfunction cannotOverrideUndeclaredRule(ruleName, grammarName, optSource) {\n  return createError(\n      'Cannot override rule ' + ruleName + ' because it is not declared in ' + grammarName,\n      optSource,\n  );\n}\n\n// Cannot extend undeclared rule\n\nfunction cannotExtendUndeclaredRule(ruleName, grammarName, optSource) {\n  return createError(\n      'Cannot extend rule ' + ruleName + ' because it is not declared in ' + grammarName,\n      optSource,\n  );\n}\n\n// Duplicate rule declaration\n\nfunction duplicateRuleDeclaration(ruleName, grammarName, declGrammarName, optSource) {\n  let message =\n    \"Duplicate declaration for rule '\" + ruleName + \"' in grammar '\" + grammarName + \"'\";\n  if (grammarName !== declGrammarName) {\n    message += \" (originally declared in '\" + declGrammarName + \"')\";\n  }\n  return createError(message, optSource);\n}\n\n// Wrong number of parameters\n\nfunction wrongNumberOfParameters(ruleName, expected, actual, source) {\n  return createError(\n      'Wrong number of parameters for rule ' +\n      ruleName +\n      ' (expected ' +\n      expected +\n      ', got ' +\n      actual +\n      ')',\n      source,\n  );\n}\n\n// Wrong number of arguments\n\nfunction wrongNumberOfArguments(ruleName, expected, actual, expr) {\n  return createError(\n      'Wrong number of arguments for rule ' +\n      ruleName +\n      ' (expected ' +\n      expected +\n      ', got ' +\n      actual +\n      ')',\n      expr,\n  );\n}\n\n// Duplicate parameter names\n\nfunction duplicateParameterNames(ruleName, duplicates, source) {\n  return createError(\n      'Duplicate parameter names in rule ' + ruleName + ': ' + duplicates.join(', '),\n      source,\n  );\n}\n\n// Invalid parameter expression\n\nfunction invalidParameter(ruleName, expr) {\n  return createError(\n      'Invalid parameter to rule ' +\n      ruleName +\n      ': ' +\n      expr +\n      ' has arity ' +\n      expr.getArity() +\n      ', but parameter expressions must have arity 1',\n      expr.source,\n  );\n}\n\n// Application of syntactic rule from lexical rule\n\nconst syntacticVsLexicalNote =\n  'NOTE: A _syntactic rule_ is a rule whose name begins with a capital letter. ' +\n  'See https://ohmjs.org/d/svl for more details.';\n\nfunction applicationOfSyntacticRuleFromLexicalContext(ruleName, applyExpr) {\n  return createError(\n      'Cannot apply syntactic rule ' + ruleName + ' from here (inside a lexical context)',\n      applyExpr.source,\n  );\n}\n\n// Lexical rule application used with applySyntactic\n\nfunction applySyntacticWithLexicalRuleApplication(applyExpr) {\n  const {ruleName} = applyExpr;\n  return createError(\n      `applySyntactic is for syntactic rules, but '${ruleName}' is a lexical rule. ` +\n      syntacticVsLexicalNote,\n      applyExpr.source,\n  );\n}\n\n// Application of applySyntactic in a syntactic context\n\nfunction unnecessaryExperimentalApplySyntactic(applyExpr) {\n  return createError(\n      'applySyntactic is not required here (in a syntactic context)',\n      applyExpr.source,\n  );\n}\n\n// Incorrect argument type\n\nfunction incorrectArgumentType(expectedType, expr) {\n  return createError('Incorrect argument type: expected ' + expectedType, expr.source);\n}\n\n// Multiple instances of the super-splice operator (`...`) in the rule body.\n\nfunction multipleSuperSplices(expr) {\n  return createError(\"'...' can appear at most once in a rule body\", expr.source);\n}\n\n// Unicode code point escapes\n\nfunction invalidCodePoint(applyWrapper) {\n  const node = applyWrapper._node;\n  assert(node && node.isNonterminal() && node.ctorName === 'escapeChar_unicodeCodePoint');\n\n  // Get an interval that covers all of the hex digits.\n  const digitIntervals = applyWrapper.children.slice(1, -1).map(d => d.source);\n  const fullInterval = digitIntervals[0].coverageWith(...digitIntervals.slice(1));\n  return createError(\n      `U+${fullInterval.contents} is not a valid Unicode code point`,\n      fullInterval,\n  );\n}\n\n// ----------------- Kleene operators -----------------\n\nfunction kleeneExprHasNullableOperand(kleeneExpr, applicationStack) {\n  const actuals =\n    applicationStack.length > 0 ? applicationStack[applicationStack.length - 1].args : [];\n  const expr = kleeneExpr.expr.substituteParams(actuals);\n  let message =\n    'Nullable expression ' +\n    expr +\n    \" is not allowed inside '\" +\n    kleeneExpr.operator +\n    \"' (possible infinite loop)\";\n  if (applicationStack.length > 0) {\n    const stackTrace = applicationStack\n        .map(app => new Apply(app.ruleName, app.args))\n        .join('\\n');\n    message += '\\nApplication stack (most recent application last):\\n' + stackTrace;\n  }\n  return createError(message, kleeneExpr.expr.source);\n}\n\n// ----------------- arity -----------------\n\nfunction inconsistentArity(ruleName, expected, actual, expr) {\n  return createError(\n      'Rule ' +\n      ruleName +\n      ' involves an alternation which has inconsistent arity ' +\n      '(expected ' +\n      expected +\n      ', got ' +\n      actual +\n      ')',\n      expr.source,\n  );\n}\n\n// ----------------- convenience -----------------\n\nfunction multipleErrors(errors) {\n  const messages = errors.map(e => e.message);\n  return createError(['Errors:'].concat(messages).join('\\n- '), errors[0].interval);\n}\n\n// ----------------- semantic -----------------\n\nfunction missingSemanticAction(ctorName, name, type, stack) {\n  let stackTrace = stack\n      .slice(0, -1)\n      .map(info => {\n        const ans = '  ' + info[0].name + ' > ' + info[1];\n        return info.length === 3 ? ans + \" for '\" + info[2] + \"'\" : ans;\n      })\n      .join('\\n');\n  stackTrace += '\\n  ' + name + ' > ' + ctorName;\n\n  let moreInfo = '';\n  if (ctorName === '_iter') {\n    moreInfo = [\n      '\\nNOTE: as of Ohm v16, there is no default action for iteration nodes  see ',\n      '  https://ohmjs.org/d/dsa for details.',\n    ].join('\\n');\n  }\n\n  const message = [\n    `Missing semantic action for '${ctorName}' in ${type} '${name}'.${moreInfo}`,\n    'Action stack (most recent call last):',\n    stackTrace,\n  ].join('\\n');\n\n  const e = createError(message);\n  e.name = 'missingSemanticAction';\n  return e;\n}\n\nfunction throwErrors(errors) {\n  if (errors.length === 1) {\n    throw errors[0];\n  }\n  if (errors.length > 1) {\n    throw multipleErrors(errors);\n  }\n}\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n// Given an array of numbers `arr`, return an array of the numbers as strings,\n// right-justified and padded to the same length.\nfunction padNumbersToEqualLength(arr) {\n  let maxLen = 0;\n  const strings = arr.map(n => {\n    const str = n.toString();\n    maxLen = Math.max(maxLen, str.length);\n    return str;\n  });\n  return strings.map(s => padLeft(s, maxLen));\n}\n\n// Produce a new string that would be the result of copying the contents\n// of the string `src` onto `dest` at offset `offest`.\nfunction strcpy(dest, src, offset) {\n  const origDestLen = dest.length;\n  const start = dest.slice(0, offset);\n  const end = dest.slice(offset + src.length);\n  return (start + src + end).substr(0, origDestLen);\n}\n\n// Casts the underlying lineAndCol object to a formatted message string,\n// highlighting `ranges`.\nfunction lineAndColumnToMessage(...ranges) {\n  const lineAndCol = this;\n  const {offset} = lineAndCol;\n  const {repeatStr} = common;\n\n  const sb = new StringBuffer();\n  sb.append('Line ' + lineAndCol.lineNum + ', col ' + lineAndCol.colNum + ':\\n');\n\n  // An array of the previous, current, and next line numbers as strings of equal length.\n  const lineNumbers = padNumbersToEqualLength([\n    lineAndCol.prevLine == null ? 0 : lineAndCol.lineNum - 1,\n    lineAndCol.lineNum,\n    lineAndCol.nextLine == null ? 0 : lineAndCol.lineNum + 1,\n  ]);\n\n  // Helper for appending formatting input lines to the buffer.\n  const appendLine = (num, content, prefix) => {\n    sb.append(prefix + lineNumbers[num] + ' | ' + content + '\\n');\n  };\n\n  // Include the previous line for context if possible.\n  if (lineAndCol.prevLine != null) {\n    appendLine(0, lineAndCol.prevLine, '  ');\n  }\n  // Line that the error occurred on.\n  appendLine(1, lineAndCol.line, '> ');\n\n  // Build up the line that points to the offset and possible indicates one or more ranges.\n  // Start with a blank line, and indicate each range by overlaying a string of `~` chars.\n  const lineLen = lineAndCol.line.length;\n  let indicationLine = repeatStr(' ', lineLen + 1);\n  for (let i = 0; i < ranges.length; ++i) {\n    let startIdx = ranges[i][0];\n    let endIdx = ranges[i][1];\n    assert(startIdx >= 0 && startIdx <= endIdx, 'range start must be >= 0 and <= end');\n\n    const lineStartOffset = offset - lineAndCol.colNum + 1;\n    startIdx = Math.max(0, startIdx - lineStartOffset);\n    endIdx = Math.min(endIdx - lineStartOffset, lineLen);\n\n    indicationLine = strcpy(indicationLine, repeatStr('~', endIdx - startIdx), startIdx);\n  }\n  const gutterWidth = 2 + lineNumbers[1].length + 3;\n  sb.append(repeatStr(' ', gutterWidth));\n  indicationLine = strcpy(indicationLine, '^', lineAndCol.colNum - 1);\n  sb.append(indicationLine.replace(/ +$/, '') + '\\n');\n\n  // Include the next line for context if possible.\n  if (lineAndCol.nextLine != null) {\n    appendLine(2, lineAndCol.nextLine, '  ');\n  }\n  return sb.contents();\n}\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nlet builtInRulesCallbacks = [];\n\n// Since Grammar.BuiltInRules is bootstrapped, most of Ohm can't directly depend it.\n// This function allows modules that do depend on the built-in rules to register a callback\n// that will be called later in the initialization process.\nfunction awaitBuiltInRules(cb) {\n  builtInRulesCallbacks.push(cb);\n}\n\nfunction announceBuiltInRules(grammar) {\n  builtInRulesCallbacks.forEach(cb => {\n    cb(grammar);\n  });\n  builtInRulesCallbacks = null;\n}\n\n// Return an object with the line and column information for the given\n// offset in `str`.\nfunction getLineAndColumn(str, offset) {\n  let lineNum = 1;\n  let colNum = 1;\n\n  let currOffset = 0;\n  let lineStartOffset = 0;\n\n  let nextLine = null;\n  let prevLine = null;\n  let prevLineStartOffset = -1;\n\n  while (currOffset < offset) {\n    const c = str.charAt(currOffset++);\n    if (c === '\\n') {\n      lineNum++;\n      colNum = 1;\n      prevLineStartOffset = lineStartOffset;\n      lineStartOffset = currOffset;\n    } else if (c !== '\\r') {\n      colNum++;\n    }\n  }\n\n  // Find the end of the target line.\n  let lineEndOffset = str.indexOf('\\n', lineStartOffset);\n  if (lineEndOffset === -1) {\n    lineEndOffset = str.length;\n  } else {\n    // Get the next line.\n    const nextLineEndOffset = str.indexOf('\\n', lineEndOffset + 1);\n    nextLine =\n      nextLineEndOffset === -1 ?\n        str.slice(lineEndOffset) :\n        str.slice(lineEndOffset, nextLineEndOffset);\n    // Strip leading and trailing EOL char(s).\n    nextLine = nextLine.replace(/^\\r?\\n/, '').replace(/\\r$/, '');\n  }\n\n  // Get the previous line.\n  if (prevLineStartOffset >= 0) {\n    // Strip trailing EOL char(s).\n    prevLine = str.slice(prevLineStartOffset, lineStartOffset).replace(/\\r?\\n$/, '');\n  }\n\n  // Get the target line, stripping a trailing carriage return if necessary.\n  const line = str.slice(lineStartOffset, lineEndOffset).replace(/\\r$/, '');\n\n  return {\n    offset,\n    lineNum,\n    colNum,\n    line,\n    prevLine,\n    nextLine,\n    toString: lineAndColumnToMessage,\n  };\n}\n\n// Return a nicely-formatted string describing the line and column for the\n// given offset in `str` highlighting `ranges`.\nfunction getLineAndColumnMessage(str, offset, ...ranges) {\n  return getLineAndColumn(str, offset).toString(...ranges);\n}\n\nconst uniqueId = (() => {\n  let idCounter = 0;\n  return prefix => '' + prefix + idCounter++;\n})();\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nclass Interval {\n  constructor(sourceString, startIdx, endIdx) {\n    this.sourceString = sourceString;\n    this.startIdx = startIdx;\n    this.endIdx = endIdx;\n  }\n\n  get contents() {\n    if (this._contents === undefined) {\n      this._contents = this.sourceString.slice(this.startIdx, this.endIdx);\n    }\n    return this._contents;\n  }\n\n  get length() {\n    return this.endIdx - this.startIdx;\n  }\n\n  coverageWith(...intervals) {\n    return Interval.coverage(...intervals, this);\n  }\n\n  collapsedLeft() {\n    return new Interval(this.sourceString, this.startIdx, this.startIdx);\n  }\n\n  collapsedRight() {\n    return new Interval(this.sourceString, this.endIdx, this.endIdx);\n  }\n\n  getLineAndColumn() {\n    return getLineAndColumn(this.sourceString, this.startIdx);\n  }\n\n  getLineAndColumnMessage() {\n    const range = [this.startIdx, this.endIdx];\n    return getLineAndColumnMessage(this.sourceString, this.startIdx, range);\n  }\n\n  // Returns an array of 0, 1, or 2 intervals that represents the result of the\n  // interval difference operation.\n  minus(that) {\n    if (this.sourceString !== that.sourceString) {\n      throw intervalSourcesDontMatch();\n    } else if (this.startIdx === that.startIdx && this.endIdx === that.endIdx) {\n      // `this` and `that` are the same interval!\n      return [];\n    } else if (this.startIdx < that.startIdx && that.endIdx < this.endIdx) {\n      // `that` splits `this` into two intervals\n      return [\n        new Interval(this.sourceString, this.startIdx, that.startIdx),\n        new Interval(this.sourceString, that.endIdx, this.endIdx),\n      ];\n    } else if (this.startIdx < that.endIdx && that.endIdx < this.endIdx) {\n      // `that` contains a prefix of `this`\n      return [new Interval(this.sourceString, that.endIdx, this.endIdx)];\n    } else if (this.startIdx < that.startIdx && that.startIdx < this.endIdx) {\n      // `that` contains a suffix of `this`\n      return [new Interval(this.sourceString, this.startIdx, that.startIdx)];\n    } else {\n      // `that` and `this` do not overlap\n      return [this];\n    }\n  }\n\n  // Returns a new Interval that has the same extent as this one, but which is relative\n  // to `that`, an Interval that fully covers this one.\n  relativeTo(that) {\n    if (this.sourceString !== that.sourceString) {\n      throw intervalSourcesDontMatch();\n    }\n    assert(\n        this.startIdx >= that.startIdx && this.endIdx <= that.endIdx,\n        'other interval does not cover this one',\n    );\n    return new Interval(\n        this.sourceString,\n        this.startIdx - that.startIdx,\n        this.endIdx - that.startIdx,\n    );\n  }\n\n  // Returns a new Interval which contains the same contents as this one,\n  // but with whitespace trimmed from both ends.\n  trimmed() {\n    const {contents} = this;\n    const startIdx = this.startIdx + contents.match(/^\\s*/)[0].length;\n    const endIdx = this.endIdx - contents.match(/\\s*$/)[0].length;\n    return new Interval(this.sourceString, startIdx, endIdx);\n  }\n\n  subInterval(offset, len) {\n    const newStartIdx = this.startIdx + offset;\n    return new Interval(this.sourceString, newStartIdx, newStartIdx + len);\n  }\n}\n\nInterval.coverage = function(firstInterval, ...intervals) {\n  let {startIdx, endIdx} = firstInterval;\n  for (const interval of intervals) {\n    if (interval.sourceString !== firstInterval.sourceString) {\n      throw intervalSourcesDontMatch();\n    } else {\n      startIdx = Math.min(startIdx, interval.startIdx);\n      endIdx = Math.max(endIdx, interval.endIdx);\n    }\n  }\n  return new Interval(firstInterval.sourceString, startIdx, endIdx);\n};\n\nconst MAX_CHAR_CODE = 0xffff;\n\nclass InputStream {\n  constructor(source) {\n    this.source = source;\n    this.pos = 0;\n    this.examinedLength = 0;\n  }\n\n  atEnd() {\n    const ans = this.pos >= this.source.length;\n    this.examinedLength = Math.max(this.examinedLength, this.pos + 1);\n    return ans;\n  }\n\n  next() {\n    const ans = this.source[this.pos++];\n    this.examinedLength = Math.max(this.examinedLength, this.pos);\n    return ans;\n  }\n\n  nextCharCode() {\n    const nextChar = this.next();\n    return nextChar && nextChar.charCodeAt(0);\n  }\n\n  nextCodePoint() {\n    const cp = this.source.slice(this.pos++).codePointAt(0);\n    // If the code point is beyond plane 0, it takes up two characters.\n    if (cp > MAX_CHAR_CODE) {\n      this.pos += 1;\n    }\n    this.examinedLength = Math.max(this.examinedLength, this.pos);\n    return cp;\n  }\n\n  matchString(s, optIgnoreCase) {\n    let idx;\n    if (optIgnoreCase) {\n      /*\n        Case-insensitive comparison is a tricky business. Some notable gotchas include the\n        \"Turkish I\" problem (http://www.i18nguy.com/unicode/turkish-i18n.html) and the fact\n        that the German Esszet () turns into \"SS\" in upper case.\n\n        This is intended to be a locale-invariant comparison, which means it may not obey\n        locale-specific expectations (e.g. \"i\" => \"\").\n       */\n      for (idx = 0; idx < s.length; idx++) {\n        const actual = this.next();\n        const expected = s[idx];\n        if (actual == null || actual.toUpperCase() !== expected.toUpperCase()) {\n          return false;\n        }\n      }\n      return true;\n    }\n    // Default is case-sensitive comparison.\n    for (idx = 0; idx < s.length; idx++) {\n      if (this.next() !== s[idx]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  sourceSlice(startIdx, endIdx) {\n    return this.source.slice(startIdx, endIdx);\n  }\n\n  interval(startIdx, optEndIdx) {\n    return new Interval(this.source, startIdx, optEndIdx ? optEndIdx : this.pos);\n  }\n}\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nclass MatchResult {\n  constructor(\n      matcher,\n      input,\n      startExpr,\n      cst,\n      cstOffset,\n      rightmostFailurePosition,\n      optRecordedFailures,\n  ) {\n    this.matcher = matcher;\n    this.input = input;\n    this.startExpr = startExpr;\n    this._cst = cst;\n    this._cstOffset = cstOffset;\n    this._rightmostFailurePosition = rightmostFailurePosition;\n    this._rightmostFailures = optRecordedFailures;\n\n    if (this.failed()) {\n      /* eslint-disable no-invalid-this */\n      defineLazyProperty(this, 'message', function() {\n        const detail = 'Expected ' + this.getExpectedText();\n        return (\n          getLineAndColumnMessage(this.input, this.getRightmostFailurePosition()) + detail\n        );\n      });\n      defineLazyProperty(this, 'shortMessage', function() {\n        const detail = 'expected ' + this.getExpectedText();\n        const errorInfo = getLineAndColumn(\n            this.input,\n            this.getRightmostFailurePosition(),\n        );\n        return 'Line ' + errorInfo.lineNum + ', col ' + errorInfo.colNum + ': ' + detail;\n      });\n      /* eslint-enable no-invalid-this */\n    }\n  }\n\n  succeeded() {\n    return !!this._cst;\n  }\n\n  failed() {\n    return !this.succeeded();\n  }\n\n  getRightmostFailurePosition() {\n    return this._rightmostFailurePosition;\n  }\n\n  getRightmostFailures() {\n    if (!this._rightmostFailures) {\n      this.matcher.setInput(this.input);\n      const matchResultWithFailures = this.matcher._match(this.startExpr, {\n        tracing: false,\n        positionToRecordFailures: this.getRightmostFailurePosition(),\n      });\n      this._rightmostFailures = matchResultWithFailures.getRightmostFailures();\n    }\n    return this._rightmostFailures;\n  }\n\n  toString() {\n    return this.succeeded() ?\n      '[match succeeded]' :\n      '[match failed at position ' + this.getRightmostFailurePosition() + ']';\n  }\n\n  // Return a string summarizing the expected contents of the input stream when\n  // the match failure occurred.\n  getExpectedText() {\n    if (this.succeeded()) {\n      throw new Error('cannot get expected text of a successful MatchResult');\n    }\n\n    const sb = new StringBuffer();\n    let failures = this.getRightmostFailures();\n\n    // Filter out the fluffy failures to make the default error messages more useful\n    failures = failures.filter(failure => !failure.isFluffy());\n\n    for (let idx = 0; idx < failures.length; idx++) {\n      if (idx > 0) {\n        if (idx === failures.length - 1) {\n          sb.append(failures.length > 2 ? ', or ' : ' or ');\n        } else {\n          sb.append(', ');\n        }\n      }\n      sb.append(failures[idx].toString());\n    }\n    return sb.contents();\n  }\n\n  getInterval() {\n    const pos = this.getRightmostFailurePosition();\n    return new Interval(this.input, pos, pos);\n  }\n}\n\nclass PosInfo {\n  constructor() {\n    this.applicationMemoKeyStack = []; // active applications at this position\n    this.memo = {};\n    this.maxExaminedLength = 0;\n    this.maxRightmostFailureOffset = -1;\n    this.currentLeftRecursion = undefined;\n  }\n\n  isActive(application) {\n    return this.applicationMemoKeyStack.indexOf(application.toMemoKey()) >= 0;\n  }\n\n  enter(application) {\n    this.applicationMemoKeyStack.push(application.toMemoKey());\n  }\n\n  exit() {\n    this.applicationMemoKeyStack.pop();\n  }\n\n  startLeftRecursion(headApplication, memoRec) {\n    memoRec.isLeftRecursion = true;\n    memoRec.headApplication = headApplication;\n    memoRec.nextLeftRecursion = this.currentLeftRecursion;\n    this.currentLeftRecursion = memoRec;\n\n    const {applicationMemoKeyStack} = this;\n    const indexOfFirstInvolvedRule =\n      applicationMemoKeyStack.indexOf(headApplication.toMemoKey()) + 1;\n    const involvedApplicationMemoKeys = applicationMemoKeyStack.slice(\n        indexOfFirstInvolvedRule,\n    );\n\n    memoRec.isInvolved = function(applicationMemoKey) {\n      return involvedApplicationMemoKeys.indexOf(applicationMemoKey) >= 0;\n    };\n\n    memoRec.updateInvolvedApplicationMemoKeys = function() {\n      for (let idx = indexOfFirstInvolvedRule; idx < applicationMemoKeyStack.length; idx++) {\n        const applicationMemoKey = applicationMemoKeyStack[idx];\n        if (!this.isInvolved(applicationMemoKey)) {\n          involvedApplicationMemoKeys.push(applicationMemoKey);\n        }\n      }\n    };\n  }\n\n  endLeftRecursion() {\n    this.currentLeftRecursion = this.currentLeftRecursion.nextLeftRecursion;\n  }\n\n  // Note: this method doesn't get called for the \"head\" of a left recursion -- for LR heads,\n  // the memoized result (which starts out being a failure) is always used.\n  shouldUseMemoizedResult(memoRec) {\n    if (!memoRec.isLeftRecursion) {\n      return true;\n    }\n    const {applicationMemoKeyStack} = this;\n    for (let idx = 0; idx < applicationMemoKeyStack.length; idx++) {\n      const applicationMemoKey = applicationMemoKeyStack[idx];\n      if (memoRec.isInvolved(applicationMemoKey)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  memoize(memoKey, memoRec) {\n    this.memo[memoKey] = memoRec;\n    this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);\n    this.maxRightmostFailureOffset = Math.max(\n        this.maxRightmostFailureOffset,\n        memoRec.rightmostFailureOffset,\n    );\n    return memoRec;\n  }\n\n  clearObsoleteEntries(pos, invalidatedIdx) {\n    if (pos + this.maxExaminedLength <= invalidatedIdx) {\n      // Optimization: none of the rule applications that were memoized here examined the\n      // interval of the input that changed, so nothing has to be invalidated.\n      return;\n    }\n\n    const {memo} = this;\n    this.maxExaminedLength = 0;\n    this.maxRightmostFailureOffset = -1;\n    Object.keys(memo).forEach(k => {\n      const memoRec = memo[k];\n      if (pos + memoRec.examinedLength > invalidatedIdx) {\n        delete memo[k];\n      } else {\n        this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);\n        this.maxRightmostFailureOffset = Math.max(\n            this.maxRightmostFailureOffset,\n            memoRec.rightmostFailureOffset,\n        );\n      }\n    });\n  }\n}\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n// Unicode characters that are used in the `toString` output.\nconst BALLOT_X = '\\u2717';\nconst CHECK_MARK = '\\u2713';\nconst DOT_OPERATOR = '\\u22C5';\nconst RIGHTWARDS_DOUBLE_ARROW = '\\u21D2';\nconst SYMBOL_FOR_HORIZONTAL_TABULATION = '\\u2409';\nconst SYMBOL_FOR_LINE_FEED = '\\u240A';\nconst SYMBOL_FOR_CARRIAGE_RETURN = '\\u240D';\n\nconst Flags = {\n  succeeded: 1 << 0,\n  isRootNode: 1 << 1,\n  isImplicitSpaces: 1 << 2,\n  isMemoized: 1 << 3,\n  isHeadOfLeftRecursion: 1 << 4,\n  terminatesLR: 1 << 5,\n};\n\nfunction spaces(n) {\n  return repeat(' ', n).join('');\n}\n\n// Return a string representation of a portion of `input` at offset `pos`.\n// The result will contain exactly `len` characters.\nfunction getInputExcerpt(input, pos, len) {\n  const excerpt = asEscapedString(input.slice(pos, pos + len));\n\n  // Pad the output if necessary.\n  if (excerpt.length < len) {\n    return excerpt + repeat(' ', len - excerpt.length).join('');\n  }\n  return excerpt;\n}\n\nfunction asEscapedString(obj) {\n  if (typeof obj === 'string') {\n    // Replace non-printable characters with visible symbols.\n    return obj\n        .replace(/ /g, DOT_OPERATOR)\n        .replace(/\\t/g, SYMBOL_FOR_HORIZONTAL_TABULATION)\n        .replace(/\\n/g, SYMBOL_FOR_LINE_FEED)\n        .replace(/\\r/g, SYMBOL_FOR_CARRIAGE_RETURN);\n  }\n  return String(obj);\n}\n\n// ----------------- Trace -----------------\n\nclass Trace {\n  constructor(input, pos1, pos2, expr, succeeded, bindings, optChildren) {\n    this.input = input;\n    this.pos = this.pos1 = pos1;\n    this.pos2 = pos2;\n    this.source = new Interval(input, pos1, pos2);\n    this.expr = expr;\n    this.bindings = bindings;\n    this.children = optChildren || [];\n    this.terminatingLREntry = null;\n\n    this._flags = succeeded ? Flags.succeeded : 0;\n  }\n\n  get displayString() {\n    return this.expr.toDisplayString();\n  }\n\n  clone() {\n    return this.cloneWithExpr(this.expr);\n  }\n\n  cloneWithExpr(expr) {\n    const ans = new Trace(\n        this.input,\n        this.pos,\n        this.pos2,\n        expr,\n        this.succeeded,\n        this.bindings,\n        this.children,\n    );\n\n    ans.isHeadOfLeftRecursion = this.isHeadOfLeftRecursion;\n    ans.isImplicitSpaces = this.isImplicitSpaces;\n    ans.isMemoized = this.isMemoized;\n    ans.isRootNode = this.isRootNode;\n    ans.terminatesLR = this.terminatesLR;\n    ans.terminatingLREntry = this.terminatingLREntry;\n    return ans;\n  }\n\n  // Record the trace information for the terminating condition of the LR loop.\n  recordLRTermination(ruleBodyTrace, value) {\n    this.terminatingLREntry = new Trace(\n        this.input,\n        this.pos,\n        this.pos2,\n        this.expr,\n        false,\n        [value],\n        [ruleBodyTrace],\n    );\n    this.terminatingLREntry.terminatesLR = true;\n  }\n\n  // Recursively traverse this trace node and all its descendents, calling a visitor function\n  // for each node that is visited. If `vistorObjOrFn` is an object, then its 'enter' property\n  // is a function to call before visiting the children of a node, and its 'exit' property is\n  // a function to call afterwards. If `visitorObjOrFn` is a function, it represents the 'enter'\n  // function.\n  //\n  // The functions are called with three arguments: the Trace node, its parent Trace, and a number\n  // representing the depth of the node in the tree. (The root node has depth 0.) `optThisArg`, if\n  // specified, is the value to use for `this` when executing the visitor functions.\n  walk(visitorObjOrFn, optThisArg) {\n    let visitor = visitorObjOrFn;\n    if (typeof visitor === 'function') {\n      visitor = {enter: visitor};\n    }\n\n    function _walk(node, parent, depth) {\n      let recurse = true;\n      if (visitor.enter) {\n        if (visitor.enter.call(optThisArg, node, parent, depth) === Trace.prototype.SKIP) {\n          recurse = false;\n        }\n      }\n      if (recurse) {\n        node.children.forEach(child => {\n          _walk(child, node, depth + 1);\n        });\n        if (visitor.exit) {\n          visitor.exit.call(optThisArg, node, parent, depth);\n        }\n      }\n    }\n    if (this.isRootNode) {\n      // Don't visit the root node itself, only its children.\n      this.children.forEach(c => {\n        _walk(c, null, 0);\n      });\n    } else {\n      _walk(this, null, 0);\n    }\n  }\n\n  // Return a string representation of the trace.\n  // Sample:\n  //     12+2*3  exp   \"12\"\n  //     12+2*3    addExp (LR)   \"12\"\n  //     12+2*3        addExp_plus\n  toString() {\n    const sb = new StringBuffer();\n    this.walk((node, parent, depth) => {\n      if (!node) {\n        return this.SKIP;\n      }\n      const ctorName = node.expr.constructor.name;\n      // Don't print anything for Alt nodes.\n      if (ctorName === 'Alt') {\n        return; // eslint-disable-line consistent-return\n      }\n      sb.append(getInputExcerpt(node.input, node.pos, 10) + spaces(depth * 2 + 1));\n      sb.append((node.succeeded ? CHECK_MARK : BALLOT_X) + ' ' + node.displayString);\n      if (node.isHeadOfLeftRecursion) {\n        sb.append(' (LR)');\n      }\n      if (node.succeeded) {\n        const contents = asEscapedString(node.source.contents);\n        sb.append(' ' + RIGHTWARDS_DOUBLE_ARROW + '  ');\n        sb.append(typeof contents === 'string' ? '\"' + contents + '\"' : contents);\n      }\n      sb.append('\\n');\n    });\n    return sb.contents();\n  }\n}\n\n// A value that can be returned from visitor functions to indicate that a\n// node should not be recursed into.\nTrace.prototype.SKIP = {};\n\n// For convenience, create a getter and setter for the boolean flags in `Flags`.\nObject.keys(Flags).forEach(name => {\n  const mask = Flags[name];\n  Object.defineProperty(Trace.prototype, name, {\n    get() {\n      return (this._flags & mask) !== 0;\n    },\n    set(val) {\n      if (val) {\n        this._flags |= mask;\n      } else {\n        this._flags &= ~mask;\n      }\n    },\n  });\n});\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  Return true if we should skip spaces preceding this expression in a syntactic context.\n*/\nPExpr.prototype.allowsSkippingPrecedingSpace = abstract('allowsSkippingPrecedingSpace');\n\n/*\n  Generally, these are all first-order expressions and (with the exception of Apply)\n  directly read from the input stream.\n*/\nany.allowsSkippingPrecedingSpace =\n  end.allowsSkippingPrecedingSpace =\n  Apply.prototype.allowsSkippingPrecedingSpace =\n  Terminal.prototype.allowsSkippingPrecedingSpace =\n  Range.prototype.allowsSkippingPrecedingSpace =\n  UnicodeChar.prototype.allowsSkippingPrecedingSpace =\n    function() {\n      return true;\n    };\n\n/*\n  Higher-order expressions that don't directly consume input.\n*/\nAlt.prototype.allowsSkippingPrecedingSpace =\n  Iter.prototype.allowsSkippingPrecedingSpace =\n  Lex.prototype.allowsSkippingPrecedingSpace =\n  Lookahead.prototype.allowsSkippingPrecedingSpace =\n  Not.prototype.allowsSkippingPrecedingSpace =\n  Param.prototype.allowsSkippingPrecedingSpace =\n  Seq.prototype.allowsSkippingPrecedingSpace =\n    function() {\n      return false;\n    };\n\nlet BuiltInRules;\n\nawaitBuiltInRules(g => {\n  BuiltInRules = g;\n});\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\nlet lexifyCount;\n\nPExpr.prototype.assertAllApplicationsAreValid = function(ruleName, grammar) {\n  lexifyCount = 0;\n  this._assertAllApplicationsAreValid(ruleName, grammar);\n};\n\nPExpr.prototype._assertAllApplicationsAreValid = abstract(\n    '_assertAllApplicationsAreValid',\n);\n\nany._assertAllApplicationsAreValid =\n  end._assertAllApplicationsAreValid =\n  Terminal.prototype._assertAllApplicationsAreValid =\n  Range.prototype._assertAllApplicationsAreValid =\n  Param.prototype._assertAllApplicationsAreValid =\n  UnicodeChar.prototype._assertAllApplicationsAreValid =\n    function(ruleName, grammar) {\n      // no-op\n    };\n\nLex.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {\n  lexifyCount++;\n  this.expr._assertAllApplicationsAreValid(ruleName, grammar);\n  lexifyCount--;\n};\n\nAlt.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {\n  for (let idx = 0; idx < this.terms.length; idx++) {\n    this.terms[idx]._assertAllApplicationsAreValid(ruleName, grammar);\n  }\n};\n\nSeq.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {\n  for (let idx = 0; idx < this.factors.length; idx++) {\n    this.factors[idx]._assertAllApplicationsAreValid(ruleName, grammar);\n  }\n};\n\nIter.prototype._assertAllApplicationsAreValid =\n  Not.prototype._assertAllApplicationsAreValid =\n  Lookahead.prototype._assertAllApplicationsAreValid =\n    function(ruleName, grammar) {\n      this.expr._assertAllApplicationsAreValid(ruleName, grammar);\n    };\n\nApply.prototype._assertAllApplicationsAreValid = function(\n    ruleName,\n    grammar,\n    skipSyntacticCheck = false,\n) {\n  const ruleInfo = grammar.rules[this.ruleName];\n  const isContextSyntactic = isSyntactic(ruleName) && lexifyCount === 0;\n\n  // Make sure that the rule exists...\n  if (!ruleInfo) {\n    throw undeclaredRule(this.ruleName, grammar.name, this.source);\n  }\n\n  // ...and that this application is allowed\n  if (!skipSyntacticCheck && isSyntactic(this.ruleName) && !isContextSyntactic) {\n    throw applicationOfSyntacticRuleFromLexicalContext(this.ruleName, this);\n  }\n\n  // ...and that this application has the correct number of arguments.\n  const actual = this.args.length;\n  const expected = ruleInfo.formals.length;\n  if (actual !== expected) {\n    throw wrongNumberOfArguments(this.ruleName, expected, actual, this.source);\n  }\n\n  const isBuiltInApplySyntactic =\n    BuiltInRules && ruleInfo === BuiltInRules.rules.applySyntactic;\n  const isBuiltInCaseInsensitive =\n    BuiltInRules && ruleInfo === BuiltInRules.rules.caseInsensitive;\n\n  // If it's an application of 'caseInsensitive', ensure that the argument is a Terminal.\n  if (isBuiltInCaseInsensitive) {\n    if (!(this.args[0] instanceof Terminal)) {\n      throw incorrectArgumentType('a Terminal (e.g. \"abc\")', this.args[0]);\n    }\n  }\n\n  if (isBuiltInApplySyntactic) {\n    const arg = this.args[0];\n    if (!(arg instanceof Apply)) {\n      throw incorrectArgumentType('a syntactic rule application', arg);\n    }\n    if (!isSyntactic(arg.ruleName)) {\n      throw applySyntacticWithLexicalRuleApplication(arg);\n    }\n    if (isContextSyntactic) {\n      throw unnecessaryExperimentalApplySyntactic(this);\n    }\n  }\n\n  // ...and that all of the argument expressions only have valid applications and have arity 1.\n  // If `this` is an application of the built-in applySyntactic rule, then its arg is\n  // allowed (and expected) to be a syntactic rule, even if we're in a lexical context.\n  this.args.forEach(arg => {\n    arg._assertAllApplicationsAreValid(ruleName, grammar, isBuiltInApplySyntactic);\n    if (arg.getArity() !== 1) {\n      throw invalidParameter(this.ruleName, arg);\n    }\n  });\n};\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\nPExpr.prototype.assertChoicesHaveUniformArity = abstract(\n    'assertChoicesHaveUniformArity',\n);\n\nany.assertChoicesHaveUniformArity =\n  end.assertChoicesHaveUniformArity =\n  Terminal.prototype.assertChoicesHaveUniformArity =\n  Range.prototype.assertChoicesHaveUniformArity =\n  Param.prototype.assertChoicesHaveUniformArity =\n  Lex.prototype.assertChoicesHaveUniformArity =\n  UnicodeChar.prototype.assertChoicesHaveUniformArity =\n    function(ruleName) {\n      // no-op\n    };\n\nAlt.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  if (this.terms.length === 0) {\n    return;\n  }\n  const arity = this.terms[0].getArity();\n  for (let idx = 0; idx < this.terms.length; idx++) {\n    const term = this.terms[idx];\n    term.assertChoicesHaveUniformArity();\n    const otherArity = term.getArity();\n    if (arity !== otherArity) {\n      throw inconsistentArity(ruleName, arity, otherArity, term);\n    }\n  }\n};\n\nExtend.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  // Extend is a special case of Alt that's guaranteed to have exactly two\n  // cases: [extensions, origBody].\n  const actualArity = this.terms[0].getArity();\n  const expectedArity = this.terms[1].getArity();\n  if (actualArity !== expectedArity) {\n    throw inconsistentArity(ruleName, expectedArity, actualArity, this.terms[0]);\n  }\n};\n\nSeq.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  for (let idx = 0; idx < this.factors.length; idx++) {\n    this.factors[idx].assertChoicesHaveUniformArity(ruleName);\n  }\n};\n\nIter.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  this.expr.assertChoicesHaveUniformArity(ruleName);\n};\n\nNot.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  // no-op (not required b/c the nested expr doesn't show up in the CST)\n};\n\nLookahead.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  this.expr.assertChoicesHaveUniformArity(ruleName);\n};\n\nApply.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  // The arities of the parameter expressions is required to be 1 by\n  // `assertAllApplicationsAreValid()`.\n};\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\nPExpr.prototype.assertIteratedExprsAreNotNullable = abstract(\n    'assertIteratedExprsAreNotNullable',\n);\n\nany.assertIteratedExprsAreNotNullable =\n  end.assertIteratedExprsAreNotNullable =\n  Terminal.prototype.assertIteratedExprsAreNotNullable =\n  Range.prototype.assertIteratedExprsAreNotNullable =\n  Param.prototype.assertIteratedExprsAreNotNullable =\n  UnicodeChar.prototype.assertIteratedExprsAreNotNullable =\n    function(grammar) {\n      // no-op\n    };\n\nAlt.prototype.assertIteratedExprsAreNotNullable = function(grammar) {\n  for (let idx = 0; idx < this.terms.length; idx++) {\n    this.terms[idx].assertIteratedExprsAreNotNullable(grammar);\n  }\n};\n\nSeq.prototype.assertIteratedExprsAreNotNullable = function(grammar) {\n  for (let idx = 0; idx < this.factors.length; idx++) {\n    this.factors[idx].assertIteratedExprsAreNotNullable(grammar);\n  }\n};\n\nIter.prototype.assertIteratedExprsAreNotNullable = function(grammar) {\n  // Note: this is the implementation of this method for `Star` and `Plus` expressions.\n  // It is overridden for `Opt` below.\n  this.expr.assertIteratedExprsAreNotNullable(grammar);\n  if (this.expr.isNullable(grammar)) {\n    throw kleeneExprHasNullableOperand(this, []);\n  }\n};\n\nOpt.prototype.assertIteratedExprsAreNotNullable =\n  Not.prototype.assertIteratedExprsAreNotNullable =\n  Lookahead.prototype.assertIteratedExprsAreNotNullable =\n  Lex.prototype.assertIteratedExprsAreNotNullable =\n    function(grammar) {\n      this.expr.assertIteratedExprsAreNotNullable(grammar);\n    };\n\nApply.prototype.assertIteratedExprsAreNotNullable = function(grammar) {\n  this.args.forEach(arg => {\n    arg.assertIteratedExprsAreNotNullable(grammar);\n  });\n};\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nclass Node {\n  constructor(matchLength) {\n    this.matchLength = matchLength;\n  }\n\n  get ctorName() {\n    throw new Error('subclass responsibility');\n  }\n\n  numChildren() {\n    return this.children ? this.children.length : 0;\n  }\n\n  childAt(idx) {\n    if (this.children) {\n      return this.children[idx];\n    }\n  }\n\n  indexOfChild(arg) {\n    return this.children.indexOf(arg);\n  }\n\n  hasChildren() {\n    return this.numChildren() > 0;\n  }\n\n  hasNoChildren() {\n    return !this.hasChildren();\n  }\n\n  onlyChild() {\n    if (this.numChildren() !== 1) {\n      throw new Error(\n          'cannot get only child of a node of type ' +\n          this.ctorName +\n          ' (it has ' +\n          this.numChildren() +\n          ' children)',\n      );\n    } else {\n      return this.firstChild();\n    }\n  }\n\n  firstChild() {\n    if (this.hasNoChildren()) {\n      throw new Error(\n          'cannot get first child of a ' + this.ctorName + ' node, which has no children',\n      );\n    } else {\n      return this.childAt(0);\n    }\n  }\n\n  lastChild() {\n    if (this.hasNoChildren()) {\n      throw new Error(\n          'cannot get last child of a ' + this.ctorName + ' node, which has no children',\n      );\n    } else {\n      return this.childAt(this.numChildren() - 1);\n    }\n  }\n\n  childBefore(child) {\n    const childIdx = this.indexOfChild(child);\n    if (childIdx < 0) {\n      throw new Error('Node.childBefore() called w/ an argument that is not a child');\n    } else if (childIdx === 0) {\n      throw new Error('cannot get child before first child');\n    } else {\n      return this.childAt(childIdx - 1);\n    }\n  }\n\n  childAfter(child) {\n    const childIdx = this.indexOfChild(child);\n    if (childIdx < 0) {\n      throw new Error('Node.childAfter() called w/ an argument that is not a child');\n    } else if (childIdx === this.numChildren() - 1) {\n      throw new Error('cannot get child after last child');\n    } else {\n      return this.childAt(childIdx + 1);\n    }\n  }\n\n  isTerminal() {\n    return false;\n  }\n\n  isNonterminal() {\n    return false;\n  }\n\n  isIteration() {\n    return false;\n  }\n\n  isOptional() {\n    return false;\n  }\n}\n\n// Terminals\n\nclass TerminalNode extends Node {\n  get ctorName() {\n    return '_terminal';\n  }\n\n  isTerminal() {\n    return true;\n  }\n\n  get primitiveValue() {\n    throw new Error('The `primitiveValue` property was removed in Ohm v17.');\n  }\n}\n\n// Nonterminals\n\nclass NonterminalNode extends Node {\n  constructor(ruleName, children, childOffsets, matchLength) {\n    super(matchLength);\n    this.ruleName = ruleName;\n    this.children = children;\n    this.childOffsets = childOffsets;\n  }\n\n  get ctorName() {\n    return this.ruleName;\n  }\n\n  isNonterminal() {\n    return true;\n  }\n\n  isLexical() {\n    return isLexical(this.ctorName);\n  }\n\n  isSyntactic() {\n    return isSyntactic(this.ctorName);\n  }\n}\n\n// Iterations\n\nclass IterationNode extends Node {\n  constructor(children, childOffsets, matchLength, isOptional) {\n    super(matchLength);\n    this.children = children;\n    this.childOffsets = childOffsets;\n    this.optional = isOptional;\n  }\n\n  get ctorName() {\n    return '_iter';\n  }\n\n  isIteration() {\n    return true;\n  }\n\n  isOptional() {\n    return this.optional;\n  }\n}\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  Evaluate the expression and return `true` if it succeeds, `false` otherwise. This method should\n  only be called directly by `State.prototype.eval(expr)`, which also updates the data structures\n  that are used for tracing. (Making those updates in a method of `State` enables the trace-specific\n  data structures to be \"secrets\" of that class, which is good for modularity.)\n\n  The contract of this method is as follows:\n  * When the return value is `true`,\n    - the state object will have `expr.getArity()` more bindings than it did before the call.\n  * When the return value is `false`,\n    - the state object may have more bindings than it did before the call, and\n    - its input stream's position may be anywhere.\n\n  Note that `State.prototype.eval(expr)`, unlike this method, guarantees that neither the state\n  object's bindings nor its input stream's position will change if the expression fails to match.\n*/\nPExpr.prototype.eval = abstract('eval'); // function(state) { ... }\n\nany.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  const cp = inputStream.nextCodePoint();\n  if (cp !== undefined) {\n    state.pushBinding(new TerminalNode(String.fromCodePoint(cp).length), origPos);\n    return true;\n  } else {\n    state.processFailure(origPos, this);\n    return false;\n  }\n};\n\nend.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  if (inputStream.atEnd()) {\n    state.pushBinding(new TerminalNode(0), origPos);\n    return true;\n  } else {\n    state.processFailure(origPos, this);\n    return false;\n  }\n};\n\nTerminal.prototype.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  if (!inputStream.matchString(this.obj)) {\n    state.processFailure(origPos, this);\n    return false;\n  } else {\n    state.pushBinding(new TerminalNode(this.obj.length), origPos);\n    return true;\n  }\n};\n\nRange.prototype.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n\n  // A range can operate in one of two modes: matching a single, 16-bit _code unit_,\n  // or matching a _code point_. (Code points over 0xFFFF take up two 16-bit code units.)\n  const cp = this.matchCodePoint ? inputStream.nextCodePoint() : inputStream.nextCharCode();\n\n  // Always compare by code point value to get the correct result in all scenarios.\n  // Note that for strings of length 1, codePointAt(0) and charPointAt(0) are equivalent.\n  if (cp !== undefined && this.from.codePointAt(0) <= cp && cp <= this.to.codePointAt(0)) {\n    state.pushBinding(new TerminalNode(String.fromCodePoint(cp).length), origPos);\n    return true;\n  } else {\n    state.processFailure(origPos, this);\n    return false;\n  }\n};\n\nParam.prototype.eval = function(state) {\n  return state.eval(state.currentApplication().args[this.index]);\n};\n\nLex.prototype.eval = function(state) {\n  state.enterLexifiedContext();\n  const ans = state.eval(this.expr);\n  state.exitLexifiedContext();\n  return ans;\n};\n\nAlt.prototype.eval = function(state) {\n  for (let idx = 0; idx < this.terms.length; idx++) {\n    if (state.eval(this.terms[idx])) {\n      return true;\n    }\n  }\n  return false;\n};\n\nSeq.prototype.eval = function(state) {\n  for (let idx = 0; idx < this.factors.length; idx++) {\n    const factor = this.factors[idx];\n    if (!state.eval(factor)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nIter.prototype.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  const arity = this.getArity();\n  const cols = [];\n  const colOffsets = [];\n  while (cols.length < arity) {\n    cols.push([]);\n    colOffsets.push([]);\n  }\n\n  let numMatches = 0;\n  let prevPos = origPos;\n  let idx;\n  while (numMatches < this.maxNumMatches && state.eval(this.expr)) {\n    if (inputStream.pos === prevPos) {\n      throw kleeneExprHasNullableOperand(this, state._applicationStack);\n    }\n    prevPos = inputStream.pos;\n    numMatches++;\n    const row = state._bindings.splice(state._bindings.length - arity, arity);\n    const rowOffsets = state._bindingOffsets.splice(\n        state._bindingOffsets.length - arity,\n        arity,\n    );\n    for (idx = 0; idx < row.length; idx++) {\n      cols[idx].push(row[idx]);\n      colOffsets[idx].push(rowOffsets[idx]);\n    }\n  }\n  if (numMatches < this.minNumMatches) {\n    return false;\n  }\n  let offset = state.posToOffset(origPos);\n  let matchLength = 0;\n  if (numMatches > 0) {\n    const lastCol = cols[arity - 1];\n    const lastColOffsets = colOffsets[arity - 1];\n\n    const endOffset =\n      lastColOffsets[lastColOffsets.length - 1] + lastCol[lastCol.length - 1].matchLength;\n    offset = colOffsets[0][0];\n    matchLength = endOffset - offset;\n  }\n  const isOptional = this instanceof Opt;\n  for (idx = 0; idx < cols.length; idx++) {\n    state._bindings.push(\n        new IterationNode(cols[idx], colOffsets[idx], matchLength, isOptional),\n    );\n    state._bindingOffsets.push(offset);\n  }\n  return true;\n};\n\nNot.prototype.eval = function(state) {\n  /*\n    TODO:\n    - Right now we're just throwing away all of the failures that happen inside a `not`, and\n      recording `this` as a failed expression.\n    - Double negation should be equivalent to lookahead, but that's not the case right now wrt\n      failures. E.g., ~~'foo' produces a failure for ~~'foo', but maybe it should produce\n      a failure for 'foo' instead.\n  */\n\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  state.pushFailuresInfo();\n\n  const ans = state.eval(this.expr);\n\n  state.popFailuresInfo();\n  if (ans) {\n    state.processFailure(origPos, this);\n    return false;\n  }\n\n  inputStream.pos = origPos;\n  return true;\n};\n\nLookahead.prototype.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  if (state.eval(this.expr)) {\n    inputStream.pos = origPos;\n    return true;\n  } else {\n    return false;\n  }\n};\n\nApply.prototype.eval = function(state) {\n  const caller = state.currentApplication();\n  const actuals = caller ? caller.args : [];\n  const app = this.substituteParams(actuals);\n\n  const posInfo = state.getCurrentPosInfo();\n  if (posInfo.isActive(app)) {\n    // This rule is already active at this position, i.e., it is left-recursive.\n    return app.handleCycle(state);\n  }\n\n  const memoKey = app.toMemoKey();\n  const memoRec = posInfo.memo[memoKey];\n\n  if (memoRec && posInfo.shouldUseMemoizedResult(memoRec)) {\n    if (state.hasNecessaryInfo(memoRec)) {\n      return state.useMemoizedResult(state.inputStream.pos, memoRec);\n    }\n    delete posInfo.memo[memoKey];\n  }\n  return app.reallyEval(state);\n};\n\nApply.prototype.handleCycle = function(state) {\n  const posInfo = state.getCurrentPosInfo();\n  const {currentLeftRecursion} = posInfo;\n  const memoKey = this.toMemoKey();\n  let memoRec = posInfo.memo[memoKey];\n\n  if (currentLeftRecursion && currentLeftRecursion.headApplication.toMemoKey() === memoKey) {\n    // We already know about this left recursion, but it's possible there are \"involved\n    // applications\" that we don't already know about, so...\n    memoRec.updateInvolvedApplicationMemoKeys();\n  } else if (!memoRec) {\n    // New left recursion detected! Memoize a failure to try to get a seed parse.\n    memoRec = posInfo.memoize(memoKey, {\n      matchLength: 0,\n      examinedLength: 0,\n      value: false,\n      rightmostFailureOffset: -1,\n    });\n    posInfo.startLeftRecursion(this, memoRec);\n  }\n  return state.useMemoizedResult(state.inputStream.pos, memoRec);\n};\n\nApply.prototype.reallyEval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  const origPosInfo = state.getCurrentPosInfo();\n  const ruleInfo = state.grammar.rules[this.ruleName];\n  const {body} = ruleInfo;\n  const {description} = ruleInfo;\n\n  state.enterApplication(origPosInfo, this);\n\n  if (description) {\n    state.pushFailuresInfo();\n  }\n\n  // Reset the input stream's examinedLength property so that we can track\n  // the examined length of this particular application.\n  const origInputStreamExaminedLength = inputStream.examinedLength;\n  inputStream.examinedLength = 0;\n\n  let value = this.evalOnce(body, state);\n  const currentLR = origPosInfo.currentLeftRecursion;\n  const memoKey = this.toMemoKey();\n  const isHeadOfLeftRecursion = currentLR && currentLR.headApplication.toMemoKey() === memoKey;\n  let memoRec;\n\n  if (state.doNotMemoize) {\n    state.doNotMemoize = false;\n  } else if (isHeadOfLeftRecursion) {\n    value = this.growSeedResult(body, state, origPos, currentLR, value);\n    origPosInfo.endLeftRecursion();\n    memoRec = currentLR;\n    memoRec.examinedLength = inputStream.examinedLength - origPos;\n    memoRec.rightmostFailureOffset = state._getRightmostFailureOffset();\n    origPosInfo.memoize(memoKey, memoRec); // updates origPosInfo's maxExaminedLength\n  } else if (!currentLR || !currentLR.isInvolved(memoKey)) {\n    // This application is not involved in left recursion, so it's ok to memoize it.\n    memoRec = origPosInfo.memoize(memoKey, {\n      matchLength: inputStream.pos - origPos,\n      examinedLength: inputStream.examinedLength - origPos,\n      value,\n      failuresAtRightmostPosition: state.cloneRecordedFailures(),\n      rightmostFailureOffset: state._getRightmostFailureOffset(),\n    });\n  }\n  const succeeded = !!value;\n\n  if (description) {\n    state.popFailuresInfo();\n    if (!succeeded) {\n      state.processFailure(origPos, this);\n    }\n    if (memoRec) {\n      memoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();\n    }\n  }\n\n  // Record trace information in the memo table, so that it is available if the memoized result\n  // is used later.\n  if (state.isTracing() && memoRec) {\n    const entry = state.getTraceEntry(origPos, this, succeeded, succeeded ? [value] : []);\n    if (isHeadOfLeftRecursion) {\n      assert(entry.terminatingLREntry != null || !succeeded);\n      entry.isHeadOfLeftRecursion = true;\n    }\n    memoRec.traceEntry = entry;\n  }\n\n  // Fix the input stream's examinedLength -- it should be the maximum examined length\n  // across all applications, not just this one.\n  inputStream.examinedLength = Math.max(\n      inputStream.examinedLength,\n      origInputStreamExaminedLength,\n  );\n\n  state.exitApplication(origPosInfo, value);\n\n  return succeeded;\n};\n\nApply.prototype.evalOnce = function(expr, state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n\n  if (state.eval(expr)) {\n    const arity = expr.getArity();\n    const bindings = state._bindings.splice(state._bindings.length - arity, arity);\n    const offsets = state._bindingOffsets.splice(state._bindingOffsets.length - arity, arity);\n    const matchLength = inputStream.pos - origPos;\n    return new NonterminalNode(this.ruleName, bindings, offsets, matchLength);\n  } else {\n    return false;\n  }\n};\n\nApply.prototype.growSeedResult = function(body, state, origPos, lrMemoRec, newValue) {\n  if (!newValue) {\n    return false;\n  }\n\n  const {inputStream} = state;\n\n  while (true) {\n    lrMemoRec.matchLength = inputStream.pos - origPos;\n    lrMemoRec.value = newValue;\n    lrMemoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();\n\n    if (state.isTracing()) {\n      // Before evaluating the body again, add a trace node for this application to the memo entry.\n      // Its only child is a copy of the trace node from `newValue`, which will always be the last\n      // element in `state.trace`.\n      const seedTrace = state.trace[state.trace.length - 1];\n      lrMemoRec.traceEntry = new Trace(\n          state.input,\n          origPos,\n          inputStream.pos,\n          this,\n          true,\n          [newValue],\n          [seedTrace.clone()],\n      );\n    }\n    inputStream.pos = origPos;\n    newValue = this.evalOnce(body, state);\n    if (inputStream.pos - origPos <= lrMemoRec.matchLength) {\n      break;\n    }\n    if (state.isTracing()) {\n      state.trace.splice(-2, 1); // Drop the trace for the old seed.\n    }\n  }\n  if (state.isTracing()) {\n    // The last entry is for an unused result -- pop it and save it in the \"real\" entry.\n    lrMemoRec.traceEntry.recordLRTermination(state.trace.pop(), newValue);\n  }\n  inputStream.pos = origPos + lrMemoRec.matchLength;\n  return lrMemoRec.value;\n};\n\nUnicodeChar.prototype.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  const ch = inputStream.next();\n  if (ch && this.pattern.test(ch)) {\n    state.pushBinding(new TerminalNode(ch.length), origPos);\n    return true;\n  } else {\n    state.processFailure(origPos, this);\n    return false;\n  }\n};\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\nPExpr.prototype.getArity = abstract('getArity');\n\nany.getArity =\n  end.getArity =\n  Terminal.prototype.getArity =\n  Range.prototype.getArity =\n  Param.prototype.getArity =\n  Apply.prototype.getArity =\n  UnicodeChar.prototype.getArity =\n    function() {\n      return 1;\n    };\n\nAlt.prototype.getArity = function() {\n  // This is ok b/c all terms must have the same arity -- this property is\n  // checked by the Grammar constructor.\n  return this.terms.length === 0 ? 0 : this.terms[0].getArity();\n};\n\nSeq.prototype.getArity = function() {\n  let arity = 0;\n  for (let idx = 0; idx < this.factors.length; idx++) {\n    arity += this.factors[idx].getArity();\n  }\n  return arity;\n};\n\nIter.prototype.getArity = function() {\n  return this.expr.getArity();\n};\n\nNot.prototype.getArity = function() {\n  return 0;\n};\n\nLookahead.prototype.getArity = Lex.prototype.getArity = function() {\n  return this.expr.getArity();\n};\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction getMetaInfo(expr, grammarInterval) {\n  const metaInfo = {};\n  if (expr.source && grammarInterval) {\n    const adjusted = expr.source.relativeTo(grammarInterval);\n    metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];\n  }\n  return metaInfo;\n}\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\nPExpr.prototype.outputRecipe = abstract('outputRecipe');\n\nany.outputRecipe = function(formals, grammarInterval) {\n  return ['any', getMetaInfo(this, grammarInterval)];\n};\n\nend.outputRecipe = function(formals, grammarInterval) {\n  return ['end', getMetaInfo(this, grammarInterval)];\n};\n\nTerminal.prototype.outputRecipe = function(formals, grammarInterval) {\n  return ['terminal', getMetaInfo(this, grammarInterval), this.obj];\n};\n\nRange.prototype.outputRecipe = function(formals, grammarInterval) {\n  return ['range', getMetaInfo(this, grammarInterval), this.from, this.to];\n};\n\nParam.prototype.outputRecipe = function(formals, grammarInterval) {\n  return ['param', getMetaInfo(this, grammarInterval), this.index];\n};\n\nAlt.prototype.outputRecipe = function(formals, grammarInterval) {\n  return ['alt', getMetaInfo(this, grammarInterval)].concat(\n      this.terms.map(term => term.outputRecipe(formals, grammarInterval)),\n  );\n};\n\nExtend.prototype.outputRecipe = function(formals, grammarInterval) {\n  const extension = this.terms[0]; // [extension, original]\n  return extension.outputRecipe(formals, grammarInterval);\n};\n\nSplice.prototype.outputRecipe = function(formals, grammarInterval) {\n  const beforeTerms = this.terms.slice(0, this.expansionPos);\n  const afterTerms = this.terms.slice(this.expansionPos + 1);\n  return [\n    'splice',\n    getMetaInfo(this, grammarInterval),\n    beforeTerms.map(term => term.outputRecipe(formals, grammarInterval)),\n    afterTerms.map(term => term.outputRecipe(formals, grammarInterval)),\n  ];\n};\n\nSeq.prototype.outputRecipe = function(formals, grammarInterval) {\n  return ['seq', getMetaInfo(this, grammarInterval)].concat(\n      this.factors.map(factor => factor.outputRecipe(formals, grammarInterval)),\n  );\n};\n\nStar.prototype.outputRecipe =\n  Plus.prototype.outputRecipe =\n  Opt.prototype.outputRecipe =\n  Not.prototype.outputRecipe =\n  Lookahead.prototype.outputRecipe =\n  Lex.prototype.outputRecipe =\n    function(formals, grammarInterval) {\n      return [\n        this.constructor.name.toLowerCase(),\n        getMetaInfo(this, grammarInterval),\n        this.expr.outputRecipe(formals, grammarInterval),\n      ];\n    };\n\nApply.prototype.outputRecipe = function(formals, grammarInterval) {\n  return [\n    'app',\n    getMetaInfo(this, grammarInterval),\n    this.ruleName,\n    this.args.map(arg => arg.outputRecipe(formals, grammarInterval)),\n  ];\n};\n\nUnicodeChar.prototype.outputRecipe = function(formals, grammarInterval) {\n  return ['unicodeChar', getMetaInfo(this, grammarInterval), this.category];\n};\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  Called at grammar creation time to rewrite a rule body, replacing each reference to a formal\n  parameter with a `Param` node. Returns a PExpr -- either a new one, or the original one if\n  it was modified in place.\n*/\nPExpr.prototype.introduceParams = abstract('introduceParams');\n\nany.introduceParams =\n  end.introduceParams =\n  Terminal.prototype.introduceParams =\n  Range.prototype.introduceParams =\n  Param.prototype.introduceParams =\n  UnicodeChar.prototype.introduceParams =\n    function(formals) {\n      return this;\n    };\n\nAlt.prototype.introduceParams = function(formals) {\n  this.terms.forEach((term, idx, terms) => {\n    terms[idx] = term.introduceParams(formals);\n  });\n  return this;\n};\n\nSeq.prototype.introduceParams = function(formals) {\n  this.factors.forEach((factor, idx, factors) => {\n    factors[idx] = factor.introduceParams(formals);\n  });\n  return this;\n};\n\nIter.prototype.introduceParams =\n  Not.prototype.introduceParams =\n  Lookahead.prototype.introduceParams =\n  Lex.prototype.introduceParams =\n    function(formals) {\n      this.expr = this.expr.introduceParams(formals);\n      return this;\n    };\n\nApply.prototype.introduceParams = function(formals) {\n  const index = formals.indexOf(this.ruleName);\n  if (index >= 0) {\n    if (this.args.length > 0) {\n      // TODO: Should this be supported? See issue #64.\n      throw new Error('Parameterized rules cannot be passed as arguments to another rule.');\n    }\n    return new Param(index).withSource(this.source);\n  } else {\n    this.args.forEach((arg, idx, args) => {\n      args[idx] = arg.introduceParams(formals);\n    });\n    return this;\n  }\n};\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n// Returns `true` if this parsing expression may accept without consuming any input.\nPExpr.prototype.isNullable = function(grammar) {\n  return this._isNullable(grammar, Object.create(null));\n};\n\nPExpr.prototype._isNullable = abstract('_isNullable');\n\nany._isNullable =\n  Range.prototype._isNullable =\n  Param.prototype._isNullable =\n  Plus.prototype._isNullable =\n  UnicodeChar.prototype._isNullable =\n    function(grammar, memo) {\n      return false;\n    };\n\nend._isNullable = function(grammar, memo) {\n  return true;\n};\n\nTerminal.prototype._isNullable = function(grammar, memo) {\n  if (typeof this.obj === 'string') {\n    // This is an over-simplification: it's only correct if the input is a string. If it's an array\n    // or an object, then the empty string parsing expression is not nullable.\n    return this.obj === '';\n  } else {\n    return false;\n  }\n};\n\nAlt.prototype._isNullable = function(grammar, memo) {\n  return this.terms.length === 0 || this.terms.some(term => term._isNullable(grammar, memo));\n};\n\nSeq.prototype._isNullable = function(grammar, memo) {\n  return this.factors.every(factor => factor._isNullable(grammar, memo));\n};\n\nStar.prototype._isNullable =\n  Opt.prototype._isNullable =\n  Not.prototype._isNullable =\n  Lookahead.prototype._isNullable =\n    function(grammar, memo) {\n      return true;\n    };\n\nLex.prototype._isNullable = function(grammar, memo) {\n  return this.expr._isNullable(grammar, memo);\n};\n\nApply.prototype._isNullable = function(grammar, memo) {\n  const key = this.toMemoKey();\n  if (!Object.prototype.hasOwnProperty.call(memo, key)) {\n    const {body} = grammar.rules[this.ruleName];\n    const inlined = body.substituteParams(this.args);\n    memo[key] = false; // Prevent infinite recursion for recursive rules.\n    memo[key] = inlined._isNullable(grammar, memo);\n  }\n  return memo[key];\n};\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  Returns a PExpr that results from recursively replacing every formal parameter (i.e., instance\n  of `Param`) inside this PExpr with its actual value from `actuals` (an Array).\n\n  The receiver must not be modified; a new PExpr must be returned if any replacement is necessary.\n*/\n// function(actuals) { ... }\nPExpr.prototype.substituteParams = abstract('substituteParams');\n\nany.substituteParams =\n  end.substituteParams =\n  Terminal.prototype.substituteParams =\n  Range.prototype.substituteParams =\n  UnicodeChar.prototype.substituteParams =\n    function(actuals) {\n      return this;\n    };\n\nParam.prototype.substituteParams = function(actuals) {\n  return actuals[this.index];\n};\n\nAlt.prototype.substituteParams = function(actuals) {\n  return new Alt(this.terms.map(term => term.substituteParams(actuals)));\n};\n\nSeq.prototype.substituteParams = function(actuals) {\n  return new Seq(this.factors.map(factor => factor.substituteParams(actuals)));\n};\n\nIter.prototype.substituteParams =\n  Not.prototype.substituteParams =\n  Lookahead.prototype.substituteParams =\n  Lex.prototype.substituteParams =\n    function(actuals) {\n      return new this.constructor(this.expr.substituteParams(actuals));\n    };\n\nApply.prototype.substituteParams = function(actuals) {\n  if (this.args.length === 0) {\n    // Avoid making a copy of this application, as an optimization\n    return this;\n  } else {\n    const args = this.args.map(arg => arg.substituteParams(actuals));\n    return new Apply(this.ruleName, args);\n  }\n};\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction isRestrictedJSIdentifier(str) {\n  return /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(str);\n}\n\nfunction resolveDuplicatedNames(argumentNameList) {\n  // `count` is used to record the number of times each argument name occurs in the list,\n  // this is useful for checking duplicated argument name. It maps argument names to ints.\n  const count = Object.create(null);\n  argumentNameList.forEach(argName => {\n    count[argName] = (count[argName] || 0) + 1;\n  });\n\n  // Append subscripts ('_1', '_2', ...) to duplicate argument names.\n  Object.keys(count).forEach(dupArgName => {\n    if (count[dupArgName] <= 1) {\n      return;\n    }\n\n    // This name shows up more than once, so add subscripts.\n    let subscript = 1;\n    argumentNameList.forEach((argName, idx) => {\n      if (argName === dupArgName) {\n        argumentNameList[idx] = argName + '_' + subscript++;\n      }\n    });\n  });\n}\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  Returns a list of strings that will be used as the default argument names for its receiver\n  (a pexpr) in a semantic action. This is used exclusively by the Semantics Editor.\n\n  `firstArgIndex` is the 1-based index of the first argument name that will be generated for this\n  pexpr. It enables us to name arguments positionally, e.g., if the second argument is a\n  non-alphanumeric terminal like \"+\", it will be named '$2'.\n\n  `noDupCheck` is true if the caller of `toArgumentNameList` is not a top level caller. It enables\n  us to avoid nested duplication subscripts appending, e.g., '_1_1', '_1_2', by only checking\n  duplicates at the top level.\n\n  Here is a more elaborate example that illustrates how this method works:\n  `(a \"+\" b).toArgumentNameList(1)` evaluates to `['a', '$2', 'b']` with the following recursive\n  calls:\n\n    (a).toArgumentNameList(1) -> ['a'],\n    (\"+\").toArgumentNameList(2) -> ['$2'],\n    (b).toArgumentNameList(3) -> ['b']\n\n  Notes:\n  * This method must only be called on well-formed expressions, e.g., the receiver must\n    not have any Alt sub-expressions with inconsistent arities.\n  * e.getArity() === e.toArgumentNameList(1).length\n*/\n// function(firstArgIndex, noDupCheck) { ... }\nPExpr.prototype.toArgumentNameList = abstract('toArgumentNameList');\n\nany.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return ['any'];\n};\n\nend.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return ['end'];\n};\n\nTerminal.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  if (typeof this.obj === 'string' && /^[_a-zA-Z0-9]+$/.test(this.obj)) {\n    // If this terminal is a valid suffix for a JS identifier, just prepend it with '_'\n    return ['_' + this.obj];\n  } else {\n    // Otherwise, name it positionally.\n    return ['$' + firstArgIndex];\n  }\n};\n\nRange.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  let argName = this.from + '_to_' + this.to;\n  // If the `argName` is not valid then try to prepend a `_`.\n  if (!isRestrictedJSIdentifier(argName)) {\n    argName = '_' + argName;\n  }\n  // If the `argName` still not valid after prepending a `_`, then name it positionally.\n  if (!isRestrictedJSIdentifier(argName)) {\n    argName = '$' + firstArgIndex;\n  }\n  return [argName];\n};\n\nAlt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  // `termArgNameLists` is an array of arrays where each row is the\n  // argument name list that corresponds to a term in this alternation.\n  const termArgNameLists = this.terms.map(term =>\n    term.toArgumentNameList(firstArgIndex, true),\n  );\n\n  const argumentNameList = [];\n  const numArgs = termArgNameLists[0].length;\n  for (let colIdx = 0; colIdx < numArgs; colIdx++) {\n    const col = [];\n    for (let rowIdx = 0; rowIdx < this.terms.length; rowIdx++) {\n      col.push(termArgNameLists[rowIdx][colIdx]);\n    }\n    const uniqueNames = copyWithoutDuplicates(col);\n    argumentNameList.push(uniqueNames.join('_or_'));\n  }\n\n  if (!noDupCheck) {\n    resolveDuplicatedNames(argumentNameList);\n  }\n  return argumentNameList;\n};\n\nSeq.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  // Generate the argument name list, without worrying about duplicates.\n  let argumentNameList = [];\n  this.factors.forEach(factor => {\n    const factorArgumentNameList = factor.toArgumentNameList(firstArgIndex, true);\n    argumentNameList = argumentNameList.concat(factorArgumentNameList);\n\n    // Shift the firstArgIndex to take this factor's argument names into account.\n    firstArgIndex += factorArgumentNameList.length;\n  });\n  if (!noDupCheck) {\n    resolveDuplicatedNames(argumentNameList);\n  }\n  return argumentNameList;\n};\n\nIter.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  const argumentNameList = this.expr\n      .toArgumentNameList(firstArgIndex, noDupCheck)\n      .map(exprArgumentString =>\n      exprArgumentString[exprArgumentString.length - 1] === 's' ?\n        exprArgumentString + 'es' :\n        exprArgumentString + 's',\n      );\n  if (!noDupCheck) {\n    resolveDuplicatedNames(argumentNameList);\n  }\n  return argumentNameList;\n};\n\nOpt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map(argName => {\n    return 'opt' + argName[0].toUpperCase() + argName.slice(1);\n  });\n};\n\nNot.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return [];\n};\n\nLookahead.prototype.toArgumentNameList = Lex.prototype.toArgumentNameList =\n  function(firstArgIndex, noDupCheck) {\n    return this.expr.toArgumentNameList(firstArgIndex, noDupCheck);\n  };\n\nApply.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return [this.ruleName];\n};\n\nUnicodeChar.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return ['$' + firstArgIndex];\n};\n\nParam.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return ['param' + this.index];\n};\n\n// \"Value pexprs\" (Value, Str, Arr, Obj) are going away soon, so we don't worry about them here.\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n// Returns a string representing the PExpr, for use as a UI label, etc.\nPExpr.prototype.toDisplayString = abstract('toDisplayString');\n\nAlt.prototype.toDisplayString = Seq.prototype.toDisplayString = function() {\n  if (this.source) {\n    return this.source.trimmed().contents;\n  }\n  return '[' + this.constructor.name + ']';\n};\n\nany.toDisplayString =\n  end.toDisplayString =\n  Iter.prototype.toDisplayString =\n  Not.prototype.toDisplayString =\n  Lookahead.prototype.toDisplayString =\n  Lex.prototype.toDisplayString =\n  Terminal.prototype.toDisplayString =\n  Range.prototype.toDisplayString =\n  Param.prototype.toDisplayString =\n    function() {\n      return this.toString();\n    };\n\nApply.prototype.toDisplayString = function() {\n  if (this.args.length > 0) {\n    const ps = this.args.map(arg => arg.toDisplayString());\n    return this.ruleName + '<' + ps.join(',') + '>';\n  } else {\n    return this.ruleName;\n  }\n};\n\nUnicodeChar.prototype.toDisplayString = function() {\n  return 'Unicode [' + this.category + '] character';\n};\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n/*\n  `Failure`s represent expressions that weren't matched while parsing. They are used to generate\n  error messages automatically. The interface of `Failure`s includes the collowing methods:\n\n  - getText() : String\n  - getType() : String  (one of {\"description\", \"string\", \"code\"})\n  - isDescription() : bool\n  - isStringTerminal() : bool\n  - isCode() : bool\n  - isFluffy() : bool\n  - makeFluffy() : void\n  - subsumes(Failure) : bool\n*/\n\nfunction isValidType(type) {\n  return type === 'description' || type === 'string' || type === 'code';\n}\n\nclass Failure {\n  constructor(pexpr, text, type) {\n    if (!isValidType(type)) {\n      throw new Error('invalid Failure type: ' + type);\n    }\n    this.pexpr = pexpr;\n    this.text = text;\n    this.type = type;\n    this.fluffy = false;\n  }\n\n  getPExpr() {\n    return this.pexpr;\n  }\n\n  getText() {\n    return this.text;\n  }\n\n  getType() {\n    return this.type;\n  }\n\n  isDescription() {\n    return this.type === 'description';\n  }\n\n  isStringTerminal() {\n    return this.type === 'string';\n  }\n\n  isCode() {\n    return this.type === 'code';\n  }\n\n  isFluffy() {\n    return this.fluffy;\n  }\n\n  makeFluffy() {\n    this.fluffy = true;\n  }\n\n  clearFluffy() {\n    this.fluffy = false;\n  }\n\n  subsumes(that) {\n    return (\n      this.getText() === that.getText() &&\n      this.type === that.type &&\n      (!this.isFluffy() || (this.isFluffy() && that.isFluffy()))\n    );\n  }\n\n  toString() {\n    return this.type === 'string' ? JSON.stringify(this.getText()) : this.getText();\n  }\n\n  clone() {\n    const failure = new Failure(this.pexpr, this.text, this.type);\n    if (this.isFluffy()) {\n      failure.makeFluffy();\n    }\n    return failure;\n  }\n\n  toKey() {\n    return this.toString() + '#' + this.type;\n  }\n}\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\nPExpr.prototype.toFailure = abstract('toFailure');\n\nany.toFailure = function(grammar) {\n  return new Failure(this, 'any object', 'description');\n};\n\nend.toFailure = function(grammar) {\n  return new Failure(this, 'end of input', 'description');\n};\n\nTerminal.prototype.toFailure = function(grammar) {\n  return new Failure(this, this.obj, 'string');\n};\n\nRange.prototype.toFailure = function(grammar) {\n  // TODO: come up with something better\n  return new Failure(this, JSON.stringify(this.from) + '..' + JSON.stringify(this.to), 'code');\n};\n\nNot.prototype.toFailure = function(grammar) {\n  const description =\n    this.expr === any ? 'nothing' : 'not ' + this.expr.toFailure(grammar);\n  return new Failure(this, description, 'description');\n};\n\nLookahead.prototype.toFailure = function(grammar) {\n  return this.expr.toFailure(grammar);\n};\n\nApply.prototype.toFailure = function(grammar) {\n  let {description} = grammar.rules[this.ruleName];\n  if (!description) {\n    const article = /^[aeiouAEIOU]/.test(this.ruleName) ? 'an' : 'a';\n    description = article + ' ' + this.ruleName;\n  }\n  return new Failure(this, description, 'description');\n};\n\nUnicodeChar.prototype.toFailure = function(grammar) {\n  return new Failure(this, 'a Unicode [' + this.category + '] character', 'description');\n};\n\nAlt.prototype.toFailure = function(grammar) {\n  const fs = this.terms.map(t => t.toFailure(grammar));\n  const description = '(' + fs.join(' or ') + ')';\n  return new Failure(this, description, 'description');\n};\n\nSeq.prototype.toFailure = function(grammar) {\n  const fs = this.factors.map(f => f.toFailure(grammar));\n  const description = '(' + fs.join(' ') + ')';\n  return new Failure(this, description, 'description');\n};\n\nIter.prototype.toFailure = function(grammar) {\n  const description = '(' + this.expr.toFailure(grammar) + this.operator + ')';\n  return new Failure(this, description, 'description');\n};\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  e1.toString() === e2.toString() ==> e1 and e2 are semantically equivalent.\n  Note that this is not an iff (<==>): e.g.,\n  (~\"b\" \"a\").toString() !== (\"a\").toString(), even though\n  ~\"b\" \"a\" and \"a\" are interchangeable in any grammar,\n  both in terms of the languages they accept and their arities.\n*/\nPExpr.prototype.toString = abstract('toString');\n\nany.toString = function() {\n  return 'any';\n};\n\nend.toString = function() {\n  return 'end';\n};\n\nTerminal.prototype.toString = function() {\n  return JSON.stringify(this.obj);\n};\n\nRange.prototype.toString = function() {\n  return JSON.stringify(this.from) + '..' + JSON.stringify(this.to);\n};\n\nParam.prototype.toString = function() {\n  return '$' + this.index;\n};\n\nLex.prototype.toString = function() {\n  return '#(' + this.expr.toString() + ')';\n};\n\nAlt.prototype.toString = function() {\n  return this.terms.length === 1 ?\n    this.terms[0].toString() :\n    '(' + this.terms.map(term => term.toString()).join(' | ') + ')';\n};\n\nSeq.prototype.toString = function() {\n  return this.factors.length === 1 ?\n    this.factors[0].toString() :\n    '(' + this.factors.map(factor => factor.toString()).join(' ') + ')';\n};\n\nIter.prototype.toString = function() {\n  return this.expr + this.operator;\n};\n\nNot.prototype.toString = function() {\n  return '~' + this.expr;\n};\n\nLookahead.prototype.toString = function() {\n  return '&' + this.expr;\n};\n\nApply.prototype.toString = function() {\n  if (this.args.length > 0) {\n    const ps = this.args.map(arg => arg.toString());\n    return this.ruleName + '<' + ps.join(',') + '>';\n  } else {\n    return this.ruleName;\n  }\n};\n\nUnicodeChar.prototype.toString = function() {\n  return '\\\\p{' + this.category + '}';\n};\n\nclass CaseInsensitiveTerminal extends PExpr {\n  constructor(param) {\n    super();\n    this.obj = param;\n  }\n\n  _getString(state) {\n    const terminal = state.currentApplication().args[this.obj.index];\n    assert(terminal instanceof Terminal, 'expected a Terminal expression');\n    return terminal.obj;\n  }\n\n  // Implementation of the PExpr API\n\n  allowsSkippingPrecedingSpace() {\n    return true;\n  }\n\n  eval(state) {\n    const {inputStream} = state;\n    const origPos = inputStream.pos;\n    const matchStr = this._getString(state);\n    if (!inputStream.matchString(matchStr, true)) {\n      state.processFailure(origPos, this);\n      return false;\n    } else {\n      state.pushBinding(new TerminalNode(matchStr.length), origPos);\n      return true;\n    }\n  }\n\n  getArity() {\n    return 1;\n  }\n\n  substituteParams(actuals) {\n    return new CaseInsensitiveTerminal(this.obj.substituteParams(actuals));\n  }\n\n  toDisplayString() {\n    return this.obj.toDisplayString() + ' (case-insensitive)';\n  }\n\n  toFailure(grammar) {\n    return new Failure(\n        this,\n        this.obj.toFailure(grammar) + ' (case-insensitive)',\n        'description',\n    );\n  }\n\n  _isNullable(grammar, memo) {\n    return this.obj._isNullable(grammar, memo);\n  }\n}\n\n// --------------------------------------------------------------------\n\nvar pexprs = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  CaseInsensitiveTerminal: CaseInsensitiveTerminal,\n  PExpr: PExpr,\n  any: any,\n  end: end,\n  Terminal: Terminal,\n  Range: Range,\n  Param: Param,\n  Alt: Alt,\n  Extend: Extend,\n  Splice: Splice,\n  Seq: Seq,\n  Iter: Iter,\n  Star: Star,\n  Plus: Plus,\n  Opt: Opt,\n  Not: Not,\n  Lookahead: Lookahead,\n  Lex: Lex,\n  Apply: Apply,\n  UnicodeChar: UnicodeChar\n});\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nlet builtInApplySyntacticBody;\n\nawaitBuiltInRules(builtInRules => {\n  builtInApplySyntacticBody = builtInRules.rules.applySyntactic.body;\n});\n\nconst applySpaces = new Apply('spaces');\n\nclass MatchState {\n  constructor(matcher, startExpr, optPositionToRecordFailures) {\n    this.matcher = matcher;\n    this.startExpr = startExpr;\n\n    this.grammar = matcher.grammar;\n    this.input = matcher.getInput();\n    this.inputStream = new InputStream(this.input);\n    this.memoTable = matcher._memoTable;\n\n    this.userData = undefined;\n    this.doNotMemoize = false;\n\n    this._bindings = [];\n    this._bindingOffsets = [];\n    this._applicationStack = [];\n    this._posStack = [0];\n    this.inLexifiedContextStack = [false];\n\n    this.rightmostFailurePosition = -1;\n    this._rightmostFailurePositionStack = [];\n    this._recordedFailuresStack = [];\n\n    if (optPositionToRecordFailures !== undefined) {\n      this.positionToRecordFailures = optPositionToRecordFailures;\n      this.recordedFailures = Object.create(null);\n    }\n  }\n\n  posToOffset(pos) {\n    return pos - this._posStack[this._posStack.length - 1];\n  }\n\n  enterApplication(posInfo, app) {\n    this._posStack.push(this.inputStream.pos);\n    this._applicationStack.push(app);\n    this.inLexifiedContextStack.push(false);\n    posInfo.enter(app);\n    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);\n    this.rightmostFailurePosition = -1;\n  }\n\n  exitApplication(posInfo, optNode) {\n    const origPos = this._posStack.pop();\n    this._applicationStack.pop();\n    this.inLexifiedContextStack.pop();\n    posInfo.exit();\n\n    this.rightmostFailurePosition = Math.max(\n        this.rightmostFailurePosition,\n        this._rightmostFailurePositionStack.pop(),\n    );\n\n    if (optNode) {\n      this.pushBinding(optNode, origPos);\n    }\n  }\n\n  enterLexifiedContext() {\n    this.inLexifiedContextStack.push(true);\n  }\n\n  exitLexifiedContext() {\n    this.inLexifiedContextStack.pop();\n  }\n\n  currentApplication() {\n    return this._applicationStack[this._applicationStack.length - 1];\n  }\n\n  inSyntacticContext() {\n    const currentApplication = this.currentApplication();\n    if (currentApplication) {\n      return currentApplication.isSyntactic() && !this.inLexifiedContext();\n    } else {\n      // The top-level context is syntactic if the start application is.\n      return this.startExpr.factors[0].isSyntactic();\n    }\n  }\n\n  inLexifiedContext() {\n    return this.inLexifiedContextStack[this.inLexifiedContextStack.length - 1];\n  }\n\n  skipSpaces() {\n    this.pushFailuresInfo();\n    this.eval(applySpaces);\n    this.popBinding();\n    this.popFailuresInfo();\n    return this.inputStream.pos;\n  }\n\n  skipSpacesIfInSyntacticContext() {\n    return this.inSyntacticContext() ? this.skipSpaces() : this.inputStream.pos;\n  }\n\n  maybeSkipSpacesBefore(expr) {\n    if (expr.allowsSkippingPrecedingSpace() && expr !== applySpaces) {\n      return this.skipSpacesIfInSyntacticContext();\n    } else {\n      return this.inputStream.pos;\n    }\n  }\n\n  pushBinding(node, origPos) {\n    this._bindings.push(node);\n    this._bindingOffsets.push(this.posToOffset(origPos));\n  }\n\n  popBinding() {\n    this._bindings.pop();\n    this._bindingOffsets.pop();\n  }\n\n  numBindings() {\n    return this._bindings.length;\n  }\n\n  truncateBindings(newLength) {\n    // Yes, this is this really faster than setting the `length` property (tested with\n    // bin/es5bench on Node v6.1.0).\n    // Update 2021-10-25: still true on v14.15.5  it's ~20% speedup on es5bench.\n    while (this._bindings.length > newLength) {\n      this.popBinding();\n    }\n  }\n\n  getCurrentPosInfo() {\n    return this.getPosInfo(this.inputStream.pos);\n  }\n\n  getPosInfo(pos) {\n    let posInfo = this.memoTable[pos];\n    if (!posInfo) {\n      posInfo = this.memoTable[pos] = new PosInfo();\n    }\n    return posInfo;\n  }\n\n  processFailure(pos, expr) {\n    this.rightmostFailurePosition = Math.max(this.rightmostFailurePosition, pos);\n\n    if (this.recordedFailures && pos === this.positionToRecordFailures) {\n      const app = this.currentApplication();\n      if (app) {\n        // Substitute parameters with the actual pexprs that were passed to\n        // the current rule.\n        expr = expr.substituteParams(app.args);\n      }\n\n      this.recordFailure(expr.toFailure(this.grammar), false);\n    }\n  }\n\n  recordFailure(failure, shouldCloneIfNew) {\n    const key = failure.toKey();\n    if (!this.recordedFailures[key]) {\n      this.recordedFailures[key] = shouldCloneIfNew ? failure.clone() : failure;\n    } else if (this.recordedFailures[key].isFluffy() && !failure.isFluffy()) {\n      this.recordedFailures[key].clearFluffy();\n    }\n  }\n\n  recordFailures(failures, shouldCloneIfNew) {\n    Object.keys(failures).forEach(key => {\n      this.recordFailure(failures[key], shouldCloneIfNew);\n    });\n  }\n\n  cloneRecordedFailures() {\n    if (!this.recordedFailures) {\n      return undefined;\n    }\n\n    const ans = Object.create(null);\n    Object.keys(this.recordedFailures).forEach(key => {\n      ans[key] = this.recordedFailures[key].clone();\n    });\n    return ans;\n  }\n\n  getRightmostFailurePosition() {\n    return this.rightmostFailurePosition;\n  }\n\n  _getRightmostFailureOffset() {\n    return this.rightmostFailurePosition >= 0 ?\n      this.posToOffset(this.rightmostFailurePosition) :\n      -1;\n  }\n\n  // Returns the memoized trace entry for `expr` at `pos`, if one exists, `null` otherwise.\n  getMemoizedTraceEntry(pos, expr) {\n    const posInfo = this.memoTable[pos];\n    if (posInfo && expr instanceof Apply) {\n      const memoRec = posInfo.memo[expr.toMemoKey()];\n      if (memoRec && memoRec.traceEntry) {\n        const entry = memoRec.traceEntry.cloneWithExpr(expr);\n        entry.isMemoized = true;\n        return entry;\n      }\n    }\n    return null;\n  }\n\n  // Returns a new trace entry, with the currently active trace array as its children.\n  getTraceEntry(pos, expr, succeeded, bindings) {\n    if (expr instanceof Apply) {\n      const app = this.currentApplication();\n      const actuals = app ? app.args : [];\n      expr = expr.substituteParams(actuals);\n    }\n    return (\n      this.getMemoizedTraceEntry(pos, expr) ||\n      new Trace(this.input, pos, this.inputStream.pos, expr, succeeded, bindings, this.trace)\n    );\n  }\n\n  isTracing() {\n    return !!this.trace;\n  }\n\n  hasNecessaryInfo(memoRec) {\n    if (this.trace && !memoRec.traceEntry) {\n      return false;\n    }\n\n    if (\n      this.recordedFailures &&\n      this.inputStream.pos + memoRec.rightmostFailureOffset === this.positionToRecordFailures\n    ) {\n      return !!memoRec.failuresAtRightmostPosition;\n    }\n\n    return true;\n  }\n\n  useMemoizedResult(origPos, memoRec) {\n    if (this.trace) {\n      this.trace.push(memoRec.traceEntry);\n    }\n\n    const memoRecRightmostFailurePosition =\n      this.inputStream.pos + memoRec.rightmostFailureOffset;\n    this.rightmostFailurePosition = Math.max(\n        this.rightmostFailurePosition,\n        memoRecRightmostFailurePosition,\n    );\n    if (\n      this.recordedFailures &&\n      this.positionToRecordFailures === memoRecRightmostFailurePosition &&\n      memoRec.failuresAtRightmostPosition\n    ) {\n      this.recordFailures(memoRec.failuresAtRightmostPosition, true);\n    }\n\n    this.inputStream.examinedLength = Math.max(\n        this.inputStream.examinedLength,\n        memoRec.examinedLength + origPos,\n    );\n\n    if (memoRec.value) {\n      this.inputStream.pos += memoRec.matchLength;\n      this.pushBinding(memoRec.value, origPos);\n      return true;\n    }\n    return false;\n  }\n\n  // Evaluate `expr` and return `true` if it succeeded, `false` otherwise. On success, `bindings`\n  // will have `expr.getArity()` more elements than before, and the input stream's position may\n  // have increased. On failure, `bindings` and position will be unchanged.\n  eval(expr) {\n    const {inputStream} = this;\n    const origNumBindings = this._bindings.length;\n    const origUserData = this.userData;\n\n    let origRecordedFailures;\n    if (this.recordedFailures) {\n      origRecordedFailures = this.recordedFailures;\n      this.recordedFailures = Object.create(null);\n    }\n\n    const origPos = inputStream.pos;\n    const memoPos = this.maybeSkipSpacesBefore(expr);\n\n    let origTrace;\n    if (this.trace) {\n      origTrace = this.trace;\n      this.trace = [];\n    }\n\n    // Do the actual evaluation.\n    const ans = expr.eval(this);\n\n    if (this.trace) {\n      const bindings = this._bindings.slice(origNumBindings);\n      const traceEntry = this.getTraceEntry(memoPos, expr, ans, bindings);\n      traceEntry.isImplicitSpaces = expr === applySpaces;\n      traceEntry.isRootNode = expr === this.startExpr;\n      origTrace.push(traceEntry);\n      this.trace = origTrace;\n    }\n\n    if (ans) {\n      if (this.recordedFailures && inputStream.pos === this.positionToRecordFailures) {\n        Object.keys(this.recordedFailures).forEach(key => {\n          this.recordedFailures[key].makeFluffy();\n        });\n      }\n    } else {\n      // Reset the position, bindings, and userData.\n      inputStream.pos = origPos;\n      this.truncateBindings(origNumBindings);\n      this.userData = origUserData;\n    }\n\n    if (this.recordedFailures) {\n      this.recordFailures(origRecordedFailures, false);\n    }\n\n    // The built-in applySyntactic rule needs special handling: we want to skip\n    // trailing spaces, just as with the top-level application of a syntactic rule.\n    if (expr === builtInApplySyntacticBody) {\n      this.skipSpaces();\n    }\n\n    return ans;\n  }\n\n  getMatchResult() {\n    this.grammar._setUpMatchState(this);\n    this.eval(this.startExpr);\n    let rightmostFailures;\n    if (this.recordedFailures) {\n      rightmostFailures = Object.keys(this.recordedFailures).map(\n          key => this.recordedFailures[key],\n      );\n    }\n    const cst = this._bindings[0];\n    if (cst) {\n      cst.grammar = this.grammar;\n    }\n    return new MatchResult(\n        this.matcher,\n        this.input,\n        this.startExpr,\n        cst,\n        this._bindingOffsets[0],\n        this.rightmostFailurePosition,\n        rightmostFailures,\n    );\n  }\n\n  getTrace() {\n    this.trace = [];\n    const matchResult = this.getMatchResult();\n\n    // The trace node for the start rule is always the last entry. If it is a syntactic rule,\n    // the first entry is for an application of 'spaces'.\n    // TODO(pdubroy): Clean this up by introducing a special `Match<startAppl>` rule, which will\n    // ensure that there is always a single root trace node.\n    const rootTrace = this.trace[this.trace.length - 1];\n    rootTrace.result = matchResult;\n    return rootTrace;\n  }\n\n  pushFailuresInfo() {\n    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);\n    this._recordedFailuresStack.push(this.recordedFailures);\n  }\n\n  popFailuresInfo() {\n    this.rightmostFailurePosition = this._rightmostFailurePositionStack.pop();\n    this.recordedFailures = this._recordedFailuresStack.pop();\n  }\n}\n\nclass Matcher {\n  constructor(grammar) {\n    this.grammar = grammar;\n    this._memoTable = [];\n    this._input = '';\n    this._isMemoTableStale = false;\n  }\n\n  _resetMemoTable() {\n    this._memoTable = [];\n    this._isMemoTableStale = false;\n  }\n\n  getInput() {\n    return this._input;\n  }\n\n  setInput(str) {\n    if (this._input !== str) {\n      this.replaceInputRange(0, this._input.length, str);\n    }\n    return this;\n  }\n\n  replaceInputRange(startIdx, endIdx, str) {\n    const prevInput = this._input;\n    const memoTable = this._memoTable;\n    if (\n      startIdx < 0 ||\n      startIdx > prevInput.length ||\n      endIdx < 0 ||\n      endIdx > prevInput.length ||\n      startIdx > endIdx\n    ) {\n      throw new Error('Invalid indices: ' + startIdx + ' and ' + endIdx);\n    }\n\n    // update input\n    this._input = prevInput.slice(0, startIdx) + str + prevInput.slice(endIdx);\n    if (this._input !== prevInput && memoTable.length > 0) {\n      this._isMemoTableStale = true;\n    }\n\n    // update memo table (similar to the above)\n    const restOfMemoTable = memoTable.slice(endIdx);\n    memoTable.length = startIdx;\n    for (let idx = 0; idx < str.length; idx++) {\n      memoTable.push(undefined);\n    }\n    for (const posInfo of restOfMemoTable) {\n      memoTable.push(posInfo);\n    }\n\n    // Invalidate memoRecs\n    for (let pos = 0; pos < startIdx; pos++) {\n      const posInfo = memoTable[pos];\n      if (posInfo) {\n        posInfo.clearObsoleteEntries(pos, startIdx);\n      }\n    }\n\n    return this;\n  }\n\n  match(optStartApplicationStr, options = {incremental: true}) {\n    return this._match(this._getStartExpr(optStartApplicationStr), {\n      incremental: options.incremental,\n      tracing: false,\n    });\n  }\n\n  trace(optStartApplicationStr, options = {incremental: true}) {\n    return this._match(this._getStartExpr(optStartApplicationStr), {\n      incremental: options.incremental,\n      tracing: true,\n    });\n  }\n\n  _match(startExpr, options = {}) {\n    const opts = {\n      tracing: false,\n      incremental: true,\n      positionToRecordFailures: undefined,\n      ...options,\n    };\n    if (!opts.incremental) {\n      this._resetMemoTable();\n    } else if (this._isMemoTableStale && !this.grammar.supportsIncrementalParsing) {\n      throw grammarDoesNotSupportIncrementalParsing(this.grammar);\n    }\n\n    const state = new MatchState(this, startExpr, opts.positionToRecordFailures);\n    return opts.tracing ? state.getTrace() : state.getMatchResult();\n  }\n\n  /*\n    Returns the starting expression for this Matcher's associated grammar. If\n    `optStartApplicationStr` is specified, it is a string expressing a rule application in the\n    grammar. If not specified, the grammar's default start rule will be used.\n  */\n  _getStartExpr(optStartApplicationStr) {\n    const applicationStr = optStartApplicationStr || this.grammar.defaultStartRule;\n    if (!applicationStr) {\n      throw new Error('Missing start rule argument -- the grammar has no default start rule.');\n    }\n\n    const startApp = this.grammar.parseApplication(applicationStr);\n    return new Seq([startApp, end]);\n  }\n}\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nconst globalActionStack = [];\n\nconst hasOwnProperty = (x, prop) => Object.prototype.hasOwnProperty.call(x, prop);\n\n// ----------------- Wrappers -----------------\n\n// Wrappers decorate CST nodes with all of the functionality (i.e., operations and attributes)\n// provided by a Semantics (see below). `Wrapper` is the abstract superclass of all wrappers. A\n// `Wrapper` must have `_node` and `_semantics` instance variables, which refer to the CST node and\n// Semantics (resp.) for which it was created, and a `_childWrappers` instance variable which is\n// used to cache the wrapper instances that are created for its child nodes. Setting these instance\n// variables is the responsibility of the constructor of each Semantics-specific subclass of\n// `Wrapper`.\nclass Wrapper {\n  constructor(node, sourceInterval, baseInterval) {\n    this._node = node;\n    this.source = sourceInterval;\n\n    // The interval that the childOffsets of `node` are relative to. It should be the source\n    // of the closest Nonterminal node.\n    this._baseInterval = baseInterval;\n\n    if (node.isNonterminal()) {\n      assert(sourceInterval === baseInterval);\n    }\n    this._childWrappers = [];\n  }\n\n  _forgetMemoizedResultFor(attributeName) {\n    // Remove the memoized attribute from the cstNode and all its children.\n    delete this._node[this._semantics.attributeKeys[attributeName]];\n    this.children.forEach(child => {\n      child._forgetMemoizedResultFor(attributeName);\n    });\n  }\n\n  // Returns the wrapper of the specified child node. Child wrappers are created lazily and\n  // cached in the parent wrapper's `_childWrappers` instance variable.\n  child(idx) {\n    if (!(0 <= idx && idx < this._node.numChildren())) {\n      // TODO: Consider throwing an exception here.\n      return undefined;\n    }\n    let childWrapper = this._childWrappers[idx];\n    if (!childWrapper) {\n      const childNode = this._node.childAt(idx);\n      const offset = this._node.childOffsets[idx];\n\n      const source = this._baseInterval.subInterval(offset, childNode.matchLength);\n      const base = childNode.isNonterminal() ? source : this._baseInterval;\n      childWrapper = this._childWrappers[idx] = this._semantics.wrap(childNode, source, base);\n    }\n    return childWrapper;\n  }\n\n  // Returns an array containing the wrappers of all of the children of the node associated\n  // with this wrapper.\n  _children() {\n    // Force the creation of all child wrappers\n    for (let idx = 0; idx < this._node.numChildren(); idx++) {\n      this.child(idx);\n    }\n    return this._childWrappers;\n  }\n\n  // Returns `true` if the CST node associated with this wrapper corresponds to an iteration\n  // expression, i.e., a Kleene-*, Kleene-+, or an optional. Returns `false` otherwise.\n  isIteration() {\n    return this._node.isIteration();\n  }\n\n  // Returns `true` if the CST node associated with this wrapper is a terminal node, `false`\n  // otherwise.\n  isTerminal() {\n    return this._node.isTerminal();\n  }\n\n  // Returns `true` if the CST node associated with this wrapper is a nonterminal node, `false`\n  // otherwise.\n  isNonterminal() {\n    return this._node.isNonterminal();\n  }\n\n  // Returns `true` if the CST node associated with this wrapper is a nonterminal node\n  // corresponding to a syntactic rule, `false` otherwise.\n  isSyntactic() {\n    return this.isNonterminal() && this._node.isSyntactic();\n  }\n\n  // Returns `true` if the CST node associated with this wrapper is a nonterminal node\n  // corresponding to a lexical rule, `false` otherwise.\n  isLexical() {\n    return this.isNonterminal() && this._node.isLexical();\n  }\n\n  // Returns `true` if the CST node associated with this wrapper is an iterator node\n  // having either one or no child (? operator), `false` otherwise.\n  // Otherwise, throws an exception.\n  isOptional() {\n    return this._node.isOptional();\n  }\n\n  // Create a new _iter wrapper in the same semantics as this wrapper.\n  iteration(optChildWrappers) {\n    const childWrappers = optChildWrappers || [];\n\n    const childNodes = childWrappers.map(c => c._node);\n    const iter = new IterationNode(childNodes, [], -1, false);\n\n    const wrapper = this._semantics.wrap(iter, null, null);\n    wrapper._childWrappers = childWrappers;\n    return wrapper;\n  }\n\n  // Returns an array containing the children of this CST node.\n  get children() {\n    return this._children();\n  }\n\n  // Returns the name of grammar rule that created this CST node.\n  get ctorName() {\n    return this._node.ctorName;\n  }\n\n  // Returns the number of children of this CST node.\n  get numChildren() {\n    return this._node.numChildren();\n  }\n\n  // Returns the contents of the input stream consumed by this CST node.\n  get sourceString() {\n    return this.source.contents;\n  }\n}\n\n// ----------------- Semantics -----------------\n\n// A Semantics is a container for a family of Operations and Attributes for a given grammar.\n// Semantics enable modularity (different clients of a grammar can create their set of operations\n// and attributes in isolation) and extensibility even when operations and attributes are mutually-\n// recursive. This constructor should not be called directly except from\n// `Semantics.createSemantics`. The normal ways to create a Semantics, given a grammar 'g', are\n// `g.createSemantics()` and `g.extendSemantics(parentSemantics)`.\nclass Semantics {\n  constructor(grammar, superSemantics) {\n    const self = this;\n    this.grammar = grammar;\n    this.checkedActionDicts = false;\n\n    // Constructor for wrapper instances, which are passed as the arguments to the semantic actions\n    // of an operation or attribute. Operations and attributes require double dispatch: the semantic\n    // action is chosen based on both the node's type and the semantics. Wrappers ensure that\n    // the `execute` method is called with the correct (most specific) semantics object as an\n    // argument.\n    this.Wrapper = class extends (superSemantics ? superSemantics.Wrapper : Wrapper) {\n      constructor(node, sourceInterval, baseInterval) {\n        super(node, sourceInterval, baseInterval);\n        self.checkActionDictsIfHaventAlready();\n        this._semantics = self;\n      }\n\n      toString() {\n        return '[semantics wrapper for ' + self.grammar.name + ']';\n      }\n    };\n\n    this.super = superSemantics;\n    if (superSemantics) {\n      if (!(grammar.equals(this.super.grammar) || grammar._inheritsFrom(this.super.grammar))) {\n        throw new Error(\n            \"Cannot extend a semantics for grammar '\" +\n            this.super.grammar.name +\n            \"' for use with grammar '\" +\n            grammar.name +\n            \"' (not a sub-grammar)\",\n        );\n      }\n      this.operations = Object.create(this.super.operations);\n      this.attributes = Object.create(this.super.attributes);\n      this.attributeKeys = Object.create(null);\n\n      // Assign unique symbols for each of the attributes inherited from the super-semantics so that\n      // they are memoized independently.\n      // eslint-disable-next-line guard-for-in\n      for (const attributeName in this.attributes) {\n        Object.defineProperty(this.attributeKeys, attributeName, {\n          value: uniqueId(attributeName),\n        });\n      }\n    } else {\n      this.operations = Object.create(null);\n      this.attributes = Object.create(null);\n      this.attributeKeys = Object.create(null);\n    }\n  }\n\n  toString() {\n    return '[semantics for ' + this.grammar.name + ']';\n  }\n\n  checkActionDictsIfHaventAlready() {\n    if (!this.checkedActionDicts) {\n      this.checkActionDicts();\n      this.checkedActionDicts = true;\n    }\n  }\n\n  // Checks that the action dictionaries for all operations and attributes in this semantics,\n  // including the ones that were inherited from the super-semantics, agree with the grammar.\n  // Throws an exception if one or more of them doesn't.\n  checkActionDicts() {\n    let name;\n    // eslint-disable-next-line guard-for-in\n    for (name in this.operations) {\n      this.operations[name].checkActionDict(this.grammar);\n    }\n    // eslint-disable-next-line guard-for-in\n    for (name in this.attributes) {\n      this.attributes[name].checkActionDict(this.grammar);\n    }\n  }\n\n  toRecipe(semanticsOnly) {\n    function hasSuperSemantics(s) {\n      return s.super !== Semantics.BuiltInSemantics._getSemantics();\n    }\n\n    let str = '(function(g) {\\n';\n    if (hasSuperSemantics(this)) {\n      str += '  var semantics = ' + this.super.toRecipe(true) + '(g';\n\n      const superSemanticsGrammar = this.super.grammar;\n      let relatedGrammar = this.grammar;\n      while (relatedGrammar !== superSemanticsGrammar) {\n        str += '.superGrammar';\n        relatedGrammar = relatedGrammar.superGrammar;\n      }\n\n      str += ');\\n';\n      str += '  return g.extendSemantics(semantics)';\n    } else {\n      str += '  return g.createSemantics()';\n    }\n    ['Operation', 'Attribute'].forEach(type => {\n      const semanticOperations = this[type.toLowerCase() + 's'];\n      Object.keys(semanticOperations).forEach(name => {\n        const {actionDict, formals, builtInDefault} = semanticOperations[name];\n\n        let signature = name;\n        if (formals.length > 0) {\n          signature += '(' + formals.join(', ') + ')';\n        }\n\n        let method;\n        if (hasSuperSemantics(this) && this.super[type.toLowerCase() + 's'][name]) {\n          method = 'extend' + type;\n        } else {\n          method = 'add' + type;\n        }\n        str += '\\n    .' + method + '(' + JSON.stringify(signature) + ', {';\n\n        const srcArray = [];\n        Object.keys(actionDict).forEach(actionName => {\n          if (actionDict[actionName] !== builtInDefault) {\n            let source = actionDict[actionName].toString().trim();\n\n            // Convert method shorthand to plain old function syntax.\n            // https://github.com/ohmjs/ohm/issues/263\n            source = source.replace(/^.*\\(/, 'function(');\n\n            srcArray.push('\\n      ' + JSON.stringify(actionName) + ': ' + source);\n          }\n        });\n        str += srcArray.join(',') + '\\n    })';\n      });\n    });\n    str += ';\\n  })';\n\n    if (!semanticsOnly) {\n      str =\n        '(function() {\\n' +\n        '  var grammar = this.fromRecipe(' +\n        this.grammar.toRecipe() +\n        ');\\n' +\n        '  var semantics = ' +\n        str +\n        '(grammar);\\n' +\n        '  return semantics;\\n' +\n        '});\\n';\n    }\n\n    return str;\n  }\n\n  addOperationOrAttribute(type, signature, actionDict) {\n    const typePlural = type + 's';\n\n    const parsedNameAndFormalArgs = parseSignature(signature, type);\n    const {name} = parsedNameAndFormalArgs;\n    const {formals} = parsedNameAndFormalArgs;\n\n    // TODO: check that there are no duplicate formal arguments\n\n    this.assertNewName(name, type);\n\n    // Create the action dictionary for this operation / attribute that contains a `_default` action\n    // which defines the default behavior of iteration, terminal, and non-terminal nodes...\n    const builtInDefault = newDefaultAction(type, name, doIt);\n    const realActionDict = {_default: builtInDefault};\n    // ... and add in the actions supplied by the programmer, which may override some or all of the\n    // default ones.\n    Object.keys(actionDict).forEach(name => {\n      realActionDict[name] = actionDict[name];\n    });\n\n    const entry =\n      type === 'operation' ?\n        new Operation(name, formals, realActionDict, builtInDefault) :\n        new Attribute(name, realActionDict, builtInDefault);\n\n    // The following check is not strictly necessary (it will happen later anyway) but it's better\n    // to catch errors early.\n    entry.checkActionDict(this.grammar);\n\n    this[typePlural][name] = entry;\n\n    function doIt(...args) {\n      // Dispatch to most specific version of this operation / attribute -- it may have been\n      // overridden by a sub-semantics.\n      const thisThing = this._semantics[typePlural][name];\n\n      // Check that the caller passed the correct number of arguments.\n      if (arguments.length !== thisThing.formals.length) {\n        throw new Error(\n            'Invalid number of arguments passed to ' +\n            name +\n            ' ' +\n            type +\n            ' (expected ' +\n            thisThing.formals.length +\n            ', got ' +\n            arguments.length +\n            ')',\n        );\n      }\n\n      // Create an \"arguments object\" from the arguments that were passed to this\n      // operation / attribute.\n      const argsObj = Object.create(null);\n      for (const [idx, val] of Object.entries(args)) {\n        const formal = thisThing.formals[idx];\n        argsObj[formal] = val;\n      }\n\n      const oldArgs = this.args;\n      this.args = argsObj;\n      const ans = thisThing.execute(this._semantics, this);\n      this.args = oldArgs;\n      return ans;\n    }\n\n    if (type === 'operation') {\n      this.Wrapper.prototype[name] = doIt;\n      this.Wrapper.prototype[name].toString = function() {\n        return '[' + name + ' operation]';\n      };\n    } else {\n      Object.defineProperty(this.Wrapper.prototype, name, {\n        get: doIt,\n        configurable: true, // So the property can be deleted.\n      });\n      Object.defineProperty(this.attributeKeys, name, {\n        value: uniqueId(name),\n      });\n    }\n  }\n\n  extendOperationOrAttribute(type, name, actionDict) {\n    const typePlural = type + 's';\n\n    // Make sure that `name` really is just a name, i.e., that it doesn't also contain formals.\n    parseSignature(name, 'attribute');\n\n    if (!(this.super && name in this.super[typePlural])) {\n      throw new Error(\n          'Cannot extend ' +\n          type +\n          \" '\" +\n          name +\n          \"': did not inherit an \" +\n          type +\n          ' with that name',\n      );\n    }\n    if (hasOwnProperty(this[typePlural], name)) {\n      throw new Error('Cannot extend ' + type + \" '\" + name + \"' again\");\n    }\n\n    // Create a new operation / attribute whose actionDict delegates to the super operation /\n    // attribute's actionDict, and which has all the keys from `inheritedActionDict`.\n    const inheritedFormals = this[typePlural][name].formals;\n    const inheritedActionDict = this[typePlural][name].actionDict;\n    const newActionDict = Object.create(inheritedActionDict);\n    Object.keys(actionDict).forEach(name => {\n      newActionDict[name] = actionDict[name];\n    });\n\n    this[typePlural][name] =\n      type === 'operation' ?\n        new Operation(name, inheritedFormals, newActionDict) :\n        new Attribute(name, newActionDict);\n\n    // The following check is not strictly necessary (it will happen later anyway) but it's better\n    // to catch errors early.\n    this[typePlural][name].checkActionDict(this.grammar);\n  }\n\n  assertNewName(name, type) {\n    if (hasOwnProperty(Wrapper.prototype, name)) {\n      throw new Error('Cannot add ' + type + \" '\" + name + \"': that's a reserved name\");\n    }\n    if (name in this.operations) {\n      throw new Error(\n          'Cannot add ' + type + \" '\" + name + \"': an operation with that name already exists\",\n      );\n    }\n    if (name in this.attributes) {\n      throw new Error(\n          'Cannot add ' + type + \" '\" + name + \"': an attribute with that name already exists\",\n      );\n    }\n  }\n\n  // Returns a wrapper for the given CST `node` in this semantics.\n  // If `node` is already a wrapper, returns `node` itself.  // TODO: why is this needed?\n  wrap(node, source, optBaseInterval) {\n    const baseInterval = optBaseInterval || source;\n    return node instanceof this.Wrapper ? node : new this.Wrapper(node, source, baseInterval);\n  }\n}\n\nfunction parseSignature(signature, type) {\n  if (!Semantics.prototypeGrammar) {\n    // The Operations and Attributes grammar won't be available while Ohm is loading,\n    // but we can get away the following simplification b/c none of the operations\n    // that are used while loading take arguments.\n    assert(signature.indexOf('(') === -1);\n    return {\n      name: signature,\n      formals: [],\n    };\n  }\n\n  const r = Semantics.prototypeGrammar.match(\n      signature,\n    type === 'operation' ? 'OperationSignature' : 'AttributeSignature',\n  );\n  if (r.failed()) {\n    throw new Error(r.message);\n  }\n\n  return Semantics.prototypeGrammarSemantics(r).parse();\n}\n\nfunction newDefaultAction(type, name, doIt) {\n  return function(...children) {\n    const thisThing = this._semantics.operations[name] || this._semantics.attributes[name];\n    const args = thisThing.formals.map(formal => this.args[formal]);\n\n    if (!this.isIteration() && children.length === 1) {\n      // This CST node corresponds to a non-terminal in the grammar (e.g., AddExpr). The fact that\n      // we got here means that this action dictionary doesn't have an action for this particular\n      // non-terminal or a generic `_nonterminal` action.\n      // As a convenience, if this node only has one child, we just return the result of applying\n      // this operation / attribute to the child node.\n      return doIt.apply(children[0], args);\n    } else {\n      // Otherwise, we throw an exception to let the programmer know that we don't know what\n      // to do with this node.\n      throw missingSemanticAction(this.ctorName, name, type, globalActionStack);\n    }\n  };\n}\n\n// Creates a new Semantics instance for `grammar`, inheriting operations and attributes from\n// `optSuperSemantics`, if it is specified. Returns a function that acts as a proxy for the new\n// Semantics instance. When that function is invoked with a CST node as an argument, it returns\n// a wrapper for that node which gives access to the operations and attributes provided by this\n// semantics.\nSemantics.createSemantics = function(grammar, optSuperSemantics) {\n  const s = new Semantics(\n      grammar,\n    optSuperSemantics !== undefined ?\n      optSuperSemantics :\n      Semantics.BuiltInSemantics._getSemantics(),\n  );\n\n  // To enable clients to invoke a semantics like a function, return a function that acts as a proxy\n  // for `s`, which is the real `Semantics` instance.\n  const proxy = function ASemantics(matchResult) {\n    if (!(matchResult instanceof MatchResult)) {\n      throw new TypeError(\n          'Semantics expected a MatchResult, but got ' +\n          unexpectedObjToString(matchResult),\n      );\n    }\n    if (matchResult.failed()) {\n      throw new TypeError('cannot apply Semantics to ' + matchResult.toString());\n    }\n\n    const cst = matchResult._cst;\n    if (cst.grammar !== grammar) {\n      throw new Error(\n          \"Cannot use a MatchResult from grammar '\" +\n          cst.grammar.name +\n          \"' with a semantics for '\" +\n          grammar.name +\n          \"'\",\n      );\n    }\n    const inputStream = new InputStream(matchResult.input);\n    return s.wrap(cst, inputStream.interval(matchResult._cstOffset, matchResult.input.length));\n  };\n\n  // Forward public methods from the proxy to the semantics instance.\n  proxy.addOperation = function(signature, actionDict) {\n    s.addOperationOrAttribute('operation', signature, actionDict);\n    return proxy;\n  };\n  proxy.extendOperation = function(name, actionDict) {\n    s.extendOperationOrAttribute('operation', name, actionDict);\n    return proxy;\n  };\n  proxy.addAttribute = function(name, actionDict) {\n    s.addOperationOrAttribute('attribute', name, actionDict);\n    return proxy;\n  };\n  proxy.extendAttribute = function(name, actionDict) {\n    s.extendOperationOrAttribute('attribute', name, actionDict);\n    return proxy;\n  };\n  proxy._getActionDict = function(operationOrAttributeName) {\n    const action =\n      s.operations[operationOrAttributeName] || s.attributes[operationOrAttributeName];\n    if (!action) {\n      throw new Error(\n          '\"' +\n          operationOrAttributeName +\n          '\" is not a valid operation or attribute ' +\n          'name in this semantics for \"' +\n          grammar.name +\n          '\"',\n      );\n    }\n    return action.actionDict;\n  };\n  proxy._remove = function(operationOrAttributeName) {\n    let semantic;\n    if (operationOrAttributeName in s.operations) {\n      semantic = s.operations[operationOrAttributeName];\n      delete s.operations[operationOrAttributeName];\n    } else if (operationOrAttributeName in s.attributes) {\n      semantic = s.attributes[operationOrAttributeName];\n      delete s.attributes[operationOrAttributeName];\n    }\n    delete s.Wrapper.prototype[operationOrAttributeName];\n    return semantic;\n  };\n  proxy.getOperationNames = function() {\n    return Object.keys(s.operations);\n  };\n  proxy.getAttributeNames = function() {\n    return Object.keys(s.attributes);\n  };\n  proxy.getGrammar = function() {\n    return s.grammar;\n  };\n  proxy.toRecipe = function(semanticsOnly) {\n    return s.toRecipe(semanticsOnly);\n  };\n\n  // Make the proxy's toString() work.\n  proxy.toString = s.toString.bind(s);\n\n  // Returns the semantics for the proxy.\n  proxy._getSemantics = function() {\n    return s;\n  };\n\n  return proxy;\n};\n\n// ----------------- Operation -----------------\n\n// An Operation represents a function to be applied to a concrete syntax tree (CST) -- it's very\n// similar to a Visitor (http://en.wikipedia.org/wiki/Visitor_pattern). An operation is executed by\n// recursively walking the CST, and at each node, invoking the matching semantic action from\n// `actionDict`. See `Operation.prototype.execute` for details of how a CST node's matching semantic\n// action is found.\nclass Operation {\n  constructor(name, formals, actionDict, builtInDefault) {\n    this.name = name;\n    this.formals = formals;\n    this.actionDict = actionDict;\n    this.builtInDefault = builtInDefault;\n  }\n\n  checkActionDict(grammar) {\n    grammar._checkTopDownActionDict(this.typeName, this.name, this.actionDict);\n  }\n\n  // Execute this operation on the CST node associated with `nodeWrapper` in the context of the\n  // given Semantics instance.\n  execute(semantics, nodeWrapper) {\n    try {\n      // Look for a semantic action whose name matches the node's constructor name, which is either\n      // the name of a rule in the grammar, or '_terminal' (for a terminal node), or '_iter' (for an\n      // iteration node).\n      const {ctorName} = nodeWrapper._node;\n      let actionFn = this.actionDict[ctorName];\n      if (actionFn) {\n        globalActionStack.push([this, ctorName]);\n        return actionFn.apply(nodeWrapper, nodeWrapper._children());\n      }\n\n      // The action dictionary does not contain a semantic action for this specific type of node.\n      // If this is a nonterminal node and the programmer has provided a `_nonterminal` semantic\n      // action, we invoke it:\n      if (nodeWrapper.isNonterminal()) {\n        actionFn = this.actionDict._nonterminal;\n        if (actionFn) {\n          globalActionStack.push([this, '_nonterminal', ctorName]);\n          return actionFn.apply(nodeWrapper, nodeWrapper._children());\n        }\n      }\n\n      // Otherwise, we invoke the '_default' semantic action.\n      globalActionStack.push([this, 'default action', ctorName]);\n      return this.actionDict._default.apply(nodeWrapper, nodeWrapper._children());\n    } finally {\n      globalActionStack.pop();\n    }\n  }\n}\n\nOperation.prototype.typeName = 'operation';\n\n// ----------------- Attribute -----------------\n\n// Attributes are Operations whose results are memoized. This means that, for any given semantics,\n// the semantic action for a CST node will be invoked no more than once.\nclass Attribute extends Operation {\n  constructor(name, actionDict, builtInDefault) {\n    super(name, [], actionDict, builtInDefault);\n  }\n\n  execute(semantics, nodeWrapper) {\n    const node = nodeWrapper._node;\n    const key = semantics.attributeKeys[this.name];\n    if (!hasOwnProperty(node, key)) {\n      // The following is a super-send -- isn't JS beautiful? :/\n      node[key] = Operation.prototype.execute.call(this, semantics, nodeWrapper);\n    }\n    return node[key];\n  }\n}\n\nAttribute.prototype.typeName = 'attribute';\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nconst SPECIAL_ACTION_NAMES = ['_iter', '_terminal', '_nonterminal', '_default'];\n\nfunction getSortedRuleValues(grammar) {\n  return Object.keys(grammar.rules)\n      .sort()\n      .map(name => grammar.rules[name]);\n}\n\n// Until ES2019, JSON was not a valid subset of JavaScript because U+2028 (line separator)\n// and U+2029 (paragraph separator) are allowed in JSON string literals, but not in JS.\n// This function properly encodes those two characters so that the resulting string is\n// represents both valid JSON, and valid JavaScript (for ES2018 and below).\n// See https://v8.dev/features/subsume-json for more details.\nconst jsonToJS = str => str.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n\nlet ohmGrammar;\nlet buildGrammar;\n\nclass Grammar {\n  constructor(name, superGrammar, rules, optDefaultStartRule) {\n    this.name = name;\n    this.superGrammar = superGrammar;\n    this.rules = rules;\n    if (optDefaultStartRule) {\n      if (!(optDefaultStartRule in rules)) {\n        throw new Error(\n            \"Invalid start rule: '\" +\n            optDefaultStartRule +\n            \"' is not a rule in grammar '\" +\n            name +\n            \"'\",\n        );\n      }\n      this.defaultStartRule = optDefaultStartRule;\n    }\n    this._matchStateInitializer = undefined;\n    this.supportsIncrementalParsing = true;\n  }\n\n  matcher() {\n    return new Matcher(this);\n  }\n\n  // Return true if the grammar is a built-in grammar, otherwise false.\n  // NOTE: This might give an unexpected result if called before BuiltInRules is defined!\n  isBuiltIn() {\n    return this === Grammar.ProtoBuiltInRules || this === Grammar.BuiltInRules;\n  }\n\n  equals(g) {\n    if (this === g) {\n      return true;\n    }\n    // Do the cheapest comparisons first.\n    if (\n      g == null ||\n      this.name !== g.name ||\n      this.defaultStartRule !== g.defaultStartRule ||\n      !(this.superGrammar === g.superGrammar || this.superGrammar.equals(g.superGrammar))\n    ) {\n      return false;\n    }\n    const myRules = getSortedRuleValues(this);\n    const otherRules = getSortedRuleValues(g);\n    return (\n      myRules.length === otherRules.length &&\n      myRules.every((rule, i) => {\n        return (\n          rule.description === otherRules[i].description &&\n          rule.formals.join(',') === otherRules[i].formals.join(',') &&\n          rule.body.toString() === otherRules[i].body.toString()\n        );\n      })\n    );\n  }\n\n  match(input, optStartApplication) {\n    const m = this.matcher();\n    m.replaceInputRange(0, 0, input);\n    return m.match(optStartApplication);\n  }\n\n  trace(input, optStartApplication) {\n    const m = this.matcher();\n    m.replaceInputRange(0, 0, input);\n    return m.trace(optStartApplication);\n  }\n\n  createSemantics() {\n    return Semantics.createSemantics(this);\n  }\n\n  extendSemantics(superSemantics) {\n    return Semantics.createSemantics(this, superSemantics._getSemantics());\n  }\n\n  // Check that every key in `actionDict` corresponds to a semantic action, and that it maps to\n  // a function of the correct arity. If not, throw an exception.\n  _checkTopDownActionDict(what, name, actionDict) {\n    const problems = [];\n\n    // eslint-disable-next-line guard-for-in\n    for (const k in actionDict) {\n      const v = actionDict[k];\n      const isSpecialAction = SPECIAL_ACTION_NAMES.includes(k);\n\n      if (!isSpecialAction && !(k in this.rules)) {\n        problems.push(`'${k}' is not a valid semantic action for '${this.name}'`);\n        continue;\n      }\n      if (typeof v !== 'function') {\n        problems.push(`'${k}' must be a function in an action dictionary for '${this.name}'`);\n        continue;\n      }\n      const actual = v.length;\n      const expected = this._topDownActionArity(k);\n      if (actual !== expected) {\n        let details;\n        if (k === '_iter' || k === '_nonterminal') {\n          details =\n            `it should use a rest parameter, e.g. \\`${k}(...children) {}\\`. ` +\n            'NOTE: this is new in Ohm v16  see https://ohmjs.org/d/ati for details.';\n        } else {\n          details = `expected ${expected}, got ${actual}`;\n        }\n        problems.push(`Semantic action '${k}' has the wrong arity: ${details}`);\n      }\n    }\n    if (problems.length > 0) {\n      const prettyProblems = problems.map(problem => '- ' + problem);\n      const error = new Error(\n          [\n            `Found errors in the action dictionary of the '${name}' ${what}:`,\n            ...prettyProblems,\n          ].join('\\n'),\n      );\n      error.problems = problems;\n      throw error;\n    }\n  }\n\n  // Return the expected arity for a semantic action named `actionName`, which\n  // is either a rule name or a special action name like '_nonterminal'.\n  _topDownActionArity(actionName) {\n    // All special actions have an expected arity of 0, though all but _terminal\n    // are expected to use the rest parameter syntax (e.g. `_iter(...children)`).\n    // This is considered to have arity 0, i.e. `((...args) => {}).length` is 0.\n    return SPECIAL_ACTION_NAMES.includes(actionName) ?\n      0 :\n      this.rules[actionName].body.getArity();\n  }\n\n  _inheritsFrom(grammar) {\n    let g = this.superGrammar;\n    while (g) {\n      if (g.equals(grammar, true)) {\n        return true;\n      }\n      g = g.superGrammar;\n    }\n    return false;\n  }\n\n  toRecipe(superGrammarExpr = undefined) {\n    const metaInfo = {};\n    // Include the grammar source if it is available.\n    if (this.source) {\n      metaInfo.source = this.source.contents;\n    }\n\n    let startRule = null;\n    if (this.defaultStartRule) {\n      startRule = this.defaultStartRule;\n    }\n\n    const rules = {};\n    Object.keys(this.rules).forEach(ruleName => {\n      const ruleInfo = this.rules[ruleName];\n      const {body} = ruleInfo;\n      const isDefinition = !this.superGrammar || !this.superGrammar.rules[ruleName];\n\n      let operation;\n      if (isDefinition) {\n        operation = 'define';\n      } else {\n        operation = body instanceof Extend ? 'extend' : 'override';\n      }\n\n      const metaInfo = {};\n      if (ruleInfo.source && this.source) {\n        const adjusted = ruleInfo.source.relativeTo(this.source);\n        metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];\n      }\n\n      const description = isDefinition ? ruleInfo.description : null;\n      const bodyRecipe = body.outputRecipe(ruleInfo.formals, this.source);\n\n      rules[ruleName] = [\n        operation, // \"define\"/\"extend\"/\"override\"\n        metaInfo,\n        description,\n        ruleInfo.formals,\n        bodyRecipe,\n      ];\n    });\n\n    // If the caller provided an expression to use for the supergrammar, use that.\n    // Otherwise, if the supergrammar is a user grammar, use its recipe inline.\n    let superGrammarOutput = 'null';\n    if (superGrammarExpr) {\n      superGrammarOutput = superGrammarExpr;\n    } else if (this.superGrammar && !this.superGrammar.isBuiltIn()) {\n      superGrammarOutput = this.superGrammar.toRecipe();\n    }\n\n    const recipeElements = [\n      ...['grammar', metaInfo, this.name].map(JSON.stringify),\n      superGrammarOutput,\n      ...[startRule, rules].map(JSON.stringify),\n    ];\n    return jsonToJS(`[${recipeElements.join(',')}]`);\n  }\n\n  // TODO: Come up with better names for these methods.\n  // TODO: Write the analog of these methods for inherited attributes.\n  toOperationActionDictionaryTemplate() {\n    return this._toOperationOrAttributeActionDictionaryTemplate();\n  }\n  toAttributeActionDictionaryTemplate() {\n    return this._toOperationOrAttributeActionDictionaryTemplate();\n  }\n\n  _toOperationOrAttributeActionDictionaryTemplate() {\n    // TODO: add the super-grammar's templates at the right place, e.g., a case for AddExpr_plus\n    // should appear next to other cases of AddExpr.\n\n    const sb = new StringBuffer();\n    sb.append('{');\n\n    let first = true;\n    // eslint-disable-next-line guard-for-in\n    for (const ruleName in this.rules) {\n      const {body} = this.rules[ruleName];\n      if (first) {\n        first = false;\n      } else {\n        sb.append(',');\n      }\n      sb.append('\\n');\n      sb.append('  ');\n      this.addSemanticActionTemplate(ruleName, body, sb);\n    }\n\n    sb.append('\\n}');\n    return sb.contents();\n  }\n\n  addSemanticActionTemplate(ruleName, body, sb) {\n    sb.append(ruleName);\n    sb.append(': function(');\n    const arity = this._topDownActionArity(ruleName);\n    sb.append(repeat('_', arity).join(', '));\n    sb.append(') {\\n');\n    sb.append('  }');\n  }\n\n  // Parse a string which expresses a rule application in this grammar, and return the\n  // resulting Apply node.\n  parseApplication(str) {\n    let app;\n    if (str.indexOf('<') === -1) {\n      // simple application\n      app = new Apply(str);\n    } else {\n      // parameterized application\n      const cst = ohmGrammar.match(str, 'Base_application');\n      app = buildGrammar(cst, {});\n    }\n\n    // Ensure that the application is valid.\n    if (!(app.ruleName in this.rules)) {\n      throw undeclaredRule(app.ruleName, this.name);\n    }\n    const {formals} = this.rules[app.ruleName];\n    if (formals.length !== app.args.length) {\n      const {source} = this.rules[app.ruleName];\n      throw wrongNumberOfParameters(\n          app.ruleName,\n          formals.length,\n          app.args.length,\n          source,\n      );\n    }\n    return app;\n  }\n\n  _setUpMatchState(state) {\n    if (this._matchStateInitializer) {\n      this._matchStateInitializer(state);\n    }\n  }\n}\n\n// The following grammar contains a few rules that couldn't be written  in \"userland\".\n// At the bottom of src/main.js, we create a sub-grammar of this grammar that's called\n// `BuiltInRules`. That grammar contains several convenience rules, e.g., `letter` and\n// `digit`, and is implicitly the super-grammar of any grammar whose super-grammar\n// isn't specified.\nGrammar.ProtoBuiltInRules = new Grammar(\n    'ProtoBuiltInRules', // name\n    undefined, // supergrammar\n    {\n      any: {\n        body: any,\n        formals: [],\n        description: 'any character',\n        primitive: true,\n      },\n      end: {\n        body: end,\n        formals: [],\n        description: 'end of input',\n        primitive: true,\n      },\n\n      caseInsensitive: {\n        body: new CaseInsensitiveTerminal(new Param(0)),\n        formals: ['str'],\n        primitive: true,\n      },\n      lower: {\n        body: new UnicodeChar('Ll'),\n        formals: [],\n        description: 'a lowercase letter',\n        primitive: true,\n      },\n      upper: {\n        body: new UnicodeChar('Lu'),\n        formals: [],\n        description: 'an uppercase letter',\n        primitive: true,\n      },\n      // Union of Lt (titlecase), Lm (modifier), and Lo (other), i.e. any letter not in Ll or Lu.\n      unicodeLtmo: {\n        body: new UnicodeChar('Ltmo'),\n        formals: [],\n        description: 'a Unicode character in Lt, Lm, or Lo',\n        primitive: true,\n      },\n\n      // These rules are not truly primitive (they could be written in userland) but are defined\n      // here for bootstrapping purposes.\n      spaces: {\n        body: new Star(new Apply('space')),\n        formals: [],\n      },\n      space: {\n        body: new Range('\\x00', ' '),\n        formals: [],\n        description: 'a space',\n      },\n    },\n);\n\n// This method is called from main.js once Ohm has loaded.\nGrammar.initApplicationParser = function(grammar, builderFn) {\n  ohmGrammar = grammar;\n  buildGrammar = builderFn;\n};\n\n// --------------------------------------------------------------------\n// Private Stuff\n// --------------------------------------------------------------------\n\n// Constructors\n\nclass GrammarDecl {\n  constructor(name) {\n    this.name = name;\n  }\n\n  // Helpers\n\n  sourceInterval(startIdx, endIdx) {\n    return this.source.subInterval(startIdx, endIdx - startIdx);\n  }\n\n  ensureSuperGrammar() {\n    if (!this.superGrammar) {\n      this.withSuperGrammar(\n        // TODO: The conditional expression below is an ugly hack. It's kind of ok because\n        // I doubt anyone will ever try to declare a grammar called `BuiltInRules`. Still,\n        // we should try to find a better way to do this.\n        this.name === 'BuiltInRules' ? Grammar.ProtoBuiltInRules : Grammar.BuiltInRules,\n      );\n    }\n    return this.superGrammar;\n  }\n\n  ensureSuperGrammarRuleForOverriding(name, source) {\n    const ruleInfo = this.ensureSuperGrammar().rules[name];\n    if (!ruleInfo) {\n      throw cannotOverrideUndeclaredRule(name, this.superGrammar.name, source);\n    }\n    return ruleInfo;\n  }\n\n  installOverriddenOrExtendedRule(name, formals, body, source) {\n    const duplicateParameterNames$1 = getDuplicates(formals);\n    if (duplicateParameterNames$1.length > 0) {\n      throw duplicateParameterNames(name, duplicateParameterNames$1, source);\n    }\n    const ruleInfo = this.ensureSuperGrammar().rules[name];\n    const expectedFormals = ruleInfo.formals;\n    const expectedNumFormals = expectedFormals ? expectedFormals.length : 0;\n    if (formals.length !== expectedNumFormals) {\n      throw wrongNumberOfParameters(name, expectedNumFormals, formals.length, source);\n    }\n    return this.install(name, formals, body, ruleInfo.description, source);\n  }\n\n  install(name, formals, body, description, source, primitive = false) {\n    this.rules[name] = {\n      body: body.introduceParams(formals),\n      formals,\n      description,\n      source,\n      primitive,\n    };\n    return this;\n  }\n\n  // Stuff that you should only do once\n\n  withSuperGrammar(superGrammar) {\n    if (this.superGrammar) {\n      throw new Error('the super grammar of a GrammarDecl cannot be set more than once');\n    }\n    this.superGrammar = superGrammar;\n    this.rules = Object.create(superGrammar.rules);\n\n    // Grammars with an explicit supergrammar inherit a default start rule.\n    if (!superGrammar.isBuiltIn()) {\n      this.defaultStartRule = superGrammar.defaultStartRule;\n    }\n    return this;\n  }\n\n  withDefaultStartRule(ruleName) {\n    this.defaultStartRule = ruleName;\n    return this;\n  }\n\n  withSource(source) {\n    this.source = new InputStream(source).interval(0, source.length);\n    return this;\n  }\n\n  // Creates a Grammar instance, and if it passes the sanity checks, returns it.\n  build() {\n    const grammar = new Grammar(\n        this.name,\n        this.ensureSuperGrammar(),\n        this.rules,\n        this.defaultStartRule,\n    );\n    // Initialize internal props that are inherited from the super grammar.\n    grammar._matchStateInitializer = grammar.superGrammar._matchStateInitializer;\n    grammar.supportsIncrementalParsing = grammar.superGrammar.supportsIncrementalParsing;\n\n    // TODO: change the pexpr.prototype.assert... methods to make them add\n    // exceptions to an array that's provided as an arg. Then we'll be able to\n    // show more than one error of the same type at a time.\n    // TODO: include the offending pexpr in the errors, that way we can show\n    // the part of the source that caused it.\n    const grammarErrors = [];\n    let grammarHasInvalidApplications = false;\n    Object.keys(grammar.rules).forEach(ruleName => {\n      const {body} = grammar.rules[ruleName];\n      try {\n        body.assertChoicesHaveUniformArity(ruleName);\n      } catch (e) {\n        grammarErrors.push(e);\n      }\n      try {\n        body.assertAllApplicationsAreValid(ruleName, grammar);\n      } catch (e) {\n        grammarErrors.push(e);\n        grammarHasInvalidApplications = true;\n      }\n    });\n    if (!grammarHasInvalidApplications) {\n      // The following check can only be done if the grammar has no invalid applications.\n      Object.keys(grammar.rules).forEach(ruleName => {\n        const {body} = grammar.rules[ruleName];\n        try {\n          body.assertIteratedExprsAreNotNullable(grammar, []);\n        } catch (e) {\n          grammarErrors.push(e);\n        }\n      });\n    }\n    if (grammarErrors.length > 0) {\n      throwErrors(grammarErrors);\n    }\n    if (this.source) {\n      grammar.source = this.source;\n    }\n\n    return grammar;\n  }\n\n  // Rule declarations\n\n  define(name, formals, body, description, source, primitive) {\n    this.ensureSuperGrammar();\n    if (this.superGrammar.rules[name]) {\n      throw duplicateRuleDeclaration(name, this.name, this.superGrammar.name, source);\n    } else if (this.rules[name]) {\n      throw duplicateRuleDeclaration(name, this.name, this.name, source);\n    }\n    const duplicateParameterNames$1 = getDuplicates(formals);\n    if (duplicateParameterNames$1.length > 0) {\n      throw duplicateParameterNames(name, duplicateParameterNames$1, source);\n    }\n    return this.install(name, formals, body, description, source, primitive);\n  }\n\n  override(name, formals, body, descIgnored, source) {\n    this.ensureSuperGrammarRuleForOverriding(name, source);\n    this.installOverriddenOrExtendedRule(name, formals, body, source);\n    return this;\n  }\n\n  extend(name, formals, fragment, descIgnored, source) {\n    const ruleInfo = this.ensureSuperGrammar().rules[name];\n    if (!ruleInfo) {\n      throw cannotExtendUndeclaredRule(name, this.superGrammar.name, source);\n    }\n    const body = new Extend(this.superGrammar, name, fragment);\n    body.source = fragment.source;\n    this.installOverriddenOrExtendedRule(name, formals, body, source);\n    return this;\n  }\n}\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nclass Builder {\n  constructor() {\n    this.currentDecl = null;\n    this.currentRuleName = null;\n  }\n\n  newGrammar(name) {\n    return new GrammarDecl(name);\n  }\n\n  grammar(metaInfo, name, superGrammar, defaultStartRule, rules) {\n    const gDecl = new GrammarDecl(name);\n    if (superGrammar) {\n      // `superGrammar` may be a recipe (i.e. an Array), or an actual grammar instance.\n      gDecl.withSuperGrammar(\n        superGrammar instanceof Grammar ? superGrammar : this.fromRecipe(superGrammar),\n      );\n    }\n    if (defaultStartRule) {\n      gDecl.withDefaultStartRule(defaultStartRule);\n    }\n    if (metaInfo && metaInfo.source) {\n      gDecl.withSource(metaInfo.source);\n    }\n\n    this.currentDecl = gDecl;\n    Object.keys(rules).forEach(ruleName => {\n      this.currentRuleName = ruleName;\n      const ruleRecipe = rules[ruleName];\n\n      const action = ruleRecipe[0]; // define/extend/override\n      const metaInfo = ruleRecipe[1];\n      const description = ruleRecipe[2];\n      const formals = ruleRecipe[3];\n      const body = this.fromRecipe(ruleRecipe[4]);\n\n      let source;\n      if (gDecl.source && metaInfo && metaInfo.sourceInterval) {\n        source = gDecl.source.subInterval(\n            metaInfo.sourceInterval[0],\n            metaInfo.sourceInterval[1] - metaInfo.sourceInterval[0],\n        );\n      }\n      gDecl[action](ruleName, formals, body, description, source);\n    });\n    this.currentRuleName = this.currentDecl = null;\n    return gDecl.build();\n  }\n\n  terminal(x) {\n    return new Terminal(x);\n  }\n\n  range(from, to) {\n    return new Range(from, to);\n  }\n\n  param(index) {\n    return new Param(index);\n  }\n\n  alt(...termArgs) {\n    let terms = [];\n    for (let arg of termArgs) {\n      if (!(arg instanceof PExpr)) {\n        arg = this.fromRecipe(arg);\n      }\n      if (arg instanceof Alt) {\n        terms = terms.concat(arg.terms);\n      } else {\n        terms.push(arg);\n      }\n    }\n    return terms.length === 1 ? terms[0] : new Alt(terms);\n  }\n\n  seq(...factorArgs) {\n    let factors = [];\n    for (let arg of factorArgs) {\n      if (!(arg instanceof PExpr)) {\n        arg = this.fromRecipe(arg);\n      }\n      if (arg instanceof Seq) {\n        factors = factors.concat(arg.factors);\n      } else {\n        factors.push(arg);\n      }\n    }\n    return factors.length === 1 ? factors[0] : new Seq(factors);\n  }\n\n  star(expr) {\n    if (!(expr instanceof PExpr)) {\n      expr = this.fromRecipe(expr);\n    }\n    return new Star(expr);\n  }\n\n  plus(expr) {\n    if (!(expr instanceof PExpr)) {\n      expr = this.fromRecipe(expr);\n    }\n    return new Plus(expr);\n  }\n\n  opt(expr) {\n    if (!(expr instanceof PExpr)) {\n      expr = this.fromRecipe(expr);\n    }\n    return new Opt(expr);\n  }\n\n  not(expr) {\n    if (!(expr instanceof PExpr)) {\n      expr = this.fromRecipe(expr);\n    }\n    return new Not(expr);\n  }\n\n  lookahead(expr) {\n    if (!(expr instanceof PExpr)) {\n      expr = this.fromRecipe(expr);\n    }\n    return new Lookahead(expr);\n  }\n\n  lex(expr) {\n    if (!(expr instanceof PExpr)) {\n      expr = this.fromRecipe(expr);\n    }\n    return new Lex(expr);\n  }\n\n  app(ruleName, optParams) {\n    if (optParams && optParams.length > 0) {\n      optParams = optParams.map(function(param) {\n        return param instanceof PExpr ? param : this.fromRecipe(param);\n      }, this);\n    }\n    return new Apply(ruleName, optParams);\n  }\n\n  // Note that unlike other methods in this class, this method cannot be used as a\n  // convenience constructor. It only works with recipes, because it relies on\n  // `this.currentDecl` and `this.currentRuleName` being set.\n  splice(beforeTerms, afterTerms) {\n    return new Splice(\n        this.currentDecl.superGrammar,\n        this.currentRuleName,\n        beforeTerms.map(term => this.fromRecipe(term)),\n        afterTerms.map(term => this.fromRecipe(term)),\n    );\n  }\n\n  fromRecipe(recipe) {\n    // the meta-info of 'grammar' is processed in Builder.grammar\n    const args = recipe[0] === 'grammar' ? recipe.slice(1) : recipe.slice(2);\n    const result = this[recipe[0]](...args);\n\n    const metaInfo = recipe[1];\n    if (metaInfo) {\n      if (metaInfo.sourceInterval && this.currentDecl) {\n        result.withSource(this.currentDecl.sourceInterval(...metaInfo.sourceInterval));\n      }\n    }\n    return result;\n  }\n}\n\nfunction makeRecipe(recipe) {\n  if (typeof recipe === 'function') {\n    return recipe.call(new Builder());\n  } else {\n    if (typeof recipe === 'string') {\n      // stringified JSON recipe\n      recipe = JSON.parse(recipe);\n    }\n    return new Builder().fromRecipe(recipe);\n  }\n}\n\nvar BuiltInRules$1 = makeRecipe([\"grammar\",{\"source\":\"BuiltInRules {\\n\\n  alnum  (an alpha-numeric character)\\n    = letter\\n    | digit\\n\\n  letter  (a letter)\\n    = lower\\n    | upper\\n    | unicodeLtmo\\n\\n  digit  (a digit)\\n    = \\\"0\\\"..\\\"9\\\"\\n\\n  hexDigit  (a hexadecimal digit)\\n    = digit\\n    | \\\"a\\\"..\\\"f\\\"\\n    | \\\"A\\\"..\\\"F\\\"\\n\\n  ListOf<elem, sep>\\n    = NonemptyListOf<elem, sep>\\n    | EmptyListOf<elem, sep>\\n\\n  NonemptyListOf<elem, sep>\\n    = elem (sep elem)*\\n\\n  EmptyListOf<elem, sep>\\n    = /* nothing */\\n\\n  listOf<elem, sep>\\n    = nonemptyListOf<elem, sep>\\n    | emptyListOf<elem, sep>\\n\\n  nonemptyListOf<elem, sep>\\n    = elem (sep elem)*\\n\\n  emptyListOf<elem, sep>\\n    = /* nothing */\\n\\n  // Allows a syntactic rule application within a lexical context.\\n  applySyntactic<app> = app\\n}\"},\"BuiltInRules\",null,null,{\"alnum\":[\"define\",{\"sourceInterval\":[18,78]},\"an alpha-numeric character\",[],[\"alt\",{\"sourceInterval\":[60,78]},[\"app\",{\"sourceInterval\":[60,66]},\"letter\",[]],[\"app\",{\"sourceInterval\":[73,78]},\"digit\",[]]]],\"letter\":[\"define\",{\"sourceInterval\":[82,142]},\"a letter\",[],[\"alt\",{\"sourceInterval\":[107,142]},[\"app\",{\"sourceInterval\":[107,112]},\"lower\",[]],[\"app\",{\"sourceInterval\":[119,124]},\"upper\",[]],[\"app\",{\"sourceInterval\":[131,142]},\"unicodeLtmo\",[]]]],\"digit\":[\"define\",{\"sourceInterval\":[146,177]},\"a digit\",[],[\"range\",{\"sourceInterval\":[169,177]},\"0\",\"9\"]],\"hexDigit\":[\"define\",{\"sourceInterval\":[181,254]},\"a hexadecimal digit\",[],[\"alt\",{\"sourceInterval\":[219,254]},[\"app\",{\"sourceInterval\":[219,224]},\"digit\",[]],[\"range\",{\"sourceInterval\":[231,239]},\"a\",\"f\"],[\"range\",{\"sourceInterval\":[246,254]},\"A\",\"F\"]]],\"ListOf\":[\"define\",{\"sourceInterval\":[258,336]},null,[\"elem\",\"sep\"],[\"alt\",{\"sourceInterval\":[282,336]},[\"app\",{\"sourceInterval\":[282,307]},\"NonemptyListOf\",[[\"param\",{\"sourceInterval\":[297,301]},0],[\"param\",{\"sourceInterval\":[303,306]},1]]],[\"app\",{\"sourceInterval\":[314,336]},\"EmptyListOf\",[[\"param\",{\"sourceInterval\":[326,330]},0],[\"param\",{\"sourceInterval\":[332,335]},1]]]]],\"NonemptyListOf\":[\"define\",{\"sourceInterval\":[340,388]},null,[\"elem\",\"sep\"],[\"seq\",{\"sourceInterval\":[372,388]},[\"param\",{\"sourceInterval\":[372,376]},0],[\"star\",{\"sourceInterval\":[377,388]},[\"seq\",{\"sourceInterval\":[378,386]},[\"param\",{\"sourceInterval\":[378,381]},1],[\"param\",{\"sourceInterval\":[382,386]},0]]]]],\"EmptyListOf\":[\"define\",{\"sourceInterval\":[392,434]},null,[\"elem\",\"sep\"],[\"seq\",{\"sourceInterval\":[438,438]}]],\"listOf\":[\"define\",{\"sourceInterval\":[438,516]},null,[\"elem\",\"sep\"],[\"alt\",{\"sourceInterval\":[462,516]},[\"app\",{\"sourceInterval\":[462,487]},\"nonemptyListOf\",[[\"param\",{\"sourceInterval\":[477,481]},0],[\"param\",{\"sourceInterval\":[483,486]},1]]],[\"app\",{\"sourceInterval\":[494,516]},\"emptyListOf\",[[\"param\",{\"sourceInterval\":[506,510]},0],[\"param\",{\"sourceInterval\":[512,515]},1]]]]],\"nonemptyListOf\":[\"define\",{\"sourceInterval\":[520,568]},null,[\"elem\",\"sep\"],[\"seq\",{\"sourceInterval\":[552,568]},[\"param\",{\"sourceInterval\":[552,556]},0],[\"star\",{\"sourceInterval\":[557,568]},[\"seq\",{\"sourceInterval\":[558,566]},[\"param\",{\"sourceInterval\":[558,561]},1],[\"param\",{\"sourceInterval\":[562,566]},0]]]]],\"emptyListOf\":[\"define\",{\"sourceInterval\":[572,682]},null,[\"elem\",\"sep\"],[\"seq\",{\"sourceInterval\":[685,685]}]],\"applySyntactic\":[\"define\",{\"sourceInterval\":[685,710]},null,[\"app\"],[\"param\",{\"sourceInterval\":[707,710]},0]]}]);\n\nGrammar.BuiltInRules = BuiltInRules$1;\nannounceBuiltInRules(Grammar.BuiltInRules);\n\nvar ohmGrammar$1 = makeRecipe([\"grammar\",{\"source\":\"Ohm {\\n\\n  Grammars\\n    = Grammar*\\n\\n  Grammar\\n    = ident SuperGrammar? \\\"{\\\" Rule* \\\"}\\\"\\n\\n  SuperGrammar\\n    = \\\"<:\\\" ident\\n\\n  Rule\\n    = ident Formals? ruleDescr? \\\"=\\\"  RuleBody  -- define\\n    | ident Formals?            \\\":=\\\" OverrideRuleBody  -- override\\n    | ident Formals?            \\\"+=\\\" RuleBody  -- extend\\n\\n  RuleBody\\n    = \\\"|\\\"? NonemptyListOf<TopLevelTerm, \\\"|\\\">\\n\\n  TopLevelTerm\\n    = Seq caseName  -- inline\\n    | Seq\\n\\n  OverrideRuleBody\\n    = \\\"|\\\"? NonemptyListOf<OverrideTopLevelTerm, \\\"|\\\">\\n\\n  OverrideTopLevelTerm\\n    = \\\"...\\\"  -- superSplice\\n    | TopLevelTerm\\n\\n  Formals\\n    = \\\"<\\\" ListOf<ident, \\\",\\\"> \\\">\\\"\\n\\n  Params\\n    = \\\"<\\\" ListOf<Seq, \\\",\\\"> \\\">\\\"\\n\\n  Alt\\n    = NonemptyListOf<Seq, \\\"|\\\">\\n\\n  Seq\\n    = Iter*\\n\\n  Iter\\n    = Pred \\\"*\\\"  -- star\\n    | Pred \\\"+\\\"  -- plus\\n    | Pred \\\"?\\\"  -- opt\\n    | Pred\\n\\n  Pred\\n    = \\\"~\\\" Lex  -- not\\n    | \\\"&\\\" Lex  -- lookahead\\n    | Lex\\n\\n  Lex\\n    = \\\"#\\\" Base  -- lex\\n    | Base\\n\\n  Base\\n    = ident Params? ~(ruleDescr? \\\"=\\\" | \\\":=\\\" | \\\"+=\\\")  -- application\\n    | oneCharTerminal \\\"..\\\" oneCharTerminal           -- range\\n    | terminal                                       -- terminal\\n    | \\\"(\\\" Alt \\\")\\\"                                    -- paren\\n\\n  ruleDescr  (a rule description)\\n    = \\\"(\\\" ruleDescrText \\\")\\\"\\n\\n  ruleDescrText\\n    = (~\\\")\\\" any)*\\n\\n  caseName\\n    = \\\"--\\\" (~\\\"\\\\n\\\" space)* name (~\\\"\\\\n\\\" space)* (\\\"\\\\n\\\" | &\\\"}\\\")\\n\\n  name  (a name)\\n    = nameFirst nameRest*\\n\\n  nameFirst\\n    = \\\"_\\\"\\n    | letter\\n\\n  nameRest\\n    = \\\"_\\\"\\n    | alnum\\n\\n  ident  (an identifier)\\n    = name\\n\\n  terminal\\n    = \\\"\\\\\\\"\\\" terminalChar* \\\"\\\\\\\"\\\"\\n\\n  oneCharTerminal\\n    = \\\"\\\\\\\"\\\" terminalChar \\\"\\\\\\\"\\\"\\n\\n  terminalChar\\n    = escapeChar\\n      | ~\\\"\\\\\\\\\\\" ~\\\"\\\\\\\"\\\" ~\\\"\\\\n\\\" \\\"\\\\u{0}\\\"..\\\"\\\\u{10FFFF}\\\"\\n\\n  escapeChar  (an escape sequence)\\n    = \\\"\\\\\\\\\\\\\\\\\\\"                                     -- backslash\\n    | \\\"\\\\\\\\\\\\\\\"\\\"                                     -- doubleQuote\\n    | \\\"\\\\\\\\\\\\'\\\"                                     -- singleQuote\\n    | \\\"\\\\\\\\b\\\"                                      -- backspace\\n    | \\\"\\\\\\\\n\\\"                                      -- lineFeed\\n    | \\\"\\\\\\\\r\\\"                                      -- carriageReturn\\n    | \\\"\\\\\\\\t\\\"                                      -- tab\\n    | \\\"\\\\\\\\u{\\\" hexDigit hexDigit? hexDigit?\\n             hexDigit? hexDigit? hexDigit? \\\"}\\\"   -- unicodeCodePoint\\n    | \\\"\\\\\\\\u\\\" hexDigit hexDigit hexDigit hexDigit  -- unicodeEscape\\n    | \\\"\\\\\\\\x\\\" hexDigit hexDigit                    -- hexEscape\\n\\n  space\\n   += comment\\n\\n  comment\\n    = \\\"//\\\" (~\\\"\\\\n\\\" any)* &(\\\"\\\\n\\\" | end)  -- singleLine\\n    | \\\"/*\\\" (~\\\"*/\\\" any)* \\\"*/\\\"  -- multiLine\\n\\n  tokens = token*\\n\\n  token = caseName | comment | ident | operator | punctuation | terminal | any\\n\\n  operator = \\\"<:\\\" | \\\"=\\\" | \\\":=\\\" | \\\"+=\\\" | \\\"*\\\" | \\\"+\\\" | \\\"?\\\" | \\\"~\\\" | \\\"&\\\"\\n\\n  punctuation = \\\"<\\\" | \\\">\\\" | \\\",\\\" | \\\"--\\\"\\n}\"},\"Ohm\",null,\"Grammars\",{\"Grammars\":[\"define\",{\"sourceInterval\":[9,32]},null,[],[\"star\",{\"sourceInterval\":[24,32]},[\"app\",{\"sourceInterval\":[24,31]},\"Grammar\",[]]]],\"Grammar\":[\"define\",{\"sourceInterval\":[36,83]},null,[],[\"seq\",{\"sourceInterval\":[50,83]},[\"app\",{\"sourceInterval\":[50,55]},\"ident\",[]],[\"opt\",{\"sourceInterval\":[56,69]},[\"app\",{\"sourceInterval\":[56,68]},\"SuperGrammar\",[]]],[\"terminal\",{\"sourceInterval\":[70,73]},\"{\"],[\"star\",{\"sourceInterval\":[74,79]},[\"app\",{\"sourceInterval\":[74,78]},\"Rule\",[]]],[\"terminal\",{\"sourceInterval\":[80,83]},\"}\"]]],\"SuperGrammar\":[\"define\",{\"sourceInterval\":[87,116]},null,[],[\"seq\",{\"sourceInterval\":[106,116]},[\"terminal\",{\"sourceInterval\":[106,110]},\"<:\"],[\"app\",{\"sourceInterval\":[111,116]},\"ident\",[]]]],\"Rule_define\":[\"define\",{\"sourceInterval\":[131,181]},null,[],[\"seq\",{\"sourceInterval\":[131,170]},[\"app\",{\"sourceInterval\":[131,136]},\"ident\",[]],[\"opt\",{\"sourceInterval\":[137,145]},[\"app\",{\"sourceInterval\":[137,144]},\"Formals\",[]]],[\"opt\",{\"sourceInterval\":[146,156]},[\"app\",{\"sourceInterval\":[146,155]},\"ruleDescr\",[]]],[\"terminal\",{\"sourceInterval\":[157,160]},\"=\"],[\"app\",{\"sourceInterval\":[162,170]},\"RuleBody\",[]]]],\"Rule_override\":[\"define\",{\"sourceInterval\":[188,248]},null,[],[\"seq\",{\"sourceInterval\":[188,235]},[\"app\",{\"sourceInterval\":[188,193]},\"ident\",[]],[\"opt\",{\"sourceInterval\":[194,202]},[\"app\",{\"sourceInterval\":[194,201]},\"Formals\",[]]],[\"terminal\",{\"sourceInterval\":[214,218]},\":=\"],[\"app\",{\"sourceInterval\":[219,235]},\"OverrideRuleBody\",[]]]],\"Rule_extend\":[\"define\",{\"sourceInterval\":[255,305]},null,[],[\"seq\",{\"sourceInterval\":[255,294]},[\"app\",{\"sourceInterval\":[255,260]},\"ident\",[]],[\"opt\",{\"sourceInterval\":[261,269]},[\"app\",{\"sourceInterval\":[261,268]},\"Formals\",[]]],[\"terminal\",{\"sourceInterval\":[281,285]},\"+=\"],[\"app\",{\"sourceInterval\":[286,294]},\"RuleBody\",[]]]],\"Rule\":[\"define\",{\"sourceInterval\":[120,305]},null,[],[\"alt\",{\"sourceInterval\":[131,305]},[\"app\",{\"sourceInterval\":[131,170]},\"Rule_define\",[]],[\"app\",{\"sourceInterval\":[188,235]},\"Rule_override\",[]],[\"app\",{\"sourceInterval\":[255,294]},\"Rule_extend\",[]]]],\"RuleBody\":[\"define\",{\"sourceInterval\":[309,362]},null,[],[\"seq\",{\"sourceInterval\":[324,362]},[\"opt\",{\"sourceInterval\":[324,328]},[\"terminal\",{\"sourceInterval\":[324,327]},\"|\"]],[\"app\",{\"sourceInterval\":[329,362]},\"NonemptyListOf\",[[\"app\",{\"sourceInterval\":[344,356]},\"TopLevelTerm\",[]],[\"terminal\",{\"sourceInterval\":[358,361]},\"|\"]]]]],\"TopLevelTerm_inline\":[\"define\",{\"sourceInterval\":[385,408]},null,[],[\"seq\",{\"sourceInterval\":[385,397]},[\"app\",{\"sourceInterval\":[385,388]},\"Seq\",[]],[\"app\",{\"sourceInterval\":[389,397]},\"caseName\",[]]]],\"TopLevelTerm\":[\"define\",{\"sourceInterval\":[366,418]},null,[],[\"alt\",{\"sourceInterval\":[385,418]},[\"app\",{\"sourceInterval\":[385,397]},\"TopLevelTerm_inline\",[]],[\"app\",{\"sourceInterval\":[415,418]},\"Seq\",[]]]],\"OverrideRuleBody\":[\"define\",{\"sourceInterval\":[422,491]},null,[],[\"seq\",{\"sourceInterval\":[445,491]},[\"opt\",{\"sourceInterval\":[445,449]},[\"terminal\",{\"sourceInterval\":[445,448]},\"|\"]],[\"app\",{\"sourceInterval\":[450,491]},\"NonemptyListOf\",[[\"app\",{\"sourceInterval\":[465,485]},\"OverrideTopLevelTerm\",[]],[\"terminal\",{\"sourceInterval\":[487,490]},\"|\"]]]]],\"OverrideTopLevelTerm_superSplice\":[\"define\",{\"sourceInterval\":[522,543]},null,[],[\"terminal\",{\"sourceInterval\":[522,527]},\"...\"]],\"OverrideTopLevelTerm\":[\"define\",{\"sourceInterval\":[495,562]},null,[],[\"alt\",{\"sourceInterval\":[522,562]},[\"app\",{\"sourceInterval\":[522,527]},\"OverrideTopLevelTerm_superSplice\",[]],[\"app\",{\"sourceInterval\":[550,562]},\"TopLevelTerm\",[]]]],\"Formals\":[\"define\",{\"sourceInterval\":[566,606]},null,[],[\"seq\",{\"sourceInterval\":[580,606]},[\"terminal\",{\"sourceInterval\":[580,583]},\"<\"],[\"app\",{\"sourceInterval\":[584,602]},\"ListOf\",[[\"app\",{\"sourceInterval\":[591,596]},\"ident\",[]],[\"terminal\",{\"sourceInterval\":[598,601]},\",\"]]],[\"terminal\",{\"sourceInterval\":[603,606]},\">\"]]],\"Params\":[\"define\",{\"sourceInterval\":[610,647]},null,[],[\"seq\",{\"sourceInterval\":[623,647]},[\"terminal\",{\"sourceInterval\":[623,626]},\"<\"],[\"app\",{\"sourceInterval\":[627,643]},\"ListOf\",[[\"app\",{\"sourceInterval\":[634,637]},\"Seq\",[]],[\"terminal\",{\"sourceInterval\":[639,642]},\",\"]]],[\"terminal\",{\"sourceInterval\":[644,647]},\">\"]]],\"Alt\":[\"define\",{\"sourceInterval\":[651,685]},null,[],[\"app\",{\"sourceInterval\":[661,685]},\"NonemptyListOf\",[[\"app\",{\"sourceInterval\":[676,679]},\"Seq\",[]],[\"terminal\",{\"sourceInterval\":[681,684]},\"|\"]]]],\"Seq\":[\"define\",{\"sourceInterval\":[689,704]},null,[],[\"star\",{\"sourceInterval\":[699,704]},[\"app\",{\"sourceInterval\":[699,703]},\"Iter\",[]]]],\"Iter_star\":[\"define\",{\"sourceInterval\":[719,736]},null,[],[\"seq\",{\"sourceInterval\":[719,727]},[\"app\",{\"sourceInterval\":[719,723]},\"Pred\",[]],[\"terminal\",{\"sourceInterval\":[724,727]},\"*\"]]],\"Iter_plus\":[\"define\",{\"sourceInterval\":[743,760]},null,[],[\"seq\",{\"sourceInterval\":[743,751]},[\"app\",{\"sourceInterval\":[743,747]},\"Pred\",[]],[\"terminal\",{\"sourceInterval\":[748,751]},\"+\"]]],\"Iter_opt\":[\"define\",{\"sourceInterval\":[767,783]},null,[],[\"seq\",{\"sourceInterval\":[767,775]},[\"app\",{\"sourceInterval\":[767,771]},\"Pred\",[]],[\"terminal\",{\"sourceInterval\":[772,775]},\"?\"]]],\"Iter\":[\"define\",{\"sourceInterval\":[708,794]},null,[],[\"alt\",{\"sourceInterval\":[719,794]},[\"app\",{\"sourceInterval\":[719,727]},\"Iter_star\",[]],[\"app\",{\"sourceInterval\":[743,751]},\"Iter_plus\",[]],[\"app\",{\"sourceInterval\":[767,775]},\"Iter_opt\",[]],[\"app\",{\"sourceInterval\":[790,794]},\"Pred\",[]]]],\"Pred_not\":[\"define\",{\"sourceInterval\":[809,824]},null,[],[\"seq\",{\"sourceInterval\":[809,816]},[\"terminal\",{\"sourceInterval\":[809,812]},\"~\"],[\"app\",{\"sourceInterval\":[813,816]},\"Lex\",[]]]],\"Pred_lookahead\":[\"define\",{\"sourceInterval\":[831,852]},null,[],[\"seq\",{\"sourceInterval\":[831,838]},[\"terminal\",{\"sourceInterval\":[831,834]},\"&\"],[\"app\",{\"sourceInterval\":[835,838]},\"Lex\",[]]]],\"Pred\":[\"define\",{\"sourceInterval\":[798,862]},null,[],[\"alt\",{\"sourceInterval\":[809,862]},[\"app\",{\"sourceInterval\":[809,816]},\"Pred_not\",[]],[\"app\",{\"sourceInterval\":[831,838]},\"Pred_lookahead\",[]],[\"app\",{\"sourceInterval\":[859,862]},\"Lex\",[]]]],\"Lex_lex\":[\"define\",{\"sourceInterval\":[876,892]},null,[],[\"seq\",{\"sourceInterval\":[876,884]},[\"terminal\",{\"sourceInterval\":[876,879]},\"#\"],[\"app\",{\"sourceInterval\":[880,884]},\"Base\",[]]]],\"Lex\":[\"define\",{\"sourceInterval\":[866,903]},null,[],[\"alt\",{\"sourceInterval\":[876,903]},[\"app\",{\"sourceInterval\":[876,884]},\"Lex_lex\",[]],[\"app\",{\"sourceInterval\":[899,903]},\"Base\",[]]]],\"Base_application\":[\"define\",{\"sourceInterval\":[918,979]},null,[],[\"seq\",{\"sourceInterval\":[918,963]},[\"app\",{\"sourceInterval\":[918,923]},\"ident\",[]],[\"opt\",{\"sourceInterval\":[924,931]},[\"app\",{\"sourceInterval\":[924,930]},\"Params\",[]]],[\"not\",{\"sourceInterval\":[932,963]},[\"alt\",{\"sourceInterval\":[934,962]},[\"seq\",{\"sourceInterval\":[934,948]},[\"opt\",{\"sourceInterval\":[934,944]},[\"app\",{\"sourceInterval\":[934,943]},\"ruleDescr\",[]]],[\"terminal\",{\"sourceInterval\":[945,948]},\"=\"]],[\"terminal\",{\"sourceInterval\":[951,955]},\":=\"],[\"terminal\",{\"sourceInterval\":[958,962]},\"+=\"]]]]],\"Base_range\":[\"define\",{\"sourceInterval\":[986,1041]},null,[],[\"seq\",{\"sourceInterval\":[986,1022]},[\"app\",{\"sourceInterval\":[986,1001]},\"oneCharTerminal\",[]],[\"terminal\",{\"sourceInterval\":[1002,1006]},\"..\"],[\"app\",{\"sourceInterval\":[1007,1022]},\"oneCharTerminal\",[]]]],\"Base_terminal\":[\"define\",{\"sourceInterval\":[1048,1106]},null,[],[\"app\",{\"sourceInterval\":[1048,1056]},\"terminal\",[]]],\"Base_paren\":[\"define\",{\"sourceInterval\":[1113,1168]},null,[],[\"seq\",{\"sourceInterval\":[1113,1124]},[\"terminal\",{\"sourceInterval\":[1113,1116]},\"(\"],[\"app\",{\"sourceInterval\":[1117,1120]},\"Alt\",[]],[\"terminal\",{\"sourceInterval\":[1121,1124]},\")\"]]],\"Base\":[\"define\",{\"sourceInterval\":[907,1168]},null,[],[\"alt\",{\"sourceInterval\":[918,1168]},[\"app\",{\"sourceInterval\":[918,963]},\"Base_application\",[]],[\"app\",{\"sourceInterval\":[986,1022]},\"Base_range\",[]],[\"app\",{\"sourceInterval\":[1048,1056]},\"Base_terminal\",[]],[\"app\",{\"sourceInterval\":[1113,1124]},\"Base_paren\",[]]]],\"ruleDescr\":[\"define\",{\"sourceInterval\":[1172,1231]},\"a rule description\",[],[\"seq\",{\"sourceInterval\":[1210,1231]},[\"terminal\",{\"sourceInterval\":[1210,1213]},\"(\"],[\"app\",{\"sourceInterval\":[1214,1227]},\"ruleDescrText\",[]],[\"terminal\",{\"sourceInterval\":[1228,1231]},\")\"]]],\"ruleDescrText\":[\"define\",{\"sourceInterval\":[1235,1266]},null,[],[\"star\",{\"sourceInterval\":[1255,1266]},[\"seq\",{\"sourceInterval\":[1256,1264]},[\"not\",{\"sourceInterval\":[1256,1260]},[\"terminal\",{\"sourceInterval\":[1257,1260]},\")\"]],[\"app\",{\"sourceInterval\":[1261,1264]},\"any\",[]]]]],\"caseName\":[\"define\",{\"sourceInterval\":[1270,1338]},null,[],[\"seq\",{\"sourceInterval\":[1285,1338]},[\"terminal\",{\"sourceInterval\":[1285,1289]},\"--\"],[\"star\",{\"sourceInterval\":[1290,1304]},[\"seq\",{\"sourceInterval\":[1291,1302]},[\"not\",{\"sourceInterval\":[1291,1296]},[\"terminal\",{\"sourceInterval\":[1292,1296]},\"\\n\"]],[\"app\",{\"sourceInterval\":[1297,1302]},\"space\",[]]]],[\"app\",{\"sourceInterval\":[1305,1309]},\"name\",[]],[\"star\",{\"sourceInterval\":[1310,1324]},[\"seq\",{\"sourceInterval\":[1311,1322]},[\"not\",{\"sourceInterval\":[1311,1316]},[\"terminal\",{\"sourceInterval\":[1312,1316]},\"\\n\"]],[\"app\",{\"sourceInterval\":[1317,1322]},\"space\",[]]]],[\"alt\",{\"sourceInterval\":[1326,1337]},[\"terminal\",{\"sourceInterval\":[1326,1330]},\"\\n\"],[\"lookahead\",{\"sourceInterval\":[1333,1337]},[\"terminal\",{\"sourceInterval\":[1334,1337]},\"}\"]]]]],\"name\":[\"define\",{\"sourceInterval\":[1342,1382]},\"a name\",[],[\"seq\",{\"sourceInterval\":[1363,1382]},[\"app\",{\"sourceInterval\":[1363,1372]},\"nameFirst\",[]],[\"star\",{\"sourceInterval\":[1373,1382]},[\"app\",{\"sourceInterval\":[1373,1381]},\"nameRest\",[]]]]],\"nameFirst\":[\"define\",{\"sourceInterval\":[1386,1418]},null,[],[\"alt\",{\"sourceInterval\":[1402,1418]},[\"terminal\",{\"sourceInterval\":[1402,1405]},\"_\"],[\"app\",{\"sourceInterval\":[1412,1418]},\"letter\",[]]]],\"nameRest\":[\"define\",{\"sourceInterval\":[1422,1452]},null,[],[\"alt\",{\"sourceInterval\":[1437,1452]},[\"terminal\",{\"sourceInterval\":[1437,1440]},\"_\"],[\"app\",{\"sourceInterval\":[1447,1452]},\"alnum\",[]]]],\"ident\":[\"define\",{\"sourceInterval\":[1456,1489]},\"an identifier\",[],[\"app\",{\"sourceInterval\":[1485,1489]},\"name\",[]]],\"terminal\":[\"define\",{\"sourceInterval\":[1493,1531]},null,[],[\"seq\",{\"sourceInterval\":[1508,1531]},[\"terminal\",{\"sourceInterval\":[1508,1512]},\"\\\"\"],[\"star\",{\"sourceInterval\":[1513,1526]},[\"app\",{\"sourceInterval\":[1513,1525]},\"terminalChar\",[]]],[\"terminal\",{\"sourceInterval\":[1527,1531]},\"\\\"\"]]],\"oneCharTerminal\":[\"define\",{\"sourceInterval\":[1535,1579]},null,[],[\"seq\",{\"sourceInterval\":[1557,1579]},[\"terminal\",{\"sourceInterval\":[1557,1561]},\"\\\"\"],[\"app\",{\"sourceInterval\":[1562,1574]},\"terminalChar\",[]],[\"terminal\",{\"sourceInterval\":[1575,1579]},\"\\\"\"]]],\"terminalChar\":[\"define\",{\"sourceInterval\":[1583,1660]},null,[],[\"alt\",{\"sourceInterval\":[1602,1660]},[\"app\",{\"sourceInterval\":[1602,1612]},\"escapeChar\",[]],[\"seq\",{\"sourceInterval\":[1621,1660]},[\"not\",{\"sourceInterval\":[1621,1626]},[\"terminal\",{\"sourceInterval\":[1622,1626]},\"\\\\\"]],[\"not\",{\"sourceInterval\":[1627,1632]},[\"terminal\",{\"sourceInterval\":[1628,1632]},\"\\\"\"]],[\"not\",{\"sourceInterval\":[1633,1638]},[\"terminal\",{\"sourceInterval\":[1634,1638]},\"\\n\"]],[\"range\",{\"sourceInterval\":[1639,1660]},\"\\u0000\",\"\"]]]],\"escapeChar_backslash\":[\"define\",{\"sourceInterval\":[1703,1758]},null,[],[\"terminal\",{\"sourceInterval\":[1703,1709]},\"\\\\\\\\\"]],\"escapeChar_doubleQuote\":[\"define\",{\"sourceInterval\":[1765,1822]},null,[],[\"terminal\",{\"sourceInterval\":[1765,1771]},\"\\\\\\\"\"]],\"escapeChar_singleQuote\":[\"define\",{\"sourceInterval\":[1829,1886]},null,[],[\"terminal\",{\"sourceInterval\":[1829,1835]},\"\\\\'\"]],\"escapeChar_backspace\":[\"define\",{\"sourceInterval\":[1893,1948]},null,[],[\"terminal\",{\"sourceInterval\":[1893,1898]},\"\\\\b\"]],\"escapeChar_lineFeed\":[\"define\",{\"sourceInterval\":[1955,2009]},null,[],[\"terminal\",{\"sourceInterval\":[1955,1960]},\"\\\\n\"]],\"escapeChar_carriageReturn\":[\"define\",{\"sourceInterval\":[2016,2076]},null,[],[\"terminal\",{\"sourceInterval\":[2016,2021]},\"\\\\r\"]],\"escapeChar_tab\":[\"define\",{\"sourceInterval\":[2083,2132]},null,[],[\"terminal\",{\"sourceInterval\":[2083,2088]},\"\\\\t\"]],\"escapeChar_unicodeCodePoint\":[\"define\",{\"sourceInterval\":[2139,2243]},null,[],[\"seq\",{\"sourceInterval\":[2139,2221]},[\"terminal\",{\"sourceInterval\":[2139,2145]},\"\\\\u{\"],[\"app\",{\"sourceInterval\":[2146,2154]},\"hexDigit\",[]],[\"opt\",{\"sourceInterval\":[2155,2164]},[\"app\",{\"sourceInterval\":[2155,2163]},\"hexDigit\",[]]],[\"opt\",{\"sourceInterval\":[2165,2174]},[\"app\",{\"sourceInterval\":[2165,2173]},\"hexDigit\",[]]],[\"opt\",{\"sourceInterval\":[2188,2197]},[\"app\",{\"sourceInterval\":[2188,2196]},\"hexDigit\",[]]],[\"opt\",{\"sourceInterval\":[2198,2207]},[\"app\",{\"sourceInterval\":[2198,2206]},\"hexDigit\",[]]],[\"opt\",{\"sourceInterval\":[2208,2217]},[\"app\",{\"sourceInterval\":[2208,2216]},\"hexDigit\",[]]],[\"terminal\",{\"sourceInterval\":[2218,2221]},\"}\"]]],\"escapeChar_unicodeEscape\":[\"define\",{\"sourceInterval\":[2250,2309]},null,[],[\"seq\",{\"sourceInterval\":[2250,2291]},[\"terminal\",{\"sourceInterval\":[2250,2255]},\"\\\\u\"],[\"app\",{\"sourceInterval\":[2256,2264]},\"hexDigit\",[]],[\"app\",{\"sourceInterval\":[2265,2273]},\"hexDigit\",[]],[\"app\",{\"sourceInterval\":[2274,2282]},\"hexDigit\",[]],[\"app\",{\"sourceInterval\":[2283,2291]},\"hexDigit\",[]]]],\"escapeChar_hexEscape\":[\"define\",{\"sourceInterval\":[2316,2371]},null,[],[\"seq\",{\"sourceInterval\":[2316,2339]},[\"terminal\",{\"sourceInterval\":[2316,2321]},\"\\\\x\"],[\"app\",{\"sourceInterval\":[2322,2330]},\"hexDigit\",[]],[\"app\",{\"sourceInterval\":[2331,2339]},\"hexDigit\",[]]]],\"escapeChar\":[\"define\",{\"sourceInterval\":[1664,2371]},\"an escape sequence\",[],[\"alt\",{\"sourceInterval\":[1703,2371]},[\"app\",{\"sourceInterval\":[1703,1709]},\"escapeChar_backslash\",[]],[\"app\",{\"sourceInterval\":[1765,1771]},\"escapeChar_doubleQuote\",[]],[\"app\",{\"sourceInterval\":[1829,1835]},\"escapeChar_singleQuote\",[]],[\"app\",{\"sourceInterval\":[1893,1898]},\"escapeChar_backspace\",[]],[\"app\",{\"sourceInterval\":[1955,1960]},\"escapeChar_lineFeed\",[]],[\"app\",{\"sourceInterval\":[2016,2021]},\"escapeChar_carriageReturn\",[]],[\"app\",{\"sourceInterval\":[2083,2088]},\"escapeChar_tab\",[]],[\"app\",{\"sourceInterval\":[2139,2221]},\"escapeChar_unicodeCodePoint\",[]],[\"app\",{\"sourceInterval\":[2250,2291]},\"escapeChar_unicodeEscape\",[]],[\"app\",{\"sourceInterval\":[2316,2339]},\"escapeChar_hexEscape\",[]]]],\"space\":[\"extend\",{\"sourceInterval\":[2375,2394]},null,[],[\"app\",{\"sourceInterval\":[2387,2394]},\"comment\",[]]],\"comment_singleLine\":[\"define\",{\"sourceInterval\":[2412,2458]},null,[],[\"seq\",{\"sourceInterval\":[2412,2443]},[\"terminal\",{\"sourceInterval\":[2412,2416]},\"//\"],[\"star\",{\"sourceInterval\":[2417,2429]},[\"seq\",{\"sourceInterval\":[2418,2427]},[\"not\",{\"sourceInterval\":[2418,2423]},[\"terminal\",{\"sourceInterval\":[2419,2423]},\"\\n\"]],[\"app\",{\"sourceInterval\":[2424,2427]},\"any\",[]]]],[\"lookahead\",{\"sourceInterval\":[2430,2443]},[\"alt\",{\"sourceInterval\":[2432,2442]},[\"terminal\",{\"sourceInterval\":[2432,2436]},\"\\n\"],[\"app\",{\"sourceInterval\":[2439,2442]},\"end\",[]]]]]],\"comment_multiLine\":[\"define\",{\"sourceInterval\":[2465,2501]},null,[],[\"seq\",{\"sourceInterval\":[2465,2487]},[\"terminal\",{\"sourceInterval\":[2465,2469]},\"/*\"],[\"star\",{\"sourceInterval\":[2470,2482]},[\"seq\",{\"sourceInterval\":[2471,2480]},[\"not\",{\"sourceInterval\":[2471,2476]},[\"terminal\",{\"sourceInterval\":[2472,2476]},\"*/\"]],[\"app\",{\"sourceInterval\":[2477,2480]},\"any\",[]]]],[\"terminal\",{\"sourceInterval\":[2483,2487]},\"*/\"]]],\"comment\":[\"define\",{\"sourceInterval\":[2398,2501]},null,[],[\"alt\",{\"sourceInterval\":[2412,2501]},[\"app\",{\"sourceInterval\":[2412,2443]},\"comment_singleLine\",[]],[\"app\",{\"sourceInterval\":[2465,2487]},\"comment_multiLine\",[]]]],\"tokens\":[\"define\",{\"sourceInterval\":[2505,2520]},null,[],[\"star\",{\"sourceInterval\":[2514,2520]},[\"app\",{\"sourceInterval\":[2514,2519]},\"token\",[]]]],\"token\":[\"define\",{\"sourceInterval\":[2524,2600]},null,[],[\"alt\",{\"sourceInterval\":[2532,2600]},[\"app\",{\"sourceInterval\":[2532,2540]},\"caseName\",[]],[\"app\",{\"sourceInterval\":[2543,2550]},\"comment\",[]],[\"app\",{\"sourceInterval\":[2553,2558]},\"ident\",[]],[\"app\",{\"sourceInterval\":[2561,2569]},\"operator\",[]],[\"app\",{\"sourceInterval\":[2572,2583]},\"punctuation\",[]],[\"app\",{\"sourceInterval\":[2586,2594]},\"terminal\",[]],[\"app\",{\"sourceInterval\":[2597,2600]},\"any\",[]]]],\"operator\":[\"define\",{\"sourceInterval\":[2604,2669]},null,[],[\"alt\",{\"sourceInterval\":[2615,2669]},[\"terminal\",{\"sourceInterval\":[2615,2619]},\"<:\"],[\"terminal\",{\"sourceInterval\":[2622,2625]},\"=\"],[\"terminal\",{\"sourceInterval\":[2628,2632]},\":=\"],[\"terminal\",{\"sourceInterval\":[2635,2639]},\"+=\"],[\"terminal\",{\"sourceInterval\":[2642,2645]},\"*\"],[\"terminal\",{\"sourceInterval\":[2648,2651]},\"+\"],[\"terminal\",{\"sourceInterval\":[2654,2657]},\"?\"],[\"terminal\",{\"sourceInterval\":[2660,2663]},\"~\"],[\"terminal\",{\"sourceInterval\":[2666,2669]},\"&\"]]],\"punctuation\":[\"define\",{\"sourceInterval\":[2673,2709]},null,[],[\"alt\",{\"sourceInterval\":[2687,2709]},[\"terminal\",{\"sourceInterval\":[2687,2690]},\"<\"],[\"terminal\",{\"sourceInterval\":[2693,2696]},\">\"],[\"terminal\",{\"sourceInterval\":[2699,2702]},\",\"],[\"terminal\",{\"sourceInterval\":[2705,2709]},\"--\"]]]}]);\n\nconst superSplicePlaceholder = Object.create(PExpr.prototype);\n\nfunction namespaceHas(ns, name) {\n  // Look for an enumerable property, anywhere in the prototype chain.\n  for (const prop in ns) {\n    if (prop === name) return true;\n  }\n  return false;\n}\n\n// Returns a Grammar instance (i.e., an object with a `match` method) for\n// `tree`, which is the concrete syntax tree of a user-written grammar.\n// The grammar will be assigned into `namespace` under the name of the grammar\n// as specified in the source.\nfunction buildGrammar$1(match, namespace, optOhmGrammarForTesting) {\n  const builder = new Builder();\n  let decl;\n  let currentRuleName;\n  let currentRuleFormals;\n  let overriding = false;\n  const metaGrammar = optOhmGrammarForTesting || ohmGrammar$1;\n\n  // A visitor that produces a Grammar instance from the CST.\n  const helpers = metaGrammar.createSemantics().addOperation('visit', {\n    Grammars(grammarIter) {\n      return grammarIter.children.map(c => c.visit());\n    },\n    Grammar(id, s, _open, rules, _close) {\n      const grammarName = id.visit();\n      decl = builder.newGrammar(grammarName);\n      s.child(0) && s.child(0).visit();\n      rules.children.map(c => c.visit());\n      const g = decl.build();\n      g.source = this.source.trimmed();\n      if (namespaceHas(namespace, grammarName)) {\n        throw duplicateGrammarDeclaration(g);\n      }\n      namespace[grammarName] = g;\n      return g;\n    },\n\n    SuperGrammar(_, n) {\n      const superGrammarName = n.visit();\n      if (superGrammarName === 'null') {\n        decl.withSuperGrammar(null);\n      } else {\n        if (!namespace || !namespaceHas(namespace, superGrammarName)) {\n          throw undeclaredGrammar(superGrammarName, namespace, n.source);\n        }\n        decl.withSuperGrammar(namespace[superGrammarName]);\n      }\n    },\n\n    Rule_define(n, fs, d, _, b) {\n      currentRuleName = n.visit();\n      currentRuleFormals = fs.children.map(c => c.visit())[0] || [];\n      // If there is no default start rule yet, set it now. This must be done before visiting\n      // the body, because it might contain an inline rule definition.\n      if (!decl.defaultStartRule && decl.ensureSuperGrammar() !== Grammar.ProtoBuiltInRules) {\n        decl.withDefaultStartRule(currentRuleName);\n      }\n      const body = b.visit();\n      const description = d.children.map(c => c.visit())[0];\n      const source = this.source.trimmed();\n      return decl.define(currentRuleName, currentRuleFormals, body, description, source);\n    },\n    Rule_override(n, fs, _, b) {\n      currentRuleName = n.visit();\n      currentRuleFormals = fs.children.map(c => c.visit())[0] || [];\n\n      const source = this.source.trimmed();\n      decl.ensureSuperGrammarRuleForOverriding(currentRuleName, source);\n\n      overriding = true;\n      const body = b.visit();\n      overriding = false;\n      return decl.override(currentRuleName, currentRuleFormals, body, null, source);\n    },\n    Rule_extend(n, fs, _, b) {\n      currentRuleName = n.visit();\n      currentRuleFormals = fs.children.map(c => c.visit())[0] || [];\n      const body = b.visit();\n      const source = this.source.trimmed();\n      return decl.extend(currentRuleName, currentRuleFormals, body, null, source);\n    },\n    RuleBody(_, terms) {\n      return builder.alt(...terms.visit()).withSource(this.source);\n    },\n    OverrideRuleBody(_, terms) {\n      const args = terms.visit();\n\n      // Check if the super-splice operator (`...`) appears in the terms.\n      const expansionPos = args.indexOf(superSplicePlaceholder);\n      if (expansionPos >= 0) {\n        const beforeTerms = args.slice(0, expansionPos);\n        const afterTerms = args.slice(expansionPos + 1);\n\n        // Ensure it appears no more than once.\n        afterTerms.forEach(t => {\n          if (t === superSplicePlaceholder) throw multipleSuperSplices(t);\n        });\n\n        return new Splice(\n            decl.superGrammar,\n            currentRuleName,\n            beforeTerms,\n            afterTerms,\n        ).withSource(this.source);\n      } else {\n        return builder.alt(...args).withSource(this.source);\n      }\n    },\n    Formals(opointy, fs, cpointy) {\n      return fs.visit();\n    },\n\n    Params(opointy, ps, cpointy) {\n      return ps.visit();\n    },\n\n    Alt(seqs) {\n      return builder.alt(...seqs.visit()).withSource(this.source);\n    },\n\n    TopLevelTerm_inline(b, n) {\n      const inlineRuleName = currentRuleName + '_' + n.visit();\n      const body = b.visit();\n      const source = this.source.trimmed();\n      const isNewRuleDeclaration = !(\n        decl.superGrammar && decl.superGrammar.rules[inlineRuleName]\n      );\n      if (overriding && !isNewRuleDeclaration) {\n        decl.override(inlineRuleName, currentRuleFormals, body, null, source);\n      } else {\n        decl.define(inlineRuleName, currentRuleFormals, body, null, source);\n      }\n      const params = currentRuleFormals.map(formal => builder.app(formal));\n      return builder.app(inlineRuleName, params).withSource(body.source);\n    },\n    OverrideTopLevelTerm_superSplice(_) {\n      return superSplicePlaceholder;\n    },\n\n    Seq(expr) {\n      return builder.seq(...expr.children.map(c => c.visit())).withSource(this.source);\n    },\n\n    Iter_star(x, _) {\n      return builder.star(x.visit()).withSource(this.source);\n    },\n    Iter_plus(x, _) {\n      return builder.plus(x.visit()).withSource(this.source);\n    },\n    Iter_opt(x, _) {\n      return builder.opt(x.visit()).withSource(this.source);\n    },\n\n    Pred_not(_, x) {\n      return builder.not(x.visit()).withSource(this.source);\n    },\n    Pred_lookahead(_, x) {\n      return builder.lookahead(x.visit()).withSource(this.source);\n    },\n\n    Lex_lex(_, x) {\n      return builder.lex(x.visit()).withSource(this.source);\n    },\n\n    Base_application(rule, ps) {\n      const params = ps.children.map(c => c.visit())[0] || [];\n      return builder.app(rule.visit(), params).withSource(this.source);\n    },\n    Base_range(from, _, to) {\n      return builder.range(from.visit(), to.visit()).withSource(this.source);\n    },\n    Base_terminal(expr) {\n      return builder.terminal(expr.visit()).withSource(this.source);\n    },\n    Base_paren(open, x, close) {\n      return x.visit();\n    },\n\n    ruleDescr(open, t, close) {\n      return t.visit();\n    },\n    ruleDescrText(_) {\n      return this.sourceString.trim();\n    },\n\n    caseName(_, space1, n, space2, end) {\n      return n.visit();\n    },\n\n    name(first, rest) {\n      return this.sourceString;\n    },\n    nameFirst(expr) {},\n    nameRest(expr) {},\n\n    terminal(open, cs, close) {\n      return cs.children.map(c => c.visit()).join('');\n    },\n\n    oneCharTerminal(open, c, close) {\n      return c.visit();\n    },\n\n    escapeChar(c) {\n      try {\n        return unescapeCodePoint(this.sourceString);\n      } catch (err) {\n        if (err instanceof RangeError && err.message.startsWith('Invalid code point ')) {\n          throw invalidCodePoint(c);\n        }\n        throw err; // Rethrow\n      }\n    },\n\n    NonemptyListOf(x, _, xs) {\n      return [x.visit()].concat(xs.children.map(c => c.visit()));\n    },\n    EmptyListOf() {\n      return [];\n    },\n\n    _terminal() {\n      return this.sourceString;\n    },\n  });\n  return helpers(match).visit();\n}\n\nvar operationsAndAttributesGrammar = makeRecipe([\"grammar\",{\"source\":\"OperationsAndAttributes {\\n\\n  AttributeSignature =\\n    name\\n\\n  OperationSignature =\\n    name Formals?\\n\\n  Formals\\n    = \\\"(\\\" ListOf<name, \\\",\\\"> \\\")\\\"\\n\\n  name  (a name)\\n    = nameFirst nameRest*\\n\\n  nameFirst\\n    = \\\"_\\\"\\n    | letter\\n\\n  nameRest\\n    = \\\"_\\\"\\n    | alnum\\n\\n}\"},\"OperationsAndAttributes\",null,\"AttributeSignature\",{\"AttributeSignature\":[\"define\",{\"sourceInterval\":[29,58]},null,[],[\"app\",{\"sourceInterval\":[54,58]},\"name\",[]]],\"OperationSignature\":[\"define\",{\"sourceInterval\":[62,100]},null,[],[\"seq\",{\"sourceInterval\":[87,100]},[\"app\",{\"sourceInterval\":[87,91]},\"name\",[]],[\"opt\",{\"sourceInterval\":[92,100]},[\"app\",{\"sourceInterval\":[92,99]},\"Formals\",[]]]]],\"Formals\":[\"define\",{\"sourceInterval\":[104,143]},null,[],[\"seq\",{\"sourceInterval\":[118,143]},[\"terminal\",{\"sourceInterval\":[118,121]},\"(\"],[\"app\",{\"sourceInterval\":[122,139]},\"ListOf\",[[\"app\",{\"sourceInterval\":[129,133]},\"name\",[]],[\"terminal\",{\"sourceInterval\":[135,138]},\",\"]]],[\"terminal\",{\"sourceInterval\":[140,143]},\")\"]]],\"name\":[\"define\",{\"sourceInterval\":[147,187]},\"a name\",[],[\"seq\",{\"sourceInterval\":[168,187]},[\"app\",{\"sourceInterval\":[168,177]},\"nameFirst\",[]],[\"star\",{\"sourceInterval\":[178,187]},[\"app\",{\"sourceInterval\":[178,186]},\"nameRest\",[]]]]],\"nameFirst\":[\"define\",{\"sourceInterval\":[191,223]},null,[],[\"alt\",{\"sourceInterval\":[207,223]},[\"terminal\",{\"sourceInterval\":[207,210]},\"_\"],[\"app\",{\"sourceInterval\":[217,223]},\"letter\",[]]]],\"nameRest\":[\"define\",{\"sourceInterval\":[227,257]},null,[],[\"alt\",{\"sourceInterval\":[242,257]},[\"terminal\",{\"sourceInterval\":[242,245]},\"_\"],[\"app\",{\"sourceInterval\":[252,257]},\"alnum\",[]]]]}]);\n\ninitBuiltInSemantics(Grammar.BuiltInRules);\ninitPrototypeParser(operationsAndAttributesGrammar); // requires BuiltInSemantics\n\nfunction initBuiltInSemantics(builtInRules) {\n  const actions = {\n    empty() {\n      return this.iteration();\n    },\n    nonEmpty(first, _, rest) {\n      return this.iteration([first].concat(rest.children));\n    },\n  };\n\n  Semantics.BuiltInSemantics = Semantics.createSemantics(builtInRules, null).addOperation(\n      'asIteration',\n      {\n        emptyListOf: actions.empty,\n        nonemptyListOf: actions.nonEmpty,\n        EmptyListOf: actions.empty,\n        NonemptyListOf: actions.nonEmpty,\n      },\n  );\n}\n\nfunction initPrototypeParser(grammar) {\n  Semantics.prototypeGrammarSemantics = grammar.createSemantics().addOperation('parse', {\n    AttributeSignature(name) {\n      return {\n        name: name.parse(),\n        formals: [],\n      };\n    },\n    OperationSignature(name, optFormals) {\n      return {\n        name: name.parse(),\n        formals: optFormals.children.map(c => c.parse())[0] || [],\n      };\n    },\n    Formals(oparen, fs, cparen) {\n      return fs.asIteration().children.map(c => c.parse());\n    },\n    name(first, rest) {\n      return this.sourceString;\n    },\n  });\n  Semantics.prototypeGrammar = grammar;\n}\n\nfunction findIndentation(input) {\n  let pos = 0;\n  const stack = [0];\n  const topOfStack = () => stack[stack.length - 1];\n\n  const result = {};\n\n  const regex = /( *).*(?:$|\\r?\\n|\\r)/g;\n  let match;\n  while ((match = regex.exec(input)) != null) {\n    const [line, indent] = match;\n\n    // The last match will always have length 0. In every other case, some\n    // characters will be matched (possibly only the end of line chars).\n    if (line.length === 0) break;\n\n    const indentSize = indent.length;\n    const prevSize = topOfStack();\n\n    const indentPos = pos + indentSize;\n\n    if (indentSize > prevSize) {\n      // Indent -- always only 1.\n      stack.push(indentSize);\n      result[indentPos] = 1;\n    } else if (indentSize < prevSize) {\n      // Dedent -- can be multiple levels.\n      const prevLength = stack.length;\n      while (topOfStack() !== indentSize) {\n        stack.pop();\n      }\n      result[indentPos] = -1 * (prevLength - stack.length);\n    }\n    pos += line.length;\n  }\n  // Ensure that there is a matching DEDENT for every remaining INDENT.\n  if (stack.length > 1) {\n    result[pos] = 1 - stack.length;\n  }\n  return result;\n}\n\nconst INDENT_DESCRIPTION = 'an indented block';\nconst DEDENT_DESCRIPTION = 'a dedent';\n\n// A sentinel value that is out of range for both charCodeAt() and codePointAt().\nconst INVALID_CODE_POINT = 0x10ffff + 1;\n\nclass InputStreamWithIndentation extends InputStream {\n  constructor(state) {\n    super(state.input);\n    this.state = state;\n  }\n\n  _indentationAt(pos) {\n    return this.state.userData[pos] || 0;\n  }\n\n  atEnd() {\n    return super.atEnd() && this._indentationAt(this.pos) === 0;\n  }\n\n  next() {\n    if (this._indentationAt(this.pos) !== 0) {\n      this.examinedLength = Math.max(this.examinedLength, this.pos);\n      return undefined;\n    }\n    return super.next();\n  }\n\n  nextCharCode() {\n    if (this._indentationAt(this.pos) !== 0) {\n      this.examinedLength = Math.max(this.examinedLength, this.pos);\n      return INVALID_CODE_POINT;\n    }\n    return super.nextCharCode();\n  }\n\n  nextCodePoint() {\n    if (this._indentationAt(this.pos) !== 0) {\n      this.examinedLength = Math.max(this.examinedLength, this.pos);\n      return INVALID_CODE_POINT;\n    }\n    return super.nextCodePoint();\n  }\n}\n\nclass Indentation extends PExpr {\n  constructor(isIndent = true) {\n    super();\n    this.isIndent = isIndent;\n  }\n\n  allowsSkippingPrecedingSpace() {\n    return true;\n  }\n\n  eval(state) {\n    const {inputStream} = state;\n    const pseudoTokens = state.userData;\n    state.doNotMemoize = true;\n\n    const origPos = inputStream.pos;\n\n    const sign = this.isIndent ? 1 : -1;\n    const count = (pseudoTokens[origPos] || 0) * sign;\n    if (count > 0) {\n      // Update the count to consume the pseudotoken.\n      state.userData = Object.create(pseudoTokens);\n      state.userData[origPos] -= sign;\n\n      state.pushBinding(new TerminalNode(0), origPos);\n      return true;\n    } else {\n      state.processFailure(origPos, this);\n      return false;\n    }\n  }\n\n  getArity() {\n    return 1;\n  }\n\n  _assertAllApplicationsAreValid(ruleName, grammar) {}\n\n  _isNullable(grammar, memo) {\n    return false;\n  }\n\n  assertChoicesHaveUniformArity(ruleName) {}\n\n  assertIteratedExprsAreNotNullable(grammar) {}\n\n  introduceParams(formals) {\n    return this;\n  }\n\n  substituteParams(actuals) {\n    return this;\n  }\n\n  toString() {\n    return this.isIndent ? 'indent' : 'dedent';\n  }\n\n  toDisplayString() {\n    return this.toString();\n  }\n\n  toFailure(grammar) {\n    const description = this.isIndent ? INDENT_DESCRIPTION : DEDENT_DESCRIPTION;\n    return new Failure(this, description, 'description');\n  }\n}\n\n// Create a new definition for `any` that can consume indent & dedent.\nconst applyIndent = new Apply('indent');\nconst applyDedent = new Apply('dedent');\nconst newAnyBody = new Splice(BuiltInRules$1, 'any', [applyIndent, applyDedent], []);\n\nconst IndentationSensitive = new Builder()\n    .newGrammar('IndentationSensitive')\n    .withSuperGrammar(BuiltInRules$1)\n    .define('indent', [], new Indentation(true), INDENT_DESCRIPTION, undefined, true)\n    .define('dedent', [], new Indentation(false), DEDENT_DESCRIPTION, undefined, true)\n    .extend('any', [], newAnyBody, 'any character', undefined)\n    .build();\n\nObject.assign(IndentationSensitive, {\n  _matchStateInitializer(state) {\n    state.userData = findIndentation(state.input);\n    state.inputStream = new InputStreamWithIndentation(state);\n  },\n  supportsIncrementalParsing: false,\n});\n\n// Generated by scripts/prebuild.js\nconst version = '17.1.0';\n\nGrammar.initApplicationParser(ohmGrammar$1, buildGrammar$1);\n\nconst isBuffer = obj =>\n  !!obj.constructor &&\n  typeof obj.constructor.isBuffer === 'function' &&\n  obj.constructor.isBuffer(obj);\n\nfunction compileAndLoad(source, namespace) {\n  const m = ohmGrammar$1.match(source, 'Grammars');\n  if (m.failed()) {\n    throw grammarSyntaxError(m);\n  }\n  return buildGrammar$1(m, namespace);\n}\n\nfunction grammar(source, optNamespace) {\n  const ns = grammars(source, optNamespace);\n\n  // Ensure that the source contained no more than one grammar definition.\n  const grammarNames = Object.keys(ns);\n  if (grammarNames.length === 0) {\n    throw new Error('Missing grammar definition');\n  } else if (grammarNames.length > 1) {\n    const secondGrammar = ns[grammarNames[1]];\n    const interval = secondGrammar.source;\n    throw new Error(\n        getLineAndColumnMessage(interval.sourceString, interval.startIdx) +\n        'Found more than one grammar definition -- use ohm.grammars() instead.',\n    );\n  }\n  return ns[grammarNames[0]]; // Return the one and only grammar.\n}\n\nfunction grammars(source, optNamespace) {\n  const ns = Object.create(optNamespace || {});\n  if (typeof source !== 'string') {\n    // For convenience, detect Node.js Buffer objects and automatically call toString().\n    if (isBuffer(source)) {\n      source = source.toString();\n    } else {\n      throw new TypeError(\n          'Expected string as first argument, got ' + unexpectedObjToString(source),\n      );\n    }\n  }\n  compileAndLoad(source, ns);\n  return ns;\n}\n\nexport { IndentationSensitive as ExperimentalIndentationSensitive, buildGrammar$1 as _buildGrammar, grammar, grammars, makeRecipe, ohmGrammar$1 as ohmGrammar, pexprs, version };\n", "import * as ohm from './_snowpack/pkg/ohm-js.js';\n\nconst g = ohm.grammar(String.raw`\n  Constraints {\n    Label = Expr   -- expr\n          | ident  -- ident\n          | number -- number\n\n    Expr = number ident -- times\n\n    number = digit+ \"'\" (digit+ \"\\\"\")? -- feetAndInches\n           | digit+ \"\\\"\"               -- justInches\n           | digit+ (\".\" digit+)?      -- wholeAndFrac\n           | \".\" digit+                -- onlyFrac\n\n    ident = letter alnum*\n  }\n`);\n\nconst s = g.createSemantics().addOperation('parse', {\n  Label_expr(e) {\n    return {\n      type: 'lengthFormula',\n      ...e.parse(),\n      label: this.sourceString\n    };\n  },\n  Label_ident(x) {\n    return {\n      type: 'lengthLabel',\n      name: x.parse()\n    };\n  },\n  Label_number(n) {\n    return {\n      type: 'lengthConstant',\n      value: n.parse()\n    };\n  },\n  Expr_times(n, x) {\n    const k = n.parse();\n    const v = x.parse();\n    return {\n      fn: (vars) => k * vars[v].value,\n      depNames: [v],\n    };\n  },\n  number_feetAndInches(feet, _1, inches, _2) {\n    let n = parseInt(feet.sourceString);\n    if (inches.numChildren == 1) {\n      n += parseInt(inches.sourceString) / 12;\n    }\n    return n * 100;\n  },\n  number_justInches(inches, _) {\n    return parseInt(inches.sourceString) * 100 / 12;\n  },\n  number_wholeAndFrac(_1, _2, _3) {\n    return parseFloat(this.sourceString);\n  },\n  number_onlyFrac(_1, _2) {\n    return parseFloat(this.sourceString);\n  },\n  ident(_1, _2) {\n    return this.sourceString;\n  }\n});\n\nfunction parse(input) {\n  try {\n    const r = g.match(input);\n   return s(r).parse();\n  } catch (e) {\n    return null;\n  }\n}\n\nwindow.parse = parse;\nexport default parse;\n", "import Vec from './lib/vec.js';\nimport Line from './lib/line.js';\nimport parse from './parser.js';\nimport { Point as RPoint } from './lib/relax-pk.js';\n\n// Monotonically incrementing id counter\nlet nextId = 0;\n\nclass Point {\n    constructor(pos) {\n        this.id = nextId++;\n        this.pos = pos;\n    }\n\n    render(ctx) {\n        ctx.beginPath();\n        ctx.ellipse(this.pos.x, this.pos.y, 3, 3, 0, 0, Math.PI * 2);\n        ctx.fill();\n    }\n}\n\nfunction addInputElement(line) {\n    const input = document.createElement('input');\n    input.setAttribute('type', 'text');\n    input.contentEditable = true;\n    input.onchange = () => {\n        input.value = input.value.toLowerCase();\n        input.blur();\n    };\n    input.setPos = (x, y) => {\n        const rect = input.getBoundingClientRect();\n        input.style.setProperty('left', `${x - rect.width / 2}px`);\n        input.style.setProperty('top', `${y - rect.height / 2}px`);\n    };\n    input.line = line;\n    document.body.appendChild(input);\n    return input;\n}\n\nclass LineStroke {\n    constructor(a, b) {\n        this.id = nextId++;\n        this.a = a;\n        this.b = b;\n        this.input = addInputElement(this);\n        this.updateInputPos();\n    }\n\n    render(ctx, highlight) {\n        ctx.lineWidth = 1.0;\n        ctx.strokeStyle = highlight ? '#F81ED5' : '#000000';\n        ctx.beginPath();\n        ctx.moveTo(this.a.pos.x, this.a.pos.y);\n        ctx.lineTo(this.b.pos.x, this.b.pos.y);\n        ctx.stroke();\n        this.updateInputPos();\n    }\n\n    updateInputPos() {\n        this.input.setPos(\n            (this.a.pos.x + this.b.pos.x) / 2,\n            (this.a.pos.y + this.b.pos.y) / 2\n        );\n    }\n}\n\nclass WetStroke {\n    constructor(pos) {\n        this.a = pos;\n        this.b = Vec.clone(pos);\n\n        this.last_b = Vec.clone(pos);\n        this.velocity = 0;\n    }\n\n    update(pos, points, ref_line) {\n        this.b = pos;\n        let new_velocity = Vec.dist(this.last_b, this.b);\n        this.last_b = Vec.clone(this.b);\n        this.velocity = 0.05 * new_velocity + (1 - 0.05) * this.velocity; // Filter velocity\n        //console.log(this.velocity);\n\n        this.h_snap = false;\n        this.v_snap = false;\n\n        if (Math.abs(this.a.x - this.b.x) < 10) {\n            this.b.x = this.a.x;\n            this.v_snap = true;\n        }\n    \n        if (Math.abs(this.a.y - this.b.y) < 10) {\n            this.b.y = this.a.y;\n            this.h_snap = true;\n        }\n        \n        const snaps = [];\n        if (this.velocity < 1.5) {\n            points.forEach(point => {\n                const sx = Line.getXforY(this, point.pos.y);\n                const sy = Line.getYforX(this, point.pos.x);\n                snaps.push(\n                    { type: 'horizontal', x: sx, y: point.pos.y, snap: point },\n                    { type: 'vertical', x: point.pos.x, y: sy, snap: point },\n                );\n            });\n\n            this.point_snap = false;\n            snaps.forEach(snap => {\n                if (Vec.dist(pos, snap) < 10) {\n                    this.b.x = snap.x;\n                    this.b.y = snap.y;\n                    this.point_snap = snap;\n                }\n            });\n        } \n\n        // Snap to point\n        const point_snap = points.find(point => Vec.dist(point.pos, pos) < 10);\n        if (point_snap) {\n            this.b = point_snap.pos;\n            this.point_snap = { type: 'coincident', snap: point_snap };\n        }\n\n        \n        // Snap with reference point\n        this.len_snap = false;\n        this.angle_snap = false;\n        this.angle_offset = null;\n        if (ref_line) {\n            this.ref_line = ref_line;\n            // Snap lengths\n            const ref_len = Line.len(Line(ref_line.a.pos, ref_line.b.pos));\n            let cur_len = Line.len(Line(this.a, this.b));\n            if (Math.abs(ref_len - cur_len) < 10) {\n                this.b = Vec.add(this.a, Vec.mulS(Vec.normalize(Vec.sub(this.b, this.a)), ref_len));\n                this.len_snap = true;\n                cur_len = ref_len;\n            }\n\n            // Snap Angles\n            const my_vec = Vec.sub(this.a, this.b);\n            const ref_vec = Vec.sub(ref_line.a.pos, ref_line.b.pos);\n\n            const my_angle = Vec.angle(my_vec);\n            const ref_angle = Vec.angle(ref_vec);\n\n            const diff_angle = (my_angle - ref_angle + 360) % 360;\n\n            const closest_round_angle = (Math.round(diff_angle / 90) * 90 + 360) % 360;\n            if (Math.abs(diff_angle - closest_round_angle) < 10) {\n                const new_angle = ref_angle + closest_round_angle;\n                this.b = Vec.add(this.a, Vec.polar(180 + new_angle, cur_len));\n                this.angle_snap = true;\n                this.angle_offset = closest_round_angle;\n            }\n        }\n    }\n\n    render(ctx) {\n        ctx.lineWidth = 1.0;\n        ctx.strokeStyle = this.len_snap ? '#F81ED5' : '#000000';\n        ctx.beginPath();\n        ctx.moveTo(this.a.x, this.a.y);\n        ctx.lineTo(this.b.x, this.b.y);\n        ctx.stroke();\n\n        if (this.h_snap || this.v_snap || this.angle_snap) {\n            const projected_a = Vec.add(this.b, Vec.mulS(Vec.sub(this.a, this.b), 100));\n            const projected_b = Vec.add(this.a, Vec.mulS(Vec.sub(this.b, this.a), 100));\n            ctx.lineWidth = 0.25;\n            ctx.strokeStyle = '#F81ED5';\n            ctx.beginPath();\n            ctx.moveTo(projected_a.x, projected_a.y);\n            ctx.lineTo(projected_b.x, projected_b.y);\n            ctx.stroke();\n        }\n\n        if (this.point_snap) {\n            const projected_a = Vec.add(this.b, Vec.mulS(Vec.sub(this.point_snap.snap.pos, this.b), 100));\n            const projected_b = Vec.add(this.point_snap.snap.pos, Vec.mulS(Vec.sub(this.b, this.point_snap.snap.pos), 100));\n            ctx.lineWidth = 0.25;\n            ctx.strokeStyle = '#F81ED5';\n            ctx.beginPath();\n            ctx.moveTo(projected_a.x, projected_a.y);\n            ctx.lineTo(projected_b.x, projected_b.y);\n            ctx.stroke();\n        }\n\n        if (this.ref_line) {\n            const ref_len = Line.len(Line(this.ref_line.a.pos, this.ref_line.b.pos));\n\n            const normalized_line = Vec.normalize(Vec.sub(this.b, this.a));\n\n            const long_b = Vec.add(this.a, Vec.mulS(normalized_line, 10000));\n            const len_vec = Vec.mulS(normalized_line, ref_len);\n\n            ctx.lineWidth = 0.25;\n            ctx.strokeStyle = '#F81ED5';\n\n            ctx.beginPath();\n            ctx.moveTo(this.a.x, this.a.y);\n            ctx.lineTo(long_b.x, long_b.y);\n            ctx.stroke();\n\n            for (let i = 0; i < 10; i += 0.25) {\n                const size = i % 1 === 0.0 ? 6 : 3;\n                const perpendicular = Vec.mulS(Vec.rotate90CCW(normalized_line), size);\n\n                const snap_pt = Vec.add(this.a, Vec.mulS(len_vec, i));\n                const snap_perp_a = Vec.add(snap_pt, perpendicular);\n                const snap_perp_b = Vec.sub(snap_pt, perpendicular);\n                ctx.beginPath();\n                ctx.moveTo(snap_perp_a.x, snap_perp_a.y);\n                ctx.lineTo(snap_perp_b.x, snap_perp_b.y);\n                ctx.stroke();\n            }\n        }\n    }\n}\n\nclass DrawSnap { \n    constructor() {\n        this.mode = 'draw';\n\n        this.wet_stroke = null;\n        this.ref_line = null;\n        this.points = [];\n        this.lines = [];\n\n        this.snapConstraints = [];\n        this.scribbleConstraints = [];\n    }\n\n    find_point_near(pos) {\n        return this.points.find(point => Vec.dist(point.pos, pos) < 10);\n    }\n\n    find_stroke_near(pos) {\n        return this.lines.find(line=> {\n            const dist = Line.distToPoint(Line(line.a.pos, line.b.pos), pos);\n            return dist < 20;\n        })\n    }\n\n    begin_stroke(pos) {\n        const found = this.find_point_near(pos);\n        if (found) pos = found.pos;\n        this.wet_stroke = new WetStroke(pos);\n    }\n\n    update_stroke(pos) {\n        if (this.wet_stroke) {\n            this.wet_stroke.update(pos, this.points, this.ref_line);\n        }\n    }\n\n    end_stroke(pos) {\n        let a = this.find_point_near(this.wet_stroke.a);\n        if (!a) a = new Point(this.wet_stroke.a);\n        this.points.push(a);\n\n        let b = this.find_point_near(this.wet_stroke.b);\n        if (!b) b = new Point(this.wet_stroke.b);\n        this.points.push(b);\n\n        const l = new LineStroke(a, b);\n        this.lines.push(l);\n        \n\n        // record constraints\n        this.snapConstraints.push({ type: 'minLength', a:l, b: 50 });\n        const ws = this.wet_stroke;\n        if (ws.v_snap) {\n            this.snapConstraints.push({ type: 'vertical', a, b });\n        }\n        if (ws.h_snap) {\n            this.snapConstraints.push({ type: 'horizontal', a, b });\n        }\n        if (ws.point_snap && ws.point_snap.type != 'coincident') {\n            this.snapConstraints.push({ type: ws.point_snap.type, a: b, b: ws.point_snap.snap });\n        }\n        if (ws.len_snap) {\n            this.snapConstraints.push({ type: 'length', a: l, b: ws.ref_line });\n        }\n        if (ws.angle_snap && !ws.v_snap && !ws.h_snap) {\n            this.snapConstraints.push({ type: 'angle', a: l, b: ws.ref_line, angle: ws.angle_offset });\n        }\n\n        console.log(this.snapConstraints);\n\n        this.wet_stroke = null\n    }\n    \n    onYank(p, v) {\n        // no op (client should override)\n    }\n\n    update(events) {\n        // Handle input\n        events.pencil.forEach(event => {\n            const pos = new RPoint(event.x, event.y);\n            if (this.mode === 'draw') {\n                if (event.type === 'began') {\n                    this.begin_stroke(pos);\n                } else if (event.type === 'moved') {\n                    this.update_stroke(pos);\n                } else if (event.type === 'ended') {\n                    this.end_stroke(pos);\n                }\n            } else if (this.mode.startsWith('move')) {\n                if (event.type === 'began') {\n                    this.dragging = this.find_point_near(pos);\n                    if (this.dragging) {\n                        this.prevDragPos = pos;\n                        const reachablePoints = new Set([this.dragging]);\n                        while (true) {\n                            const oldSize = reachablePoints.size;\n                            for (const p of reachablePoints) {\n                                for (const l of this.lines) {\n                                    if (l.a === p) {\n                                        reachablePoints.add(l.b);\n                                    } else if (l.b === p) {\n                                        reachablePoints.add(l.a);\n                                    }\n                                }\n                            }\n                            if (reachablePoints.size === oldSize) {\n                                break;\n                            }\n                        }\n                        let fixedPointDistance = -Infinity;\n                        for (const p of reachablePoints) {\n                            const distance = Vec.dist(this.dragging.pos, p.pos);\n                            if (distance > fixedPointDistance) {\n                                fixedPointDistance = distance;\n                                this.fixedPoint = p;\n                            }\n                        }\n                    }\n                }\n                if (event.type === 'moved') {\n                    if (this.dragging) {\n                        const v = pos.minus(this.prevDragPos);\n                        const m = v.magnitude();\n                        if (m > 4) {\n                            this.onYank(this.dragging.pos, v);\n                        }\n                        this.prevDragPos = pos;\n                        this.dragging.pos.x = pos.x;\n                        this.dragging.pos.y = pos.y;\n                    }\n                }\n                if (event.type === 'ended') {\n                    this.dragging = false;\n                    this.initialDragPos = null;\n                    this.fixedPoint = null;\n                }\n            }\n        });\n\n        Object.entries(events.touches).forEach(([touchId, events]) => {\n            events.forEach(event => {\n                const pos = new RPoint(event.x, event.y);\n                if (event.type === 'began') {\n                    const found = this.find_stroke_near(pos);\n                    if (this.ref_line === found) {\n                        this.ref_line = null;\n                    } else {\n                        this.ref_line = found;\n                        this.finger_down_time = event.timestamp;\n                    }\n\n                    this.ref_line_id = touchId;\n\n                    if (Vec.dist(new RPoint(40, 40), pos) < 20) {\n                        this.toggleModes();\n                    }\n                }\n    \n                if (event.type == 'ended') {\n                    if (event.timestamp - this.finger_down_time > 1.0) {\n                        this.ref_line = null;\n                    }\n                }\n            }); \n        });\n    }\n\n    toggleModes() {\n        if (this.mode === 'draw') {\n            this.mode = 'move';\n        } else if (this.mode === 'move') {\n            this.mode = 'move-v2';\n        } else if (this.mode === 'move-v2') {\n            this.mode = 'scribble';\n            for (const input of document.body.getElementsByTagName('input')) {\n                input.placeholder = '...';\n            }\n            window.webkit.messageHandlers.messages.postMessage('mgr off');\n        } else {\n            this.scribbleConstraints = [];\n            for (const input of document.body.getElementsByTagName('input')) {\n                input.placeholder = '';\n                input.blur();\n                const c = parse(input.value);\n                if (c != null) {\n                    c.input = input;\n                    this.scribbleConstraints.push(c);\n                } else {\n                    console.log('failed to parse:', input.value);\n                }\n            }\n            console.log(this.scribbleConstraints);\n            this.mode = 'draw';\n            window.webkit.messageHandlers.messages.postMessage('mgr on');\n        }\n        document.body.className = this.mode;\n        return this.mode;\n    }\n\n    render(ctx) {\n        this.lines.forEach(line => {\n            line.render(ctx, line === this.ref_line);\n        })\n        this.points.forEach(point => {\n            point.render(ctx);\n        })\n\n        if (this.wet_stroke) {\n            this.wet_stroke.render(ctx);\n        }\n\n        // Draw toggle\n        ctx.beginPath();\n        ctx.ellipse(40, 40, 20, 20, 0, 0, Math.PI * 2);\n        if (this.mode === 'draw') {\n            ctx.fill();\n        } else {\n            ctx.stroke();\n        }\n\n        ctx.fillText(this.mode, 70, 40);\n    }\n}\n\nexport default DrawSnap;\n", "import engine from './engine.js';\nimport Canvas from './canvas.js';\nimport Relax, {\n  FixedPoint,\n  FixedVar,\n  Horizontal,\n  Length,\n  MinLength,\n  Orientation,\n  Point as RPoint,\n  SpreadsheetCell,\n  Var,\n  VarEquals,\n  Vertical,\n} from './lib/relax-pk.js';\n\nimport DrawSnap from './draw_snap.js';\n\nconst draw = new DrawSnap();\nwindow.draw = draw;\n\nconst canvas = new Canvas(document.body, ctx => {\n  ctx.clearRect(0,0, window.innerWidth, window.innerHeight);\n  draw.render(ctx);\n});\n\ncanvas.canvas.addEventListener('touchstart', e => {\n  // Hokey way to detect a press of the mode button while the\n  // MultiGestureRecognizer is disabled.\n  if (\n    draw.mode === 'scribble' &&\n    e.pageX <= 50 &&\n    e.pageY <= 50\n  ) {\n    draw.toggleModes();\n  }\n});\n\nengine((events) => {\n  draw.update(events);\n  relax();\n  canvas.render();\n});\n\nconst r = new Relax();\nwindow.r = r;\n\ndraw.onYank = function(p, v) {\n  // console.log('p', p, 'v', v);\n\n  if (Math.abs(v.y) < 1) {\n    console.log('remove vertical!');\n    for (const c of r.things) {\n      if (c instanceof Vertical && c.involves(p)) {\n        r.remove(c);\n      }\n    }\n  }\n\n  if (Math.abs(v.x) < 1) {\n    console.log('remove horizontal!');\n    for (const c of r.things) {\n      if (c instanceof Horizontal && c.involves(p)) {\n        r.remove(c);\n      }\n    }\n  }\n\n  const ANGLE_TOLERANCE = 20 * Math.PI / 180;\n  const yankAngle1 = v.angleWithXAxis() + Math.PI; // puts it into (0, 2pi) range\n  const yankAngle2 = v.scaledBy(-1).angleWithXAxis() + Math.PI; // same as above\n  for (const c of r.things) {\n    if (!(c instanceof Length && c.involves(p))) {\n      continue;\n    }\n    const lineAngle = c.p2.minus(c.p1).angleWithXAxis() + Math.PI;\n    if (\n      Math.abs(yankAngle1 - lineAngle) <= ANGLE_TOLERANCE ||\n      Math.abs(yankAngle2 - lineAngle) <= ANGLE_TOLERANCE\n    ) {\n      r.remove(c);\n    }\n  }\n};\n\nfunction relax() {\n  const hgcs = addHandOfGodConstraints(r);\n  for (const c of draw.snapConstraints) {\n    addSnapConstraints(r, c);\n  }\n  draw.snapConstraints = [];\n  addScribbleConstraints(r);\n  r.iterateForUpToMillis(15);\n  hgcs.forEach(c => r.remove(c));\n}\n\nfunction addHandOfGodConstraints(r) {\n  if (!draw.mode.startsWith('move') || !draw.dragging) {\n    return [];\n  }\n\n  const cs = [];\n  \n  function addFixedPointConstraint(dp) {\n    const p = dp.pos;\n    const c = new FixedPoint(p, new RPoint(p.x, p.y));\n    r.add(c);\n    cs.push(c);\n  }\n\n  addFixedPointConstraint(draw.dragging);\n  if (draw.mode === 'move-v2') {\n    addFixedPointConstraint(draw.fixedPoint);\n  }\n\n  return cs;\n}\n\nfunction addSnapConstraints(r, c) {\n  if (c.type === 'vertical') {\n    r.add(new Vertical(c.a.pos, c.b.pos));\n  } else if (c.type === 'horizontal') {\n    r.add(new Horizontal(c.a.pos, c.b.pos));\n  } else if (c.type === 'length') {\n    const v = new Var(c.a.a.pos.distanceTo(c.a.b.pos));\n    r.add(new Length(c.a.a.pos, c.a.b.pos, v));\n    r.add(new Length(c.b.a.pos, c.b.b.pos, v));\n    } else if (c.type === 'minLength') {\n    r.add(new MinLength(c.a.a.pos, c.a.b.pos, c.b));\n  } else if (c.type === 'angle') {\n    r.add(new Orientation(c.a.a.pos, c.a.b.pos, c.b.a.pos, c.b.b.pos, Math.PI * c.angle / 180));\n  } else {\n    throw new Error('unsupported snap constraint ' + c.type);\n  }\n}\n\nlet cachedScribbleConstraints = [];\nlet cachedRScribbleConstraints = [];\n\nfunction addScribbleConstraints(r) {\n  if (draw.scribbleConstraints === cachedScribbleConstraints) {\n    return;\n  }\n\n  console.log('scribble constraints changed!');\n\n  cachedRScribbleConstraints.forEach(c => r.remove(c));\n  cachedRScribbleConstraints = [];\n\n  // length labels\n  const varsByName = {};\n  draw.scribbleConstraints.filter(c => c.type === 'lengthLabel').forEach(c => {\n    const line = c.input.line;\n    const v = new Var(line.a.pos.distanceTo(line.b.pos));\n    v.line = line;\n    cachedRScribbleConstraints.push(new Length(line.a.pos, line.b.pos, v));\n    if (varsByName[c.name] == null) {\n      varsByName[c.name] = [];\n    }\n    varsByName[c.name].push(v);\n  });\n  for (const vars of Object.values(varsByName)) {\n    if (vars.length > 1) {\n      cachedRScribbleConstraints.push(new VarEquals(...vars));\n    }\n  }\n\n  // length constants\n  draw.scribbleConstraints.filter(c => c.type === 'lengthConstant').forEach(c => {\n    const line = c.input.line;\n    const v = new Var(c.value);\n    cachedRScribbleConstraints.push(\n      new FixedVar(v, c.value),\n      new Length(line.a.pos, line.b.pos, v)\n    );\n  });\n\n  // length formulas\n  draw.scribbleConstraints.filter(c => c.type === 'lengthFormula').forEach(c => {\n    const line = c.input.line;\n    if (c.depNames.length !== 1) {\n      throw new Error('todo');\n    }\n    const varName = c.depNames[0];\n    const modifiableVars = varsByName[varName];\n    if (modifiableVars == null) {\n      // name is not bound yet, so ignore this constraint\n      return;\n    }\n\n    const modifiablePoints = [line.a, line.b];\n    const otherLines = modifiableVars.map(v => v.line);\n    otherLines.forEach(otherLine => modifiablePoints.push(otherLine.a, otherLine.b));\n\n    const env = {};\n    env[varName] = modifiableVars[0];\n    const cell = new SpreadsheetCell(\n      { xs: modifiablePoints, ys: modifiablePoints, vars: modifiableVars },\n      () => c.fn(env)\n    );\n    cachedRScribbleConstraints.push(cell);\n    cachedRScribbleConstraints.push(new Length(line.a.pos, line.b.pos, cell));\n  });\n\n  cachedScribbleConstraints = draw.scribbleConstraints;\n  cachedRScribbleConstraints.forEach(c => r.add(c));\n}\n"],
  "mappings": "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",
  "names": []
}
