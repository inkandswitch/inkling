{
  "version": 3,
  "sources": ["../build/lib/math.js", "../build/lib/vec.js", "../build/engine.js", "../build/canvas.js", "../build/lib/line.js", "../build/draw_snap.js", "../build/main.js"],
  "sourcesContent": ["// Math\n// The JS Math APIs aren't great. Here's a few extras that are nice to have.\n\nexport const TAU = Math.PI * 2;\n\nexport const isZero = (v) => {\n  return Number.EPSILON > Math.abs(v);\n};\n\nexport const isNonZero = (v) => {\n  return !Math.zero(v);\n};\n\nexport const avg = (a, b) => {\n  return (a + b) / 2;\n};\n\nexport const clip = (v, min = 0, max = 1) => {\n  return Math.min(Math.max(min, v), max);\n};\n\nexport const lerpN = (input, outputMin = 0, outputMax = 1, doClip = false) => {\n  input *= outputMax - outputMin;\n  input += outputMin;\n  if (doClip) input = clip(input, outputMin, outputMax);\n  return input;\n};\n\n// Prettier really screwed this one up, alas.\n// The args should be: input, inputMin, inputMax, outputMin, outputMax, doClip\nexport const lerp = (i, im = 0, iM = 1, om = 0, oM = 1, doClip = true) => {\n  if (im == iM) return om; // Avoids a divide by zero\n  if (im > iM) [im, iM, om, oM] = [iM, im, oM, om];\n  if (doClip) i = clip(i, im, iM);\n  i -= im;\n  i /= iM - im;\n  return lerpN(i, om, oM, false);\n};\n\nexport const rand = (min = -1, max = 1) => {\n  return lerpN(Math.random(), min, max);\n};\n\nexport const randInt = (min, max) => {\n  return Math.round(rand(min, max));\n};\n\nexport const roundTo = (input, precision) => {\n  // Using the reciprocal avoids floating point errors. Eg: 3/10 is fine, but 3*0.1 is wrong.\n  p = 1 / precision;\n  return Math.round(input * p) / p;\n};\n\nexport const easeInOut = (t) => {\n  let ease = (t) => Math.pow(t, 3);\n  if (t < 0.5) return lerp(ease(t * 2), 0, 1, 0, 0.5);\n  else return lerp(ease((1 - t) * 2), 1, 0, 0.5, 1);\n};", "// Vec\n// This is a port of (part of) Ivan's homemade CoffeeScript vector library.\n\nimport { isZero, roundTo, clip } from \"./math.js\";\n\n// Constructors ///////////////////////////////////////////////////////////////\n\nconst Vec = (x = 0, y = 0) => {\n  return { x, y };\n};\nexport default Vec;\n\nVec.clone = (v) => {\n  return Vec(v.x, v.y);\n};\n\nVec.fromRectXY = (r) => {\n  return Vec(r.x, r.y);\n};\n\nVec.fromRectWH = (r) => {\n  return Vec(r.w, r.h);\n};\n\nVec.fromRectRB = (r) => {\n  return Vec(r.x + r.w, r.y + r.h);\n};\n\nVec.of = (s) => {\n  return Vec(s, s);\n};\n\nVec.random = (scale = 1) => {\n  return Vec.Smul(\n    scale,\n    Vec.complement(Vec.Smul(2, Vec(Math.random(), Math.random())))\n  );\n};\n\nVec.toA = (v) => {\n  return [v.x, v.y];\n};\n\nVec.polar = (angle, length) => {\n  const angleInRadians = (angle * Math.PI) / 180;\n  return Vec(\n    length * Math.cos(angleInRadians),\n    length * Math.sin(angleInRadians)\n  );\n}\n\n// Static Vectors /////////////////////////////////////////////////////////////\n\nVec.x = Object.freeze(Vec(1));\nVec.y = Object.freeze(Vec(0, 1));\nVec.zero = Object.freeze(Vec());\n\n// FP /////////////////////////////////////////////////////////////////////////\n\nVec.map = (f, v) => {\n  return Vec(f(v.x), f(v.y));\n};\n\nVec.map2 = (f, a, b) => {\n  return Vec(f(a.x, b.x), f(a.y, b.y));\n};\n\nVec.reduce = (f, v) => {\n  return f(v.x, v.y);\n};\n\n// Vector Algebra /////////////////////////////////////////////////////////////\n\n// Not really cross product, but close enough\nVec.cross = (a, b) => {\n  return a.x * b.y - a.y * b.x\n};\n\nVec.project = (a, b) => {\n  return Vec.mulS(b, Vec.dot(a, b) / Vec.len2(b));\n};\n\nVec.reject = (a, b) => {\n  return Vec.sub(a, Vec.project(a, b));\n};\n\nVec.scalarProjection = (p, a, b) => {\n  let ap = Vec.sub(p, a)\n  let ab = Vec.normalize(Vec.sub(b, a))\n  let f = Vec.mulS(ab,  Vec.dot(ap, ab))\n  return Vec.add(a, f)\n}\n\n// Piecewise Vector Arithmetic ////////////////////////////////////////////////\n\nVec.add = (a, b) => {\n  return Vec(a.x + b.x, a.y + b.y);\n};\n\nVec.div = (a, b) => {\n  return Vec(a.x / b.x, a.y / b.y);\n};\n\nVec.mul = (a, b) => {\n  return Vec(a.x * b.x, a.y * b.y);\n};\n\nVec.sub = (a, b) => {\n  return Vec(a.x - b.x, a.y - b.y);\n};\n\n// Vector-Scalar Arithmetic ///////////////////////////////////////////////////\n\nVec.addS = (v, s) => {\n  return Vec.add(v, Vec.of(s));\n};\n\nVec.divS = (v, s) => {\n  return Vec.div(v, Vec.of(s));\n};\n\nVec.mulS = (v, s) => {\n  return Vec.mul(v, Vec.of(s));\n};\n\nVec.subS = (v, s) => {\n  return Vec.sub(v, Vec.of(s));\n};\n\n// Scalar-Vector Arithmetic ///////////////////////////////////////////////////\n\nVec.Sadd = (s, v) => {\n  return Vec.add(Vec.of(s), v);\n};\n\nVec.Sdiv = (s, v) => {\n  return Vec.div(Vec.of(s), v);\n};\n\nVec.Smul = (s, v) => {\n  return Vec.mul(Vec.of(s), v);\n};\n\nVec.Ssub = (s, v) => {\n  return Vec.sub(Vec.of(s), v);\n};\n\n// Measurement ////////////////////////////////////////////////////////////////\n\nVec.dist = (a, b) => {\n  return Vec.len(Vec.sub(a, b));\n};\n\n// Strongly recommend using Vec.dist instead of Vec.dist2 (distance-squared)\nVec.dist2 = (a, b) => {\n  return Vec.len2(Vec.sub(a, b));\n};\n\nVec.dot = (a, b) => {\n  return a.x * b.x + a.y * b.y;\n};\n\nVec.equal = (a, b) => {\n  return isZero(Vec.dist2(a, b));\n};\n\n// Strongly recommend using Vec.len instead of Vec.len2 (length-squared)\nVec.len2 = (v) => {\n  return Vec.dot(v, v);\n};\n\nVec.len = (v) => {\n  return Math.sqrt(Vec.dot(v, v));\n};\n\n// Rounding ///////////////////////////////////////////////////////////////////\n\nVec.ceil = (v) => {\n  return Vec.map(Math.ceil, v);\n};\n\nVec.floor = (v) => {\n  return Vec.map(Math.floor, v);\n};\n\nVec.round = (v) => {\n  return Vec.map(Math.round, v);\n};\n\nVec.roundTo = (v, s) => {\n  return Vec.map2(roundTo, v, Vec.of(s));\n};\n\n// Variations ///////////////////////////////////////////////////////////////////\n\nVec.complement = (v) => {\n  return Vec.Ssub(1, v);\n};\n\nVec.half = (v) => {\n  return Vec.divS(v, 2);\n};\n\nVec.normalize = (v) => {\n  return Vec.divS(v, Vec.len(v));\n};\n\nVec.recip = (v) => {\n  return Vec.Sdiv(1, v);\n};\n\n// Prettier really screwed this one up, alas.\n// The args should be: input, inputMin, inputMax, outputMin, outputMax\nVec.renormalize = (v, im, iM, om, oM) => {\n  return Vec.add(\n    Vec.mul(Vec.div(Vec.sub(v, im), Vec.sub(iM, im)), Vec.sub(oM, om)),\n    om\n  );\n};\n\n// Combinations ///////////////////////////////////////////////////////////////////\n\nVec.avg = (a, b) => {\n  return Vec.half(Vec.add(a, b));\n};\n\nVec.lerp = (a, b, t) => {\n  return Vec.add(a, Vec.Smul(t, Vec.sub(b, a)));\n};\n\nVec.max = (a, b) => {\n  return Vec.map2(Math.max, a, b);\n};\n\nVec.min = (a, b) => {\n  return Vec.map2(Math.min, a, b);\n};\n\n// Reflections ///////////////////////////////////////////////////////////////////\n\nVec.abs = (v) => {\n  return Vec.map(Math.abs, v);\n};\n\nVec.invert = (v) => {\n  return Vec(-v.x, -v.y);\n};\n\nVec.invertX = (v) => {\n  return Vec(-v.x, v.y);\n};\n\nVec.invertY = (v) => {\n  return Vec(v.x, -v.y);\n};\n\n// Rotation & angles ///////////////////////////////////////////////////////////\n\n\n// 90 degrees clockwise\nVec.rotate90CW = (v)=>{\n  return Vec(v.y, -v.x);\n}\n\n// 90 degrees counter clockwise\nVec.rotate90CCW = (v)=>{\n  return Vec(-v.y, v.x);\n}\n\nVec.angle = (v) =>{\n  var angleInRadians = Math.atan2(v.y, v.x);\n  var angleInDegrees = ((angleInRadians * 180) / Math.PI)\n  if (angleInDegrees < 0) {\n    angleInDegrees += 360;\n  }\n  return angleInDegrees;\n}\n\nVec.angleBetween = (a, b) => {\n  // Calculate the dot product of the two vectors\n  const dotProduct = Vec.dot(a, b);\n\n  // Calculate the magnitudes of the two vectors\n  const magnitudeA = Vec.len(a);\n  const magnitudeB = Vec.len(b);\n\n  // Calculate the angle between the vectors using the dot product and magnitudes\n  const angleInRadians = Math.acos(dotProduct / (magnitudeA * magnitudeB));\n\n  // Convert the angle from radians to degrees\n  const angleInDegrees = (angleInRadians * 180) / Math.PI;\n\n  return angleInDegrees;\n}\n\nVec.angleBetweenClockwise = (a, b) => {\n  const dP = Vec.dot(a, b);\n  const cP = Vec.cross(a, b);\n\n  let angle = Math.atan2(dP, cP);\n\n  // Convert the angle from radians to degrees\n  let angleInDegrees = angle * (180 / Math.PI);\n  if (angleInDegrees < 0) {\n    angleInDegrees = 360 + angleInDegrees;\n  }\n\n  return angleInDegrees;\n}", "let eventQueue = {\n    pencil: [], // only one pencil - so a list of events\n    touches: {}, // map by touch id to a list of events\n};\n\nwindow.nativeEvent = (eventState, touches) => {\n    Object.entries(touches).forEach(([touchId, points]) => {\n        points.forEach((point) => {\n            if (point.type === \"pencil\") {\n                eventQueue.pencil.push({\n                    // there's more data in `point` that we're ignoring here\n                    type: eventState,\n                    x: point.x,\n                    y: point.y,\n                });\n            } else {\n                if (!eventQueue.touches[touchId]) {\n                    eventQueue.touches[touchId] = [];\n                }\n\n                eventQueue.touches[touchId].push({\n                    type: eventState,\n                    x: point.x,\n                    y: point.y,\n                });\n            }\n        });\n    });\n};\n\n\nlet callback = null\nfunction frame(){\n    callback(eventQueue)\n\n    eventQueue.pencil = []\n    eventQueue.touches = {}\n\n    window.requestAnimationFrame(frame);\n}\n\nexport default (cb) => {\n    callback = cb\n    window.requestAnimationFrame(frame);\n}", "class Canvas {\n    constructor(dom, cb){\n        // SETUP CANVAS\n        this.canvas = document.createElement(\"canvas\")\n        dom.appendChild(this.canvas)\n        const dpr = window.devicePixelRatio\n        let bounds = dom.getBoundingClientRect()\n        this.canvas.width = bounds.width * dpr\n        this.canvas.height = bounds.height * dpr\n        this.ctx = this.canvas.getContext(\"2d\")\n        this.ctx.scale(dpr, dpr)\n\n        // this.canvas.addEventListener(\"touchstart\", e=>e.preventDefault(), false)\n\n        this.callback = cb\n        cb(this.ctx)\n    }\n\n    render(){\n        this.callback(this.ctx)\n    }\n\n}\n\nexport default Canvas", "// Line\n// This is a collection of functions related to line segments written by Marcel with help of ChatGPT\n\nimport Vec from \"./vec.js\"\n\nconst Line = (a, b) =>{\n    return {a, b}\n}\nexport default Line\n\nLine.len = (l)=>{\n    return Vec.dist(l.a, l.b)\n}\n\n// Returns intersection if the line segments overlap, or null if they don't\nLine.intersect = (l1, l2) =>{\n    const { a: p1, b: p2 } = l1;\n    const { a: q1, b: q2 } = l2;\n\n    const dx1 = p2.x - p1.x;\n    const dy1 = p2.y - p1.y;\n    const dx2 = q2.x - q1.x;\n    const dy2 = q2.y - q1.y;\n\n    const determinant = dx1 * dy2 - dy1 * dx2;\n\n    if (determinant === 0) {\n        // The lines are parallel or coincident\n        return null;\n    }\n\n    const dx3 = p1.x - q1.x;\n    const dy3 = p1.y - q1.y;\n\n    const t = (dx3 * dy2 - dy3 * dx2) / determinant;\n    const u = (dx1 * dy3 - dy1 * dx3) / determinant;\n\n    if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n        // The segments intersect at a point\n        const intersectionX = p1.x + t * dx1;\n        const intersectionY = p1.y + t * dy1;\n        return { x: intersectionX, y: intersectionY };\n    }\n\n    // The segments do not intersect\n    return null;\n}\n\n// Always returns intersection point even if the line segments don't overlap\nLine.intersectAnywhere = (l1, l2) =>{\n    const { a: p1, b: p2 } = l1;\n    const { a: q1, b: q2 } = l2;\n  \n    const dx1 = p2.x - p1.x;\n    const dy1 = p2.y - p1.y;\n    const dx2 = q2.x - q1.x;\n    const dy2 = q2.y - q1.y;\n  \n    const determinant = dx1 * dy2 - dy1 * dx2;\n  \n    if (determinant === 0) {\n      // The lines are parallel or coincident\n      return null;\n    }\n  \n    const dx3 = p1.x - q1.x;\n    const dy3 = p1.y - q1.y;\n  \n    const t = (dx3 * dy2 - dy3 * dx2) / determinant;\n    const u = (dx1 * dy3 - dy1 * dx3) / determinant;\n  \n    const intersectionX = p1.x + t * dx1;\n    const intersectionY = p1.y + t * dy1;\n  \n    return { x: intersectionX, y: intersectionY };\n}\n\n// Get point along slope\nLine.getYforX = (line, x) => {\n    // Extract the coordinates of points a and b\n    const { a, b } = line;\n    const { x: x1, y: y1 } = a;\n    const { x: x2, y: y2 } = b;\n    \n    // Calculate the slope of the line\n    const slope = (y2 - y1) / (x2 - x1);\n    \n    // Calculate the y-coordinate for the given x-coordinate\n    const y = slope * (x - x1) + y1;\n    \n    return y;\n}\n\n// Get point along slope\nLine.getXforY = (line, y) => {\n    // Extract the coordinates of points a and b\n    const { a, b } = line;\n    const { x: x1, y: y1 } = a;\n    const { x: x2, y: y2 } = b;\n\n    // Calculate the slope of the line\n    const slope = (y2 - y1) / (x2 - x1);\n\n    // Calculate the x-coordinate for the given y-coordinate\n    const x = (y - y1) / slope + x1;\n\n    return x;\n}\n\n\nLine.distToPoint = (line, point) => {\n    const { a, b } = line;\n\n    // Calculate vector AB and AP\n    const AB = Vec.sub(b, a);\n    const AP = Vec.sub(point, a);\n  \n    // Calculate the projection of AP onto AB\n    const projection = Vec.dot(AP, AB) / Vec.dot(AB, AB);\n  \n    // Check if the projection is outside the line segment\n    if (projection <= 0) {\n        // Closest point is A\n        return Vec.len(AP);\n    } else if (projection >= 1) {\n        // Closest point is B\n        return Vec.dist(point, b);\n    } else {\n        // Closest point is between A and B\n        const closestPoint = Vec.add(a, Vec.mulS(AB, projection));\n        return Vec.dist(point, closestPoint);\n    }\n}", "import Vec from \"./lib/vec.js\"\nimport Line from \"./lib/line.js\"\n\n// Monotonically incrementing id counter\nlet monotonic_ids = 0\n\nclass Point {\n    constructor(pos){\n        this.id = monotonic_ids++\n        this.pos = pos || Vec()\n    }\n\n    render(ctx){\n        ctx.beginPath()\n        ctx.ellipse(this.pos.x, this.pos.y, 3, 3, 0, 0, Math.PI*2);\n        ctx.fill()\n    }\n}\n\nclass LineStroke {\n    constructor(a, b) {\n        this.id = monotonic_ids++\n        this.a = a\n        this.b = b\n    }\n\n    render(ctx, highlight) {\n        ctx.lineWidth = 1.0\n        ctx.strokeStyle = highlight ? \"#F81ED5\" : \"#000000\"\n        ctx.beginPath()\n        ctx.moveTo(this.a.pos.x, this.a.pos.y)\n        ctx.lineTo(this.b.pos.x, this.b.pos.y)\n        ctx.stroke()\n    }\n}\n\nclass WetStroke {\n    constructor(pos) {\n        this.a = pos\n        this.b = Vec.clone(pos)\n\n        this.last_b = Vec.clone(pos)\n        this.velocity = 0\n\n        this.h_snap\n        this.v_snap\n        this.ref_line\n        this.angle_snap\n        this.angle_offset\n        this.len_snap\n        this.point_snap\n\n    }\n\n    update(pos, points, ref_line) {\n        this.b = pos\n        let new_velocity = Vec.dist(this.last_b, this.b)\n        this.last_b = Vec.clone(this.b)\n        this.velocity = 0.05 * new_velocity + (1 - 0.05) * this.velocity // Filter velocity\n        //console.log(this.velocity);\n\n        this.h_snap = false\n        this.v_snap = false\n\n        if(Math.abs(this.a.x-this.b.x) < 10) {\n            this.b.x = this.a.x\n            this.v_snap = true\n        }\n    \n        if(Math.abs(this.a.y-this.b.y) < 10) {\n            this.b.y = this.a.y\n            this.h_snap = true\n        }\n        \n        let snaps = []\n        if(this.velocity < 1.5) {\n            points.forEach(point=>{\n                let sx = Line.getXforY(this, point.pos.y)\n                let sy = Line.getYforX(this, point.pos.x)\n                snaps.push({x: sx, y: point.pos.y, snap: point, type: \"horizontal\"})\n                snaps.push({x: point.pos.x, y: sy, snap: point, type: \"vertical\"})\n            })\n\n            this.point_snap = false\n            snaps.forEach(snap=>{\n                if(Vec.dist(pos, snap) < 10) {\n                    this.b.x = snap.x\n                    this.b.y = snap.y\n                    this.point_snap = snap\n                }\n            })\n        } \n\n        // Snap to point\n        let point_snap = points.find(point=>Vec.dist(point.pos, pos) < 10)\n        if(point_snap) {\n            this.b = point_snap.pos\n            this.point_snap = {snap: point_snap, type: \"coincident\"}\n        }\n\n        \n        // Snap with reference point\n        this.len_snap = false\n        this.angle_snap = false\n        this.angle_offset = null\n        if(ref_line) {\n            this.ref_line = ref_line\n            // Snap lengths\n            let ref_len = Line.len(Line(ref_line.a.pos, ref_line.b.pos))\n            let cur_len = Line.len(Line(this.a, this.b))\n            if(Math.abs(ref_len - cur_len) < 10) {\n                this.b = Vec.add(this.a, Vec.mulS(Vec.normalize(Vec.sub(this.b, this.a)), ref_len))\n                this.len_snap = true\n                cur_len = ref_len\n            }\n\n            // Snap Angles\n            let my_vec = Vec.sub(this.a, this.b)\n            let ref_vec = Vec.sub(ref_line.a.pos, ref_line.b.pos)\n            let ref_angle = Vec.angle(ref_vec)\n            let diff_angle = Vec.angleBetweenClockwise(my_vec, ref_vec)\n\n            let closet_round_angle = Math.round(diff_angle / 90) * 90\n            if(Math.abs(diff_angle - closet_round_angle) < 10) {\n\n                let new_angle = ref_angle + closet_round_angle + 90\n                this.b = Vec.add(this.a, Vec.polar(new_angle, cur_len))\n                this.angle_snap = true\n                this.angle_offset = closet_round_angle + 90\n            }\n        }\n    }\n\n    render(ctx) {\n        ctx.lineWidth = 1.0\n        ctx.strokeStyle = this.len_snap ? \"#F81ED5\" : \"#000000\";\n        ctx.beginPath()\n        ctx.moveTo(this.a.x, this.a.y)\n        ctx.lineTo(this.b.x, this.b.y) \n        ctx.stroke()\n\n        if(this.h_snap || this.v_snap || this.angle_snap) {\n            let projected_a = Vec.add(this.b, Vec.mulS(Vec.sub(this.a, this.b), 100))\n            let projected_b = Vec.add(this.a, Vec.mulS(Vec.sub(this.b, this.a), 100))\n    \n            ctx.lineWidth = 0.25\n            ctx.strokeStyle = \"#F81ED5\"\n            ctx.beginPath()\n            ctx.moveTo(projected_a.x, projected_a.y)\n            ctx.lineTo(projected_b.x, projected_b.y) \n            ctx.stroke()\n        }\n\n        if(this.point_snap) {\n            let projected_a = Vec.add(this.b, Vec.mulS(Vec.sub(this.point_snap.snap.pos, this.b), 100))\n            let projected_b = Vec.add(this.point_snap.snap.pos, Vec.mulS(Vec.sub(this.b, this.point_snap.snap.pos), 100))\n            ctx.lineWidth = 0.25\n            ctx.strokeStyle = \"#F81ED5\"\n            ctx.beginPath()\n            ctx.moveTo(projected_a.x, projected_a.y)\n            ctx.lineTo(projected_b.x, projected_b.y) \n            ctx.stroke()\n        }\n    }\n}\n\nclass DrawSnap { \n    constructor(){\n        this.mode = \"draw\"\n\n        this.wet_stroke = null\n        this.ref_line = null\n        this.points = []\n        this.lines = []\n\n        this.constraints = []\n    }\n\n    find_point_near(pos) {\n        return this.points.find(point=>{\n            return Vec.dist(point.pos, pos) < 10\n        })\n    }\n\n    find_stroke_near(pos) {\n        return this.lines.find(line=>{\n            let dist = Line.distToPoint(Line(line.a.pos, line.b.pos), pos)\n            return dist < 20\n        })\n    }\n\n    begin_stroke(pos) {\n        let found = this.find_point_near(pos)\n        if(found) pos = found.pos\n        this.wet_stroke = new WetStroke(pos)\n    }\n\n    update_stroke(pos){\n        if(this.wet_stroke) {\n            this.wet_stroke.update(pos, this.points, this.ref_line)\n        }\n    }\n\n    end_stroke(pos) {\n        let a = this.find_point_near(this.wet_stroke.a)\n        if(!a) a = new Point(this.wet_stroke.a)\n        this.points.push(a)\n\n        let b = this.find_point_near(this.wet_stroke.b)\n        if(!b) b = new Point(this.wet_stroke.b)\n        this.points.push(b)\n\n        let l = new LineStroke(a, b)\n        this.lines.push(l)\n        \n\n        // record constraints\n        let ws = this.wet_stroke\n        if(ws.v_snap) {this.constraints.push({type: \"vertical\", a, b})}\n        if(ws.h_snap) {this.constraints.push({type: \"horizontal\", a, b})}\n        if(ws.point_snap && ws.point_snap.type != \"coincident\") {this.constraints.push({type: ws.point_snap.type, a:b, b:ws.point_snap.snap})}\n        if(ws.len_snap) {this.constraints.push({type: \"length\", a:l, b:ws.ref_line})}\n        if(ws.angle_snap) {this.constraints.push({type: \"angle\", a:l, b:ws.ref_line})}\n        if(ws.angle_snap) {this.constraints.push({type: \"angle\", a:l, b:ws.ref_line, angle: ws.angle_offset})}\n\n        console.log(this.constraints);\n\n        this.wet_stroke = null\n    }\n    \n    update(events) {\n        // Handle input\n        events.pencil.forEach(event=>{\n            let pos = Vec(event.x, event.y)\n            if(this.mode == \"draw\") {\n                if(event.type == \"began\") {\n                    this.begin_stroke(pos)\n                }\n                if(event.type == \"moved\") {\n                    this.update_stroke(pos)\n                }\n                if(event.type == \"ended\") {\n                    this.end_stroke(pos)\n                }\n            } else if(this.mode == \"move\") {\n                if(event.type == \"began\") {\n                    this.dragging = this.find_point_near(pos)\n                }\n                if(event.type == \"moved\") {\n                    if(this.dragging) {\n                        this.dragging.pos = pos\n                    }\n                }\n                if(event.type == \"ended\") {\n                    this.dragging = false\n                }\n            }\n            \n        })\n\n        Object.entries(events.touches).forEach(([touchId, events])=>{\n            events.forEach(event=>{\n                let pos = Vec(event.x, event.y)\n                if(event.type == \"began\") {\n                    if(this.ref_line == null) {\n                        this.ref_line = this.find_stroke_near(pos)\n                        this.ref_line_id = touchId\n                    }\n\n                    if(Vec.dist(Vec(40,40), pos) < 20) {\n                        if(this.mode == \"draw\") {\n                            this.mode = \"move\"\n                        } else {\n                            this.mode = \"draw\"\n                        }\n                    }\n                }\n    \n                if(event.type == \"ended\") {\n                    //if(this.ref_line_id == touchId){\n                        this.ref_line = null\n                    //}\n                }\n            })\n            \n        })\n    }\n\n    render(ctx) {\n        this.lines.forEach(line=>{\n            line.render(ctx, line == this.ref_line)\n        })\n        this.points.forEach(point=>{\n            point.render(ctx)\n        })\n\n        if(this.wet_stroke) {\n            this.wet_stroke.render(ctx)\n        }\n\n        // Draw toggle\n        ctx.beginPath()\n        ctx.ellipse(40, 40, 20, 20, 0, 0, Math.PI*2)\n        if(this.mode == \"draw\") {\n            ctx.fill()\n        } else {\n            ctx.stroke()\n        }\n\n        ctx.fillText(this.mode, 70, 40)\n    }\n}\n\nexport default DrawSnap", "import Vec from \"./lib/vec.js\";\nimport engine from \"./engine.js\";\nimport Canvas from \"./canvas.js\";\n\nimport DrawSnap from \"./draw_snap.js\"\n\nlet draw = new DrawSnap()\n\nlet canvas = new Canvas(document.body, ctx=>{\n    ctx.clearRect(0,0, window.innerWidth, window.innerHeight);\n    draw.render(ctx)\n\n})\n\nengine((events)=>{\n  draw.update(events)\n  canvas.render()\n})"],
  "mappings": "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",
  "names": []
}
