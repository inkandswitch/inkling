{
  "version": 3,
  "sources": ["../build/engine.js", "../build/canvas.js", "../build/lib/relax-pk.js", "../build/lib/math.js", "../build/lib/vec.js", "../build/lib/line.js", "../build/draw_snap.js", "../build/main.js"],
  "sourcesContent": ["let eventQueue = {\n    pencil: [], // only one pencil - so a list of events\n    touches: {}, // map by touch id to a list of events\n};\n\nwindow.nativeEvent = (eventState, touches) => {\n    Object.entries(touches).forEach(([touchId, points]) => {\n        points.forEach((point) => {\n            if (point.type === \"pencil\") {\n                eventQueue.pencil.push({\n                    // there's more data in `point` that we're ignoring here\n                    type: eventState,\n                    x: point.x,\n                    y: point.y,\n                });\n            } else {\n                if (!eventQueue.touches[touchId]) {\n                    eventQueue.touches[touchId] = [];\n                }\n\n                eventQueue.touches[touchId].push({\n                    type: eventState,\n                    x: point.x,\n                    y: point.y,\n                    timestamp: point.timestamp\n                });\n            }\n        });\n    });\n};\n\n\nlet callback = null\nfunction frame(){\n    callback(eventQueue)\n\n    eventQueue.pencil = []\n    eventQueue.touches = {}\n\n    window.requestAnimationFrame(frame);\n}\n\nexport default (cb) => {\n    callback = cb\n    window.requestAnimationFrame(frame);\n}", "class Canvas {\n    constructor(dom, cb){\n        // SETUP CANVAS\n        this.canvas = document.createElement(\"canvas\")\n        dom.appendChild(this.canvas)\n        const dpr = window.devicePixelRatio\n        let bounds = dom.getBoundingClientRect()\n        this.canvas.width = bounds.width * dpr\n        this.canvas.height = bounds.height * dpr\n        this.ctx = this.canvas.getContext(\"2d\")\n        this.ctx.scale(dpr, dpr)\n\n        // this.canvas.addEventListener(\"touchstart\", e=>e.preventDefault(), false)\n\n        this.callback = cb\n        cb(this.ctx)\n    }\n\n    render(){\n        this.callback(this.ctx)\n    }\n\n}\n\nexport default Canvas", "/**\n * Optimizations that I haven't implemented yet:\n * - equality constraints should be special,\n *   maybe we can keep track of the equivalence between the points,\n *   and keep a map from point -> delta\n *   and every time a delta is applied, we can apply it to all of them (or something)\n * - keep track of \"dirty\" dependencies, that way we don't have to do any work\n *   in calculateDeltas() if nothing has changed.\n *   (similar to Fisher's Continuously Evaluating Expression)\n * - fixed point and var constraints can get baked into knowns set?\n *   (would need to recompute it when a constraint changes, which could be messy)\n */\n\nconst PROPAGATE_KNOWNS = true;\n\n// -------\n\n// inteface Delta {\n//   curb(knowns: { xs, ys, vs }): void;\n//   isSignificant(epsilon: number): boolean;\n//   apply(rho: number): void;\n// }\n\n// -------\n\nexport class Var {\n  constructor(value) {\n    this.value = value;\n  }\n\n  toString() {\n    return `var(${this.value})`;\n  }\n}\n\nclass VarDelta {\n  constructor(v, amount, constraint) {\n    this.v = v;\n    this.amount = amount;\n    this.constraint = constraint;\n  }\n\n  toString() {\n    return `${this.v} += ${this.amount} from ${this.constraint}`;\n  }\n\n  curb(knowns) {\n    if (knowns.vars.has(this.v)) {\n      this.amount = 0;\n    }\n  }\n\n  isSignificant(epsilon) {\n    return Math.abs(this.amount) > epsilon;\n  }\n\n  apply(rho) {\n    this.v.value += this.amount * rho;\n  }\n\n  draw(_rc) {\n    // TODO\n  }\n}\n\n// -------\n\nexport class Point {\n  constructor(x, y, optColor) {\n    this.x = x;\n    this.y = y;\n    if (optColor != null) {\n      this.color = optColor;\n    }\n  }\n\n  toString() {\n    return `(${this.x.toFixed(1)}, ${this.y.toFixed(1)})`;\n  }\n\n  contains(p, rc) {\n    const distSquared =\n      Math.pow(p.x - this.x, 2) + Math.pow(p.y - this.y, 2);\n    return Math.pow(rc.pointRadius, 2) >= distSquared;\n  }\n\n  onClick(rc) {\n    console.log('' + this);\n    for (const t of relax.things) {\n      if (t.involves != null && t.involves(this)) {\n        console.log('* ' + t);\n      }\n    }\n  }\n\n  plus(that) {\n    return new Point(\n      this.x + that.x,\n      this.y + that.y\n    );\n  }\n\n  minus(that) {\n    return new Point(\n      this.x - that.x,\n      this.y - that.y\n    );\n  }\n\n  magnitude() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  distanceTo(that) {\n    return this.minus(that).magnitude();\n  }\n\n  scaledBy(m) {\n    return new Point(\n      this.x * m,\n      this.y * m\n    );\n  }\n\n  rotatedBy(theta) {\n    const t = theta * Math.PI / 180;\n    const c = Math.cos(t);\n    const s = Math.sin(t);\n    return new Point(\n      this.x * c - this.y * s,\n      this.x * s + this.y * c\n    );\n  }\n\n  rotatedAroundBy(axis, theta) {\n    return axis.plus(this.minus(axis).rotatedBy(theta));\n  }\n\n  angleWithXAxis() {\n    return Math.atan2(this.y, this.x) * 180 / Math.PI;\n  }\n\n  angleWithYAxis() {\n    return this.angleWithXAxis() - 90;\n  }\n\n  normalized() {\n    return this.scaledBy(1 / this.magnitude());\n  }\n\n  dot(that) {\n    return this.x * that.x + this.y * that.y;\n  }\n\n  clone() {\n    return new Point(this.x, this.y);\n  }\n\n  draw(rc) {\n    const oldFillStyle = rc.ctxt.fillStyle;\n    rc.ctxt.fillStyle = this.isSelected ? 'yellow' : this.color ?? 'cornflowerblue';\n    rc.ctxt.beginPath();\n    rc.ctxt.arc(rc.toScreenX(this.x), rc.toScreenY(this.y), rc.pointRadius, 0, 2 * Math.PI);\n    rc.ctxt.closePath();\n    rc.ctxt.fill();\n    if (this.selectionIndices && this.selectionIndices.length > 0) {\n      rc.drawSelectionIndices(this);\n    }\n    rc.ctxt.fillStyle = oldFillStyle;\n  }\n}\n\nclass PointDelta {\n  constructor(p, amount, constraint) {\n    this.p = p;\n    this.amount = amount;\n    this.constraint = constraint;\n  }\n\n  toString() {\n    return `${this.p} += ${this.amount} from ${this.constraint}`;\n  }\n\n  curb(knowns) {\n    if (knowns.xs.has(this.p)) {\n      this.amount.x = 0;\n    }\n    if (knowns.ys.has(this.p)) {\n      this.amount.y = 0;\n    }\n  }\n\n  isSignificant(epsilon) {\n    return this.amount.magnitude() > epsilon;\n  }\n\n  apply(rho) {\n    const d = this.amount.scaledBy(rho);\n    this.p.x += d.x;\n    this.p.y += d.y;\n  }\n\n  draw(rc) {\n    const p1 = this.p;\n    const p2 = p1.plus(this.amount);\n\n    const x1 = rc.toScreenX(p1.x);\n    const y1 = rc.toScreenY(p1.y);\n    const x2 = rc.toScreenX(p2.x);\n    const y2 = rc.toScreenY(p2.y);\n    if (Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)) < 0.5) {\n      return;\n    }\n\n    const ctxt = rc.ctxt;\n    const origStrokeStyle = ctxt.strokeStyle;\n    ctxt.strokeStyle = 'rgba(255,0,0,0.5)'\n    ctxt.beginPath();\n\n    ctxt.moveTo(x1, y1);\n    ctxt.lineTo(x2, y2);\n\n    const headSize = rc.pointRadius * 0.8;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const angle = Math.atan2(dy, dx);\n    ctxt.lineTo(x2 - headSize * Math.cos(angle - Math.PI / 6), y2 - headSize * Math.sin(angle - Math.PI / 6));\n    ctxt.moveTo(x2, y2);\n    ctxt.lineTo(x2 - headSize * Math.cos(angle + Math.PI / 6), y2 - headSize * Math.sin(angle + Math.PI / 6));\n\n    ctxt.closePath();\n    ctxt.stroke();\n    ctxt.strokeStyle = origStrokeStyle;\n  }\n}\n\n// -------\n\nclass Line {\n  constructor(p1, p2, optColor) {\n    this.p1 = p1;\n    this.p2 = p2;\n    if (optColor != null) {\n      this.color = optColor;\n    }\n  }\n\n  toString() {\n    return `Line(${this.p1}, ${this.p2})`;\n  }\n\n  involves(thing) {\n    return thing === this.p1 || thing === this.p2;\n  }\n\n  draw(rc) {\n    const oldLineWidth = rc.ctxt.lineWidth;\n    const oldStrokeStyle = rc.ctxt.strokeStyle;\n    rc.ctxt.beginPath();\n    rc.ctxt.moveTo(rc.toScreenX(this.p1.x), rc.toScreenY(this.p1.y));\n    rc.ctxt.lineWidth = 3;\n    rc.ctxt.strokeStyle = this.color ?? 'rgba(0,0,0,0.15)';\n    rc.ctxt.lineTo(rc.toScreenX(this.p2.x), rc.toScreenY(this.p2.y));\n    rc.ctxt.closePath();\n    rc.ctxt.stroke();\n    rc.ctxt.lineWidth = oldLineWidth;\n    rc.ctxt.strokeStyle = oldStrokeStyle;\n  }\n}\n\n// -------\n\n// interface Thing {\n//   involves(Thing): boolean; // optional\n//   contains(Point, Canvas): boolean; // optional\n//   beforeTick(Relax); // optional\n//   propagateKnowns(knowns: { xs, ys, vars }): boolean; // optional\n//   calculateDeltas(knowns: { xs, ys, vars }): Delta[]; // optional\n//   afterTick(Relax); // optional\n//   drawUnder(Canvas); // optional\n//   drawOver(Canvas); // optional\n// }\n\n// -------\n\nexport default class Relax {\n  rho = 0.25;\n  epsilon = 0.001;\n  things = new Set();\n  points = new Set();\n  lines = new Set();\n\n  add(thing) {\n    this.things.add(thing);\n    if (thing instanceof Point) {\n      this.points.add(thing);\n    } else if (thing instanceof Line) {\n      this.lines.add(thing);\n    }\n    return this;\n  }\n\n  find(thingPred) {\n    for (const t of this.things) {\n      if (thingPred(t)) {\n        return t;\n      }\n    }\n    return null;\n  }\n\n  findAll(thingPred) {\n    const ans = [];\n    for (const t of this.things) {\n      if (thingPred(t)) {\n        ans.push(t);\n      }\n    }\n    return ans;\n  }\n\n  remove(unwantedThing) {\n    this.things.delete(unwantedThing);\n    if (unwantedThing instanceof Point) {\n      this.points.delete(unwantedThing);\n    } else if (unwantedThing instanceof Line) {\n      this.lines.delete(unwantedThing);\n    }\n    // TODO: also remove things involving unwantedThing?\n    return this;\n  }\n\n  clear() {\n    this.things.clear();\n    this.points.clear();\n    this.lines.clear();\n    return this;\n  }\n\n  // Every time a thing actually does something, we break out of the loop and start over.\n  // This ensures that the non-finger constraints get their say first.\n  // (Which avoids weirdness \"in the middle\".)\n  propagateKnowns(knowns) {\n    while (true) {\n      let didSomething = false;\n      for (const t of this.things) {\n        if (t.propagateKnowns != null && t.propagateKnowns(knowns)) {\n          didSomething = true;\n          break;\n        }\n      }\n      if (!didSomething) {\n        break;\n      }\n    }\n  }\n\n  runOneIteration() {\n    for (const t of this.things) {\n      if (t.beforeTick != null) {\n        t.beforeTick(this);\n      }\n    }\n\n    const knowns = { xs: new Set(), ys: new Set(), vars: new Set() };\n    if (PROPAGATE_KNOWNS) {\n      this.propagateKnowns(knowns);\n    }\n\n    const allDeltas = [];\n    for (const t of this.things) {\n      if (t.calculateDeltas == null) {\n        continue;\n      }\n      const deltas = t.calculateDeltas(knowns);\n      for (const d of deltas) {\n        d.curb(knowns);\n      }\n      if (deltas.some(d => d.isSignificant(this.epsilon))) {\n        allDeltas.push(...deltas);\n      }\n    }\n\n    let ans;\n    if (allDeltas.length > 0) {\n      for (const d of allDeltas) {\n        d.apply(this.rho);\n      }\n      ans = true;\n    } else {\n      ans = false;\n    }\n\n    for (const t of this.things) {\n      if (t.afterTick != null) {\n        ans = t.afterTick(this) || ans;\n      }\n    }\n\n    return ans;\n  }\n\n  iterateForUpToMillis(\n    milliseconds,\n    beforeEachIterationFn,\n    afterEachIterationFn\n  ) {\n    let count = 0;\n    const t0 = Date.now();\n    Time.nowSeconds = t0 / 1_000;\n    while (Date.now() - t0  < milliseconds) {\n      if (beforeEachIterationFn) {\n        beforeEachIterationFn(count + 1);\n      }\n      const changedSomething = this.runOneIteration(t0);\n      if (afterEachIterationFn) {\n        afterEachIterationFn(count + 1);\n      }\n      if (changedSomething) {\n        count++;\n      } else {\n        break;\n      }\n    }\n    return count;\n  }\n}\n\n// -------\n\nclass FixedVar {\n  constructor(v, wanted) {\n    this.v = v;\n    this.wanted = wanted;\n  }\n\n  involves(_thing) {\n    return false;\n  }\n\n  propagateKnowns(knowns) {\n    if (!knowns.vars.has(this.v)) {\n      this.v.value = this.wanted;\n      knowns.vars.add(this.v);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  calculateDeltas(_knowns) {\n    return [new VarDelta(this.v, this.wanted - this.v.value, this)];\n  }\n\n\n  toString() {\n    return `FixedVar(${this.v}, ${this.wanted})`;\n  }\n}\n\nexport class VarEquals {\n  constructor(v1, v2) {\n    this.v1 = v1;\n    this.v2 = v2;\n  }\n\n  involves(thing) {\n    return thing === this.v1 || thing === this.v2;\n  }\n\n  propagateKnowns(knowns) {\n    if (knowns.vars.has(this.v1) && !knowns.vars.has(this.v2)) {\n      this.v2.value = this.v1.value;\n      knowns.vars.add(this.v2);\n      return true;\n    } else if (knowns.vars.has(this.v2) && !knowns.vars.has(this.v1)) {\n      this.v1.value = this.v2.value;\n      knowns.vars.add(this.v1);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  calculateDeltas(_knowns) {\n    const diff = this.v2.value - this.v1.value;\n    return [\n      new VarDelta(this.v1, diff / 2, this),\n      new VarDelta(this.v2, -diff / 2, this)\n    ];\n  }\n\n\n  toString() {\n    return `VarEquals(${this.v1}, ${this.v2})`;\n  }\n}\n\nexport class FixedPoint {\n  constructor(p, wanted, disablePKs) {\n    this.p = p;\n    this.wanted = wanted;\n    this.pdisablePKsks = disablePKs;\n  }\n\n  involves(thing) {\n    return thing === this.p;\n  }\n\n  propagateKnowns(knowns) {\n    if (this.disablePKs) {\n      return false;\n    }\n\n    let ans = false;\n    if (!knowns.xs.has(this.p)) {\n      this.p.x = this.wanted.x;\n      knowns.xs.add(this.p);\n      ans = true;\n    }\n    if (!knowns.ys.has(this.p)) {\n      this.p.y = this.wanted.y;\n      knowns.ys.add(this.p);\n      ans = true;\n    }\n    return ans;\n  }\n\n  calculateDeltas(_knowns) {\n    return [new PointDelta(this.p, this.wanted.minus(this.p), this)];\n  }\n\n  toString() {\n    return `FixedPoint(${this.p}, ${this.wanted})`;\n  }\n\n  drawOver(rc) {\n    const ctxt = rc.ctxt;\n    const origFillStyle = ctxt.fillStyle;\n    ctxt.fillStyle = 'black';\n    ctxt.beginPath();\n    ctxt.arc(\n      rc.toScreenX(this.wanted.x),\n      rc.toScreenY(this.wanted.y),\n      rc.pointRadius * 0.4,\n      0,\n      2 * Math.PI\n    );\n    ctxt.closePath();\n    ctxt.fill();\n    ctxt.fillStyle = origFillStyle;\n  }\n}\n\nclass ManyPointConstraint {\n  constructor(ps) {\n    this.ps = ps;\n  }\n\n  involves(thing) {\n    return this.ps.includes(thing);\n  }\n\n  propagateKnowns(_knowns) {\n    throw new Error('subclass responsibility');\n  }\n\n  calculateDeltas(_knowns) {\n    throw new Error('subclass responsibility');\n  }\n\n  toString() {\n    return `${this.constructor.name}(${this.ps.join(', ')})`;\n  }\n}\n\nexport class Horizontal extends ManyPointConstraint {\n  constructor(...ps) {\n    super(ps);\n  }\n\n  propagateKnowns(knowns) {\n    const knownY = this.ps.find(p => knowns.ys.has(p))?.y;\n    if (knownY == null) {\n      return false;\n    }\n    let ans = false;\n    for (const p of this.ps) {\n      if (!knowns.ys.has(p)) {\n        p.y = knownY;\n        knowns.ys.add(p);\n        ans = true;\n      }\n    }\n    return ans;\n  }\n\n  calculateDeltas(_knowns) {\n    const avgY = this.ps.map(p => p.y).reduce((a, b) => a + b) / this.ps.length;\n    return this.ps.map(p => new PointDelta(p, new Point(0, avgY - p.y), this));\n  }\n\n  drawUnder(rc) {\n    if (!rc.showConstraints) {\n      return;\n    }\n\n    const ctxt = rc.ctxt;\n    const avgY = this.ps.map(p => p.y).reduce((a, b) => a + b) / this.ps.length;\n\n    const origGlobalAlpha = ctxt.globalAlpha;\n    ctxt.globalAlpha = 0.125;\n    const arr = [5, 10];\n    ctxt.setLineDash(arr);\n    ctxt.beginPath();\n    ctxt.moveTo(0, rc.toScreenY(avgY));\n    ctxt.lineTo(rc.canvas.width, rc.toScreenY(avgY));\n    ctxt.closePath();\n    ctxt.stroke();\n    ctxt.globalAlpha = origGlobalAlpha;\n    ctxt.setLineDash([]);\n  }\n}\n\nexport class Vertical extends ManyPointConstraint {\n  constructor(...ps) {\n    super(ps);\n  }\n\n  propagateKnowns(knowns) {\n    const knownX = this.ps.find(p => knowns.xs.has(p))?.x;\n    if (knownX == null) {\n      return false;\n    }\n    let ans = false;\n    for (const p of this.ps) {\n      if (!knowns.xs.has(p)) {\n        p.x = knownX;\n        knowns.xs.add(p);\n        ans = true;\n      }\n    }\n    return ans;\n  }\n\n  calculateDeltas(_knowns) {\n    const avgX = this.ps.map(p => p.x).reduce((a, b) => a + b) / this.ps.length;\n    return this.ps.map(p => new PointDelta(p, new Point(avgX - p.x, 0), this));\n  }\n\n  drawUnder(rc) {\n    if (!rc.showConstraints) {\n      return;\n    }\n\n    const ctxt = rc.ctxt;\n    const avgX = this.ps.map(p => p.x).reduce((a, b) => a + b) / this.ps.length;\n\n    const origGlobalAlpha = ctxt.globalAlpha;\n    ctxt.globalAlpha = 0.125;\n    ctxt.setLineDash([5, 10]);\n    ctxt.beginPath();\n    ctxt.moveTo(rc.toScreenX(avgX), 0);\n    ctxt.lineTo(rc.toScreenX(avgX), rc.canvas.height);\n    ctxt.closePath();\n    ctxt.stroke();\n    ctxt.globalAlpha = origGlobalAlpha;\n    ctxt.setLineDash([]);\n  }\n}\n\nclass TwoPointConstraint {\n  constructor(p1, p2) {\n    this.p1 = p1;\n    this.p2 = p2;\n  }\n\n  involves(thing) {\n    return thing === this.p1 || thing === this.p2;\n  }\n\n  propagateKnowns(_knowns) {\n    throw new Error('subclass responsibility');\n  }\n\n  calculateDeltas(_knowns) {\n    throw new Error('subclass responsibility');\n  }\n\n  toString() {\n    return `${this.constructor.name}(${this.p1}, ${this.p2})`;\n  }\n}\n\n// TODO: make optMinAmount into a variable\nclass Above extends TwoPointConstraint {\n  constructor(p1, p2, optMinAmount) {\n    super(p1, p2);\n    this.minAmount = optMinAmount == null ? 0 : optMinAmount;\n  }\n\n  propagateKnowns(_knowns) {\n    // this is an inequality, so we can't determine p2 from p1 and vice-versa\n    return false;\n  }\n\n  calculateDeltas(_knowns) {\n    const dy = this.p1.y - this.minAmount - this.p2.y;\n    return dy > 0\n      ? []\n      : [\n        new PointDelta(this.p1, new Point(0, -dy / 2), this),\n        new PointDelta(this.p2, new Point(0, dy / 2), this)\n      ];\n  }\n\n  toString() {\n    return `Above(${this.p1}, ${this.p2}, ${this.minAmount})`;\n  }\n}\n\nexport class Length extends TwoPointConstraint {\n  constructor(p1, p2, length) {\n    super(p1, p2);\n    this.length = length;\n  }\n\n  beforeTick(relax) {\n    delete this.fixedLengthConstraint;\n    for (const t of relax.things) {\n      if (t instanceof FixedVar && t.v === this.length) {\n        this.fixedLengthConstraint = t;\n      }\n    }\n  }\n\n  propagateKnowns(knowns) {\n    if (\n      !knowns.vars.has(this.length) &&\n      knowns.xs.has(this.p1) && knowns.ys.has(this.p1) &&\n      knowns.xs.has(this.p2) && knowns.ys.has(this.p2)\n    ) {\n      this.length.value = this.p1.distanceTo(this.p2);\n      knowns.vars.add(this.length);\n      return true;\n    } else {\n      // if we know p1 and length, p2 could be anywhere along a circle\n      // same for p2 and length.\n      return false;\n    }\n    // TODO: If we know length, p1.x, p1.y, and p2.x we still can't\n    // tell what p2.y should be (b/c there are two possible values).\n    // Should think about coming up with a *directional* `Length`\n    // constraint that doesn't have this problem.\n  }\n\n  calculateDeltas(_knowns) {\n    // TODO: if this.length is known, don't generate a delta for it\n    // TODO: if this.length and one of the points is known, only generate delta for other point\n    // etc.\n    const v12 = this.p2.minus(this.p1);\n    const actualLength = v12.magnitude();\n    const diff = (actualLength - this.length.value) / 3;\n    const e12 = v12.normalized();\n    return [\n      new VarDelta(this.length, diff, this),\n      new PointDelta(this.p1, e12.scaledBy(diff), this),\n      new PointDelta(this.p2, e12.scaledBy(-diff), this)\n    ];\n  }\n\n  toString() {\n    return `Length(${this.p1}, ${this.p2}, ${this.length})`;\n  }\n\n  contains(p, rc) {\n    if (!rc.showConstraints) {\n      return false;\n    }\n\n    const xIsIn =\n      this.p1.x - 10 < p.x && p.x < this.p2.x + 10 ||\n      this.p2.x - 10 < p.x && p.x < this.p1.x + 10;\n\n    const yIsIn =\n      this.p1.y - 10 < p.y && p.y < this.p2.y + 10 ||\n      this.p2.y - 10 < p.y && p.y < this.p1.y + 10;\n\n    return xIsIn && yIsIn;\n  }\n\n  onClick(rc) {\n    if (this.fixedLengthConstraint != null) {\n      rc.remove(this.fixedLengthConstraint);\n    } else {\n      rc.addThing(new FixedVar(this.length, this.length.value));\n    }\n  }\n\n  drawOver(rc) {\n    if (!rc.showConstraints) {\n      return;\n    }\n\n    const ctxt = rc.ctxt;\n    const origLineWidth = ctxt.lineWidth;\n    const origStrokeStyle = ctxt.strokeStyle;\n    const origFillStyle = ctxt.fillStyle;\n    const origFont = ctxt.font;\n    const origTextAlign = ctxt.textAlign;\n    const origTextBaseline = ctxt.textBaseline;\n\n    ctxt.lineWidth = 1;\n    ctxt.strokeStyle = ctxt.fillStyle = 'rgba(0,0,255,0.2)';\n    ctxt.beginPath();\n\n    const angle = Math.atan2(this.p2.y - this.p1.y, this.p2.x - this.p1.x);\n    const dist = 20;\n    const p1x = this.p1.x - dist * Math.cos(angle + Math.PI / 2);\n    const p1y = this.p1.y - dist * Math.sin(angle + Math.PI / 2);\n    const p2x = this.p2.x - dist * Math.cos(angle + Math.PI / 2);\n    const p2y = this.p2.y - dist * Math.sin(angle + Math.PI / 2);\n\n    const textCenterX = rc.toScreenX((p1x + p2x) / 2 - dist / 2 * Math.cos(angle + Math.PI / 2));\n    const textCenterY = rc.toScreenY((p1y + p2y) / 2 - dist / 2 * Math.sin(angle + Math.PI / 2));\n\n    ctxt.moveTo(\n      rc.toScreenX(p1x + 5 * Math.cos(angle + Math.PI / 2)),\n      rc.toScreenY(p1y + 5 * Math.sin(angle + Math.PI / 2))\n    );\n    ctxt.lineTo(\n      rc.toScreenX(p1x - 5 * Math.cos(angle + Math.PI / 2)),\n      rc.toScreenY(p1y - 5 * Math.sin(angle + Math.PI / 2))\n    );\n\n    ctxt.moveTo(rc.toScreenX(p1x), rc.toScreenY(p1y));\n    ctxt.lineTo(rc.toScreenX(p2x), rc.toScreenY(p2y));\n\n    ctxt.moveTo(\n      rc.toScreenX(p2x + 5 * Math.cos(angle + Math.PI / 2)),\n      rc.toScreenY(p2y + 5 * Math.sin(angle + Math.PI / 2))\n    );\n    ctxt.lineTo(\n      rc.toScreenX(p2x - 5 * Math.cos(angle + Math.PI / 2)),\n      rc.toScreenY(p2y - 5 * Math.sin(angle + Math.PI / 2))\n    );\n\n    ctxt.closePath();\n    ctxt.stroke();\n\n    ctxt.textAlign = 'center';\n    ctxt.textBaseline = 'middle';\n    ctxt.font = '14pt PT-sans';\n    ctxt.fillStyle = this.fixedLengthConstraint != null ? 'rgba(0,0,255,0.4)' : 'rgba(255,0,0,0.4)';\n    ctxt.fillText(Math.round(this.length.value), textCenterX, textCenterY);\n\n    ctxt.lineWidth = origLineWidth;\n    ctxt.strokeStyle = origStrokeStyle;\n    ctxt.fillStyle = origFillStyle;\n    ctxt.font = origFont;\n    ctxt.textAlign = origTextAlign;\n    ctxt.textBaseline = origTextBaseline;\n  }\n}\n\nexport class MinLength extends TwoPointConstraint {\n  constructor(p1, p2, length) {\n    super(p1, p2);\n    this.length = length;\n  }\n\n  propagateKnowns(_knowns) {\n    return false;\n  }\n\n  calculateDeltas(_knowns) {\n    const v12 = this.p2.minus(this.p1);\n    const actualLength = v12.magnitude();\n    if (actualLength >= this.length) {\n      return [];\n    }\n\n    const diff = (actualLength - this.length) / 2;\n    const e12 = v12.normalized();\n    return [\n      new PointDelta(this.p1, e12.scaledBy(diff), this),\n      new PointDelta(this.p2, e12.scaledBy(-diff), this)\n    ];\n  }\n\n  toString() {\n    return `MinLength(${this.p1}, ${this.p2}, ${this.length})`;\n  }\n}\n\nclass PointEquals extends TwoPointConstraint {\n  constructor(p1, p2) {\n    super(p1, p2);\n  }\n\n  propagateKnowns(knowns) {\n    let ans = false;\n\n    // xs\n    if (knowns.xs.has(this.p1) && !knowns.xs.has(this.p2)) {\n      this.p2.x = this.p1.x;\n      knowns.xs.add(this.p2);\n      ans = true;\n    } else if (knowns.xs.has(this.p2) && !knowns.xs.has(this.p1)) {\n      this.p1.x = this.p2.x;\n      knowns.xs.add(this.p1);\n      ans = true;\n    }\n\n    // ys\n    if (knowns.ys.has(this.p1) && !knowns.ys.has(this.p2)) {\n      this.p2.y = this.p1.y;\n      knowns.ys.add(this.p2);\n      ans = true;\n    } else if (knowns.ys.has(this.p2) && !knowns.ys.has(this.p1)) {\n      this.p1.y = this.p2.y;\n      knowns.ys.add(this.p1);\n      ans = true;\n    }\n\n    return ans;\n  }\n\n  calculateDeltas(_knowns) {\n    const diff = this.p2.minus(this.p1);\n    return [\n      new PointDelta(this.p1, diff.scaledBy(0.5), this),\n      new PointDelta(this.p2, diff.scaledBy(-0.5), this)\n    ];\n  }\n}\n\nclass ThreePointConstraint {\n  constructor(p1, p2, p3) {\n    this.p1 = p1;\n    this.p2 = p2;\n    this.p3 = p3;\n  }\n\n  involves(thing) {\n    return thing === this.p1 || thing === this.p2 || thing === this.p3;\n  }\n\n  propagateKnowns(_knowns) {\n    throw new Error('subclass responsibility');\n  }\n\n  calculateDeltas(_knowns) {\n    throw new Error('subclass responsibility');\n  }\n\n  toString() {\n    return `${this.constructor.name}(${this.p1}, ${this.p2}, ${this.p3})`;\n  }\n}\n\nclass FourPointConstraint {\n  constructor(p1, p2, p3, p4) {\n    this.p1 = p1;\n    this.p2 = p2;\n    this.p3 = p3;\n    this.p4 = p4;\n  }\n\n  involves(thing) {\n    return thing === this.p1 || thing === this.p2 || thing === this.p3 || thing === this.p4;\n  }\n\n  propagateKnowns(_knowns) {\n    throw new Error('subclass responsibility');\n  }\n\n  calculateDeltas(_knowns) {\n    throw new Error('subclass responsibility');\n  }\n\n  toString() {\n    return `${this.constructor.name}(${this.p1}, ${this.p2}, ${this.p3}, ${this.p4})`;\n  }\n}\n\n// Orientation constraint, i.e., \"Maintain angle between p1->p2 and p3->p4 at theta.\"\nexport class Orientation extends FourPointConstraint {\n  constructor(l1p1, l1p2, l2p1, l2p2, theta) {\n    super(l1p1, l1p2, l2p1, l2p2);\n    this.theta = theta;\n  }\n\n  propagateKnowns(_knowns) {\n    return false;\n  }\n\n  calculateDeltas(_knowns) {\n    const v12 = this.p2.minus(this.p1);\n    const a12 = Math.atan2(v12.y, v12.x);\n    const m12 = this.p1.plus(this.p2).scaledBy(0.5);\n\n    const v34 = this.p4.minus(this.p3);\n    const a34 = Math.atan2(v34.y, v34.x);\n    const m34 = this.p3.plus(this.p4).scaledBy(0.5);\n\n    const currTheta = (a12 - a34 + 2 * Math.PI) % (2 * Math.PI);\n    const dTheta = (this.theta - currTheta) % (2 * Math.PI);\n    // TODO: figure out why setting dTheta to 1/2 times this value (as shown in the paper\n    // and seems to make sense) results in jumpy/unstable behavior.\n\n    return [\n      new PointDelta(this.p1, this.p1.rotatedAroundBy(m12, dTheta).minus(this.p1), this),\n      new PointDelta(this.p2, this.p2.rotatedAroundBy(m12, dTheta).minus(this.p2), this),\n      new PointDelta(this.p3, this.p3.rotatedAroundBy(m34, -dTheta).minus(this.p3), this),\n      new PointDelta(this.p4, this.p4.rotatedAroundBy(m34, -dTheta).minus(this.p4), this),\n    ];\n  }\n\n  currTheta() {\n    const v12 = this.p2.minus(this.p1);\n    const a12 = Math.atan2(v12.y, v12.x);\n\n    const v34 = this.p4.minus(this.p3);\n    const a34 = Math.atan2(v34.y, v34.x);\n\n    return a12 - a34;\n  }\n}\n\n// p1 + p2 = p3\nclass PointPlus extends ThreePointConstraint {\n  constructor(p1, p2, p3) {\n    super(p1, p2, p3);\n  }\n\n  propagateKnowns(knowns) {\n    let ans = false;\n\n    // xs\n    if (knowns.xs.has(this.p1) && knowns.xs.has(this.p2) && !knowns.xs.has(this.p3)) {\n      this.p3.x = this.p1.x + this.p2.x;\n      knowns.xs.add(this.p3);\n      ans = true;\n    } else if (knowns.xs.has(this.p1) && knowns.xs.has(this.p3) && !knowns.xs.has(this.p2)) {\n      this.p2.x = this.p3.x - this.p1.x;\n      knowns.xs.add(this.p2);\n      ans = true;\n    } else if (knowns.xs.has(this.p2) && knowns.xs.has(this.p3) && !knowns.xs.has(this.p1)) {\n      this.p1.x = this.p3.x - this.p2.x;\n      knowns.xs.add(this.p1);\n      ans = true;\n    }\n\n    // ys\n    if (knowns.ys.has(this.p1) && knowns.ys.has(this.p2) && !knowns.ys.has(this.p3)) {\n      this.p3.y = this.p1.y + this.p2.y;\n      knowns.ys.add(this.p3);\n      ans = true;\n    } else if (knowns.ys.has(this.p1) && knowns.ys.has(this.p3) && !knowns.ys.has(this.p2)) {\n      this.p2.y = this.p3.y - this.p1.y;\n      knowns.ys.add(this.p2);\n      ans = true;\n    } else if (knowns.ys.has(this.p2) && knowns.ys.has(this.p3) && !knowns.ys.has(this.p1)) {\n      this.p1.y = this.p3.y - this.p2.y;\n      knowns.ys.add(this.p1);\n      ans = true;\n    }\n\n    return ans;\n  }\n\n  calculateDeltas(_knowns) {\n    const dx = this.p3.x - (this.p1.x + this.p2.x);\n    const dy = this.p3.y - (this.p1.y + this.p2.y);\n    return [\n      new PointDelta(this.p1, new Point(+dx / 3, +dy / 3), this),\n      new PointDelta(this.p2, new Point(+dx / 3, +dy / 3), this),\n      new PointDelta(this.p3, new Point(-dx / 3, -dy / 3), this)\n    ];\n  }\n\n  drawOver(rc) {\n    if (!rc.showConstraints) {\n      return;\n    }\n\n    const avgX = avg(this.p1.x, this.p2.x, this.p3.x);\n    const avgY = avg(this.p1.y, this.p2.y, this.p3.y);\n\n    const equalsX = avgX - 10;\n    const plusX = avgX + 10;\n\n    const ctxt = rc.ctxt;\n    const origLineWidth = ctxt.lineWidth;\n    const origStrokeStyle = ctxt.strokeStyle;\n    const origFillStyle = ctxt.fillStyle;\n    const origFont = ctxt.font;\n    const origTextAlign = ctxt.textAlign;\n    const origTextBaseline = ctxt.textBaseline;\n\n    ctxt.lineWidth = 1;\n    ctxt.strokeStyle = ctxt.fillStyle = 'rgba(255,255,0,1)';\n    ctxt.beginPath();\n\n    ctxt.moveTo(rc.toScreenX(plusX), rc.toScreenY(avgY));\n    ctxt.lineTo(rc.toScreenX(this.p1.x), rc.toScreenY(this.p1.y));\n    ctxt.moveTo(rc.toScreenX(plusX), rc.toScreenY(avgY));\n    ctxt.lineTo(rc.toScreenX(this.p2.x), rc.toScreenY(this.p2.y));\n    ctxt.moveTo(rc.toScreenX(equalsX), rc.toScreenY(avgY));\n    ctxt.lineTo(rc.toScreenX(this.p3.x), rc.toScreenY(this.p3.y));\n\n    ctxt.closePath();\n    ctxt.stroke();\n\n    ctxt.textAlign = 'center';\n    ctxt.textBaseline = 'middle';\n    ctxt.font = '14pt PT-sans';\n    ctxt.fillStyle = 'black';\n    ctxt.fillText('+', rc.toScreenX(plusX), rc.toScreenY(avgY));\n    ctxt.fillText('=', rc.toScreenX(equalsX), rc.toScreenY(avgY));\n\n    ctxt.lineWidth = origLineWidth;\n    ctxt.strokeStyle = origStrokeStyle;\n    ctxt.fillStyle = origFillStyle;\n    ctxt.font = origFont;\n    ctxt.textAlign = origTextAlign;\n    ctxt.textBaseline = origTextBaseline;\n  }\n}\n\n// p1 * n = p2\nclass PointTimes extends TwoPointConstraint {\n  constructor(p1, n, p2) {\n    super(p1, p2);\n    this.n = n;\n  }\n\n  propagateKnowns(knowns) {\n    let ans = false;\n\n    // xs\n    if (knowns.xs.has(this.p1) && knowns.vars.has(this.n) && !knowns.xs.has(this.p2)) {\n      this.p2.x = this.p1.x * this.n.value;\n      knowns.xs.add(this.p2);\n      ans = true;\n    } else if (knowns.xs.has(this.p1) && knowns.xs.has(this.p2) && !knowns.vars.has(this.n)) {\n      this.n.value = this.p2.x / this.p1.x;\n      knowns.vars.add(this.n);\n      ans = true;\n    } else if (knowns.vars.has(this.n) && knowns.xs.has(this.p2) && !knowns.xs.has(this.p1)) {\n      this.p1.x = this.p2.x / this.n.value;\n      knowns.xs.add(this.p1);\n      ans = true;\n    }\n\n    // ys\n    if (knowns.ys.has(this.p1) && knowns.vars.has(this.n) && !knowns.ys.has(this.p2)) {\n      this.p2.y = this.p1.y * this.n.value;\n      knowns.ys.add(this.p2);\n      ans = true;\n    } else if (knowns.ys.has(this.p1) && knowns.ys.has(this.p2) && !knowns.vars.has(this.n)) {\n      this.n.value = this.p2.y / this.p1.y;\n      knowns.vars.add(this.n);\n      ans = true;\n    } else if (knowns.vars.has(this.n) && knowns.ys.has(this.p2) && !knowns.ys.has(this.p1)) {\n      this.p1.y = this.p2.y / this.n.value;\n      knowns.ys.add(this.p1);\n      ans = true;\n    }\n\n    return ans;\n  }\n\n  // TODO: change n, too!\n  calculateDeltas(_knowns) {\n    const xDiff = this.p2.x - this.n.value * this.p1.x;\n    const yDiff = this.p2.y - this.n.value * this.p1.y;\n    return [\n      new PointDelta(this.p1, new Point(+xDiff / 2 / this.n.value, +yDiff / 2 / this.n.value), this),\n      new PointDelta(this.p2, new Point(-xDiff / 2, -yDiff / 2), this)\n    ];\n  }\n}\n\n// -------\n\nclass Time {\n  constructor(v) {\n    this.v = v;\n  }\n\n  propagateKnowns(knowns) {\n    if (!knowns.vars.has(this.v)) {\n      this.v.value = Time.nowSeconds;\n      knowns.vars.add(this.v);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  calculateDeltas(_knowns) {\n    const diff = Time.nowSeconds - this.v.value;\n    return [new VarDelta(this.v, diff, this)];\n  }\n}\n\n// -------\n\nclass Clock extends TwoPointConstraint {\n  constructor(p1, p2, length, speed, nowSeconds) {\n    super(p1, p2);\n    this.length = length;\n    this.speed = speed;\n    this.nowSeconds = nowSeconds;\n  }\n\n  propagateKnowns(knowns) {\n    if (!knowns.vars.has(this.nowSeconds)) {\n      return false;\n    }\n\n    const theta = this.calculateTheta(this.nowSeconds.value);\n    let ans = false;\n\n    // xs\n    if (knowns.xs.has(this.p1) && !knowns.xs.has(this.p2)) {\n      this.p2.x = this.p1.x + this.length * Math.cos(theta);\n      knowns.xs.add(this.p2);\n      ans = true;\n    }\n\n    // xs\n    if (knowns.ys.has(this.p1) && !knowns.ys.has(this.p2)) {\n      this.p2.y = this.p1.y + this.length * Math.sin(theta);\n      knowns.ys.add(this.p2);\n      ans = true;\n    }\n\n    return ans;\n  }\n\n  calculateDeltas(_knowns) {\n    const theta = this.calculateTheta(this.nowSeconds.value);\n    const wantedX = this.p1.x + this.length * Math.cos(theta);\n    const wantedY = this.p1.y + this.length * Math.sin(theta);\n    return [\n      new PointDelta(\n        this.p2,\n        new Point(\n          wantedX - this.p2.x,\n          wantedY - this.p2.y\n        ),\n        this\n      )\n    ];\n  }\n\n  calculateTheta(seconds) {\n    return -seconds / (60 / this.speed) * 2 * Math.PI;\n  }\n}\n\n// -------\n\nclass PropertyPicker {\n  constructor(p, property, v) {\n    if (property !== 'x' && property !== 'y') {\n      throw new Error('PropertyPicker only supports x and y');\n    }\n    this.p = p;\n    this.property = property;\n    this.v = v;\n  }\n\n  involves(thing) {\n    return thing === this.p || thing === this.v;\n  }\n\n  propagateKnowns(knowns) {\n    if (this.property === 'x') {\n      if (knowns.xs.has(this.p) && !knowns.vars.has(this.v)) {\n        this.v.value = this.p.x;\n        knowns.vars.add(this.v);\n        return true;\n      } else if (knowns.vars.has(this.v) && !knowns.xs.has(this.p)) {\n        this.p.x = this.v.value;\n        knowns.xs.add(this.p);\n        return true;\n      }\n    } else if (this.property === 'y') {\n      if (knowns.ys.has(this.p) && !knowns.vars.has(this.v)) {\n        this.v.value = this.p.y;\n        knowns.vars.add(this.v);\n        return true;\n      } else if (knowns.vars.has(this.v) && !knowns.ys.has(this.p)) {\n        this.p.y = this.v.value;\n        knowns.ys.add(this.p);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  calculateDeltas(_knowns) {\n    if (this.property === 'x') {\n      const diff = this.v.value - this.p.x;\n      return [\n        new PointDelta(this.p, new Point(diff / 2, 0), this),\n        new VarDelta(this.v, -diff / 2, this)\n      ];\n    } else if (this.property === 'y') {\n      const diff = this.v.value - this.p.y;\n      return [\n        new PointDelta(this.p, new Point(0, diff / 2), this),\n        new VarDelta(this.v, -diff / 2, this)\n      ];\n    } else {\n      throw new Error('impossible');\n    }\n  }\n}\n\n// -------\n\nclass SpreadsheetCell extends Var {\n  epsilon = 0.001;\n  tinyDelta = 0.000001;\n  maxIterations = 100;\n\n  constructor(inputs /* { xs, ys, vars } */, computeValueFn) {\n    super(0);\n    this.inputs = inputs;\n    this.computeValueFn = computeValueFn;\n  }\n\n  toString() {\n    return `SpreadsheetCell(${this.value}, ${this.computeValueFn.toString().substring(6)})`;\n  }\n\n  involves(thing) {\n    // TODO: this isn't always right, e.g., in the slider example\n    return this.inputs.xs?.includes(thing)\n      || this.inputs.ys?.includes(thing)\n      || this.inputs.vars?.includes(thing);\n  }\n\n  propagateKnowns(knowns) {\n    if (\n      !knowns.vars.has(this) &&\n      this.allKnown(this.inputs.xs, knowns.xs) &&\n      this.allKnown(this.inputs.ys, knowns.ys) &&\n      this.allKnown(this.inputs.vars, knowns.vars)\n    ) {\n      this.value = this.computeValue();\n      knowns.vars.add(this);\n      return true;\n    } else {\n      // TODO: use relaxation if result is known and all but one of the inputs are known\n     return false;\n    }\n  }\n\n  allKnown(inputs, knowns) {\n    return inputs == null || inputs.every(input => knowns.has(input));\n  }\n\n  // Note: this method changes the values of the inputs.\n  // It is the caller's responsibility to snapshot their values before calling this\n  // method, and restore their values afterwards.\n  currentValueHasNoSolution(realKnowns) {\n    const knowns = {\n      vars: {\n        has: (v) => {\n          return v === this || realKnowns.vars?.has(v);\n        }\n      },\n      xs: {\n        has: (p) => {\n          return realKnowns.xs?.has(p);\n        }\n      },\n      ys: {\n        has: (p) => {\n          return realKnowns.ys?.has(p);\n        }\n      }\n    };\n    const error = this.relax(knowns);\n    return error > this.epsilon;\n  }\n\n  relax(knowns) {\n    let idx = 0, error;\n    while (true) {\n      error = this.calculateError();\n      if (idx++ >= this.maxIterations || error <= this.epsilon) {\n        break;\n      }\n\n      let numNonZeroDeltaAmounts = 0;\n      const calculateDeltaAmounts = (things, property, knowns) => {\n        if (things == null) {\n          return null;\n        }\n        const deltaAmounts = [];\n        for (const thing of things) {\n          if (knowns && knowns.has(thing)) {\n            deltaAmounts.push(0);\n            continue;\n          }\n          const m = this.derivativeOfErrorWrt(thing, property);\n          const b = error - m * thing[property];\n          const newValue = -b / m;\n          const deltaAmount = isFinite(newValue) ? newValue - thing[property] : 0;\n          if (deltaAmount !== 0) {\n            numNonZeroDeltaAmounts++;\n          }\n          deltaAmounts.push(deltaAmount);\n        }\n\n        return deltaAmounts;\n      };\n\n      const deltaAmounts = {\n        xs: calculateDeltaAmounts(this.inputs.xs, 'x', knowns.xs),\n        ys: calculateDeltaAmounts(this.inputs.ys, 'y', knowns.ys),\n        vars: calculateDeltaAmounts(this.inputs.vars, 'value', knowns.vars),\n        self: calculateDeltaAmounts([this], 'value', knowns.vars)[0]\n      };\n\n      if (numNonZeroDeltaAmounts === 0) {\n        error = this.calculateError();\n        break;\n      }\n\n      deltaAmounts.xs?.forEach((dx, idx) => this.inputs.xs[idx].x += dx / numNonZeroDeltaAmounts);\n      deltaAmounts.ys?.forEach((dy, idx) => this.inputs.ys[idx].y += dy / numNonZeroDeltaAmounts);\n      deltaAmounts.vars?.forEach((dv, idx) => this.inputs.vars[idx].value += dv / numNonZeroDeltaAmounts);\n      this.value += deltaAmounts.self / numNonZeroDeltaAmounts;\n    }\n    return error;\n  }\n\n  calculateDeltas(knowns) {\n    const snapshot = this.snapshotInputs();\n    const origValue = this.value;\n    const restoreState = () => {\n      this.restoreInputs(snapshot);\n      this.value = origValue;\n    }\n\n    const noSolution = this.currentValueHasNoSolution(knowns);\n    restoreState();\n    if (noSolution) {\n      // Don't mess around b/c that will result in jank!\n      return [];\n    }\n\n    const error = this.relax(knowns);\n    if (error > this.epsilon) {\n      // Didn't find a good solution, so we'll just try to fix the output.\n      if (knowns.vars?.has(this)) {\n        // ... but if we're not allowed to change the output, just give up.\n        restoreState();\n        return [];\n      } else {\n        const newValue = this.computeValue();\n        restoreState();\n        return [new VarDelta(this, newValue - this.value, this)];\n      }\n    }\n    \n    const newValues = {\n      self: this.value,\n      xs: this.inputs.xs?.map(p => p.x),\n      ys: this.inputs.ys?.map(p => p.y),\n      vars: this.inputs.vars?.map(v => v.value)\n    };\n    restoreState();\n    const deltas = [new VarDelta(this, newValues.self - this.value, this)];\n    if (newValues.xs) {\n      deltas.push(\n        ...newValues.xs.map(\n          (newValue, idx) =>\n            new PointDelta(\n              this.inputs.xs[idx],\n              new Point(newValue - this.inputs.xs[idx].x, 0),\n              this\n            )\n        )\n      );\n    }\n    if (newValues.ys) {\n      deltas.push(\n        ...newValues.ys.map(\n          (newValue, idx) =>\n            new PointDelta(\n              this.inputs.ys[idx],\n              new Point(0, newValue - this.inputs.ys[idx].y),\n              this\n            )\n        )\n      );\n    }\n    if (newValues.vars) {\n      deltas.push(\n        ...newValues.vars.map(\n          (newValue, idx) =>\n            new VarDelta(\n              this.inputs.vars[idx],\n              newValue - this.inputs.vars[idx].value,\n              this\n            )\n        )\n      );\n    }\n    return deltas;\n  }\n\n  derivativeOfErrorWrt(thing, property) {\n    const origValue = thing[property];\n\n    const calcDerivative = (x0, x1) => {\n      thing[property] = x0;\n      const y0 = this.calculateError();\n      thing[property] = x1;\n      const y1 = this.calculateError();\n      thing[property] = origValue;\n      return (y1 - y0) / (x1 - x0);\n    }\n\n    let m = calcDerivative(origValue - this.tinyDelta, origValue + this.tinyDelta);\n    if (Math.abs(m) < this.tinyDelta) {\n      m = calcDerivative(origValue, origValue + this.tinyDelta);\n    }\n    if (Math.abs(m) < this.tinyDelta) {\n      m = calcDerivative(origValue - this.tinyDelta, origValue);\n    }\n    return m;\n  }\n\n  calculateError() {\n    return Math.abs(this.computeValue() - this.value);\n  }\n\n  computeValue(setValue) {\n    const v = this.computeValueFn();\n    if (setValue) {\n      this.value = v;\n    }\n    return v;\n  }\n\n  snapshotInputs() {\n    return {\n      xs: this.inputs.xs?.map(p => p.x),\n      ys: this.inputs.ys?.map(p => p.y),\n      vars: this.inputs.vars?.map(v => v.value)\n    };\n  }\n\n  restoreInputs(snapshot) {\n    this.inputs.xs?.forEach((p, idx) => {\n      p.x = snapshot.xs[idx];\n    });\n    this.inputs.ys?.forEach((p, idx) => {\n      p.y = snapshot.ys[idx];\n    });\n    this.inputs.vars?.forEach((v, idx) => v.value = snapshot.vars[idx]);\n  }\n}\n\n// -------\n\nclass MidPoint extends ThreePointConstraint {\n  constructor(p1, pm, p3, optFract) {\n    super(p1, pm, p3);\n    const fract = optFract ?? 0.5;\n    const pmX = new SpreadsheetCell(\n      { xs: [p1, p3] },\n      () =>  p1.x + fract * (p3.x - p1.x)\n    );\n    const pmY = new SpreadsheetCell(\n      { ys: [p1, p3] },\n      () => p1.y +fract * (p3.y - p1.y)\n    );\n    this.constraints = [\n      pmX, new PropertyPicker(pm, 'x', pmX),\n      pmY, new PropertyPicker(pm, 'y', pmY)\n    ];\n  }\n\n  propagateKnowns(knowns) {\n    let ans = false;\n    for (const c of this.constraints) {\n      ans = c.propagateKnowns(knowns) || ans;\n    }\n    return ans;\n  }\n\n  calculateDeltas(knowns) {\n    return this.constraints.flatMap(c => c.calculateDeltas(knowns));\n  }\n}\n\nfunction avg(...xs) {\n  return xs.reduce((a, b) => a + b) / xs.length;\n}\n", "// Math\n// The JS Math APIs aren't great. Here's a few extras that are nice to have.\n\nexport const TAU = Math.PI * 2;\n\nexport const isZero = (v) => {\n  return Number.EPSILON > Math.abs(v);\n};\n\nexport const isNonZero = (v) => {\n  return !Math.zero(v);\n};\n\nexport const avg = (a, b) => {\n  return (a + b) / 2;\n};\n\nexport const clip = (v, min = 0, max = 1) => {\n  return Math.min(Math.max(min, v), max);\n};\n\nexport const lerpN = (input, outputMin = 0, outputMax = 1, doClip = false) => {\n  input *= outputMax - outputMin;\n  input += outputMin;\n  if (doClip) input = clip(input, outputMin, outputMax);\n  return input;\n};\n\n// Prettier really screwed this one up, alas.\n// The args should be: input, inputMin, inputMax, outputMin, outputMax, doClip\nexport const lerp = (i, im = 0, iM = 1, om = 0, oM = 1, doClip = true) => {\n  if (im == iM) return om; // Avoids a divide by zero\n  if (im > iM) [im, iM, om, oM] = [iM, im, oM, om];\n  if (doClip) i = clip(i, im, iM);\n  i -= im;\n  i /= iM - im;\n  return lerpN(i, om, oM, false);\n};\n\nexport const rand = (min = -1, max = 1) => {\n  return lerpN(Math.random(), min, max);\n};\n\nexport const randInt = (min, max) => {\n  return Math.round(rand(min, max));\n};\n\nexport const roundTo = (input, precision) => {\n  // Using the reciprocal avoids floating point errors. Eg: 3/10 is fine, but 3*0.1 is wrong.\n  p = 1 / precision;\n  return Math.round(input * p) / p;\n};\n\nexport const easeInOut = (t) => {\n  let ease = (t) => Math.pow(t, 3);\n  if (t < 0.5) return lerp(ease(t * 2), 0, 1, 0, 0.5);\n  else return lerp(ease((1 - t) * 2), 1, 0, 0.5, 1);\n};", "// Vec\n// This is a port of (part of) Ivan's homemade CoffeeScript vector library.\n\nimport { isZero, roundTo, clip } from \"./math.js\";\n\n// Constructors ///////////////////////////////////////////////////////////////\n\nconst Vec = (x = 0, y = 0) => {\n  return { x, y };\n};\nexport default Vec;\n\nVec.clone = (v) => {\n  return Vec(v.x, v.y);\n};\n\nVec.fromRectXY = (r) => {\n  return Vec(r.x, r.y);\n};\n\nVec.fromRectWH = (r) => {\n  return Vec(r.w, r.h);\n};\n\nVec.fromRectRB = (r) => {\n  return Vec(r.x + r.w, r.y + r.h);\n};\n\nVec.of = (s) => {\n  return Vec(s, s);\n};\n\nVec.random = (scale = 1) => {\n  return Vec.Smul(\n    scale,\n    Vec.complement(Vec.Smul(2, Vec(Math.random(), Math.random())))\n  );\n};\n\nVec.toA = (v) => {\n  return [v.x, v.y];\n};\n\nVec.polar = (angle, length) => {\n  const angleInRadians = (angle * Math.PI) / 180;\n  return Vec(\n    length * Math.cos(angleInRadians),\n    length * Math.sin(angleInRadians)\n  );\n}\n\n// Static Vectors /////////////////////////////////////////////////////////////\n\nVec.x = Object.freeze(Vec(1));\nVec.y = Object.freeze(Vec(0, 1));\nVec.zero = Object.freeze(Vec());\n\n// FP /////////////////////////////////////////////////////////////////////////\n\nVec.map = (f, v) => {\n  return Vec(f(v.x), f(v.y));\n};\n\nVec.map2 = (f, a, b) => {\n  return Vec(f(a.x, b.x), f(a.y, b.y));\n};\n\nVec.reduce = (f, v) => {\n  return f(v.x, v.y);\n};\n\n// Vector Algebra /////////////////////////////////////////////////////////////\n\n// Not really cross product, but close enough\nVec.cross = (a, b) => {\n  return a.x * b.y - a.y * b.x\n};\n\nVec.project = (a, b) => {\n  return Vec.mulS(b, Vec.dot(a, b) / Vec.len2(b));\n};\n\nVec.reject = (a, b) => {\n  return Vec.sub(a, Vec.project(a, b));\n};\n\nVec.scalarProjection = (p, a, b) => {\n  let ap = Vec.sub(p, a)\n  let ab = Vec.normalize(Vec.sub(b, a))\n  let f = Vec.mulS(ab,  Vec.dot(ap, ab))\n  return Vec.add(a, f)\n}\n\n// Piecewise Vector Arithmetic ////////////////////////////////////////////////\n\nVec.add = (a, b) => {\n  return Vec(a.x + b.x, a.y + b.y);\n};\n\nVec.div = (a, b) => {\n  return Vec(a.x / b.x, a.y / b.y);\n};\n\nVec.mul = (a, b) => {\n  return Vec(a.x * b.x, a.y * b.y);\n};\n\nVec.sub = (a, b) => {\n  return Vec(a.x - b.x, a.y - b.y);\n};\n\n// Vector-Scalar Arithmetic ///////////////////////////////////////////////////\n\nVec.addS = (v, s) => {\n  return Vec.add(v, Vec.of(s));\n};\n\nVec.divS = (v, s) => {\n  return Vec.div(v, Vec.of(s));\n};\n\nVec.mulS = (v, s) => {\n  return Vec.mul(v, Vec.of(s));\n};\n\nVec.subS = (v, s) => {\n  return Vec.sub(v, Vec.of(s));\n};\n\n// Scalar-Vector Arithmetic ///////////////////////////////////////////////////\n\nVec.Sadd = (s, v) => {\n  return Vec.add(Vec.of(s), v);\n};\n\nVec.Sdiv = (s, v) => {\n  return Vec.div(Vec.of(s), v);\n};\n\nVec.Smul = (s, v) => {\n  return Vec.mul(Vec.of(s), v);\n};\n\nVec.Ssub = (s, v) => {\n  return Vec.sub(Vec.of(s), v);\n};\n\n// Measurement ////////////////////////////////////////////////////////////////\n\nVec.dist = (a, b) => {\n  return Vec.len(Vec.sub(a, b));\n};\n\n// Strongly recommend using Vec.dist instead of Vec.dist2 (distance-squared)\nVec.dist2 = (a, b) => {\n  return Vec.len2(Vec.sub(a, b));\n};\n\nVec.dot = (a, b) => {\n  return a.x * b.x + a.y * b.y;\n};\n\nVec.equal = (a, b) => {\n  return isZero(Vec.dist2(a, b));\n};\n\n// Strongly recommend using Vec.len instead of Vec.len2 (length-squared)\nVec.len2 = (v) => {\n  return Vec.dot(v, v);\n};\n\nVec.len = (v) => {\n  return Math.sqrt(Vec.dot(v, v));\n};\n\n// Rounding ///////////////////////////////////////////////////////////////////\n\nVec.ceil = (v) => {\n  return Vec.map(Math.ceil, v);\n};\n\nVec.floor = (v) => {\n  return Vec.map(Math.floor, v);\n};\n\nVec.round = (v) => {\n  return Vec.map(Math.round, v);\n};\n\nVec.roundTo = (v, s) => {\n  return Vec.map2(roundTo, v, Vec.of(s));\n};\n\n// Variations ///////////////////////////////////////////////////////////////////\n\nVec.complement = (v) => {\n  return Vec.Ssub(1, v);\n};\n\nVec.half = (v) => {\n  return Vec.divS(v, 2);\n};\n\nVec.normalize = (v) => {\n  return Vec.divS(v, Vec.len(v));\n};\n\nVec.recip = (v) => {\n  return Vec.Sdiv(1, v);\n};\n\n// Prettier really screwed this one up, alas.\n// The args should be: input, inputMin, inputMax, outputMin, outputMax\nVec.renormalize = (v, im, iM, om, oM) => {\n  return Vec.add(\n    Vec.mul(Vec.div(Vec.sub(v, im), Vec.sub(iM, im)), Vec.sub(oM, om)),\n    om\n  );\n};\n\n// Combinations ///////////////////////////////////////////////////////////////////\n\nVec.avg = (a, b) => {\n  return Vec.half(Vec.add(a, b));\n};\n\nVec.lerp = (a, b, t) => {\n  return Vec.add(a, Vec.Smul(t, Vec.sub(b, a)));\n};\n\nVec.max = (a, b) => {\n  return Vec.map2(Math.max, a, b);\n};\n\nVec.min = (a, b) => {\n  return Vec.map2(Math.min, a, b);\n};\n\n// Reflections ///////////////////////////////////////////////////////////////////\n\nVec.abs = (v) => {\n  return Vec.map(Math.abs, v);\n};\n\nVec.invert = (v) => {\n  return Vec(-v.x, -v.y);\n};\n\nVec.invertX = (v) => {\n  return Vec(-v.x, v.y);\n};\n\nVec.invertY = (v) => {\n  return Vec(v.x, -v.y);\n};\n\n// Rotation & angles ///////////////////////////////////////////////////////////\n\n\n// 90 degrees clockwise\nVec.rotate90CW = (v)=>{\n  return Vec(v.y, -v.x);\n}\n\n// 90 degrees counter clockwise\nVec.rotate90CCW = (v)=>{\n  return Vec(-v.y, v.x);\n}\n\nVec.angle = (v) =>{\n  var angleInRadians = Math.atan2(v.y, v.x);\n  var angleInDegrees = ((angleInRadians * 180) / Math.PI)\n  if (angleInDegrees < 0) {\n    angleInDegrees += 360;\n  }\n  return angleInDegrees;\n}\n\nVec.angleBetween = (a, b) => {\n  // Calculate the dot product of the two vectors\n  const dotProduct = Vec.dot(a, b);\n\n  // Calculate the magnitudes of the two vectors\n  const magnitudeA = Vec.len(a);\n  const magnitudeB = Vec.len(b);\n\n  // Calculate the angle between the vectors using the dot product and magnitudes\n  const angleInRadians = Math.acos(dotProduct / (magnitudeA * magnitudeB));\n\n  // Convert the angle from radians to degrees\n  const angleInDegrees = (angleInRadians * 180) / Math.PI;\n\n  return angleInDegrees;\n}\n\nVec.angleBetweenClockwise = (a, b) => {\n  const dP = Vec.dot(a, b);\n  const cP = Vec.cross(a, b);\n\n  let angle = Math.atan2(dP, cP);\n\n  // Convert the angle from radians to degrees\n  let angleInDegrees = angle * (180 / Math.PI);\n  if (angleInDegrees < 0) {\n    angleInDegrees = 360 + angleInDegrees;\n  }\n\n  return angleInDegrees;\n}", "// Line\n// This is a collection of functions related to line segments written by Marcel with help of ChatGPT\n\nimport Vec from \"./vec.js\"\n\nconst Line = (a, b) =>{\n    return {a, b}\n}\nexport default Line\n\nLine.len = (l)=>{\n    return Vec.dist(l.a, l.b)\n}\n\n// Returns intersection if the line segments overlap, or null if they don't\nLine.intersect = (l1, l2) =>{\n    const { a: p1, b: p2 } = l1;\n    const { a: q1, b: q2 } = l2;\n\n    const dx1 = p2.x - p1.x;\n    const dy1 = p2.y - p1.y;\n    const dx2 = q2.x - q1.x;\n    const dy2 = q2.y - q1.y;\n\n    const determinant = dx1 * dy2 - dy1 * dx2;\n\n    if (determinant === 0) {\n        // The lines are parallel or coincident\n        return null;\n    }\n\n    const dx3 = p1.x - q1.x;\n    const dy3 = p1.y - q1.y;\n\n    const t = (dx3 * dy2 - dy3 * dx2) / determinant;\n    const u = (dx1 * dy3 - dy1 * dx3) / determinant;\n\n    if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n        // The segments intersect at a point\n        const intersectionX = p1.x + t * dx1;\n        const intersectionY = p1.y + t * dy1;\n        return { x: intersectionX, y: intersectionY };\n    }\n\n    // The segments do not intersect\n    return null;\n}\n\n// Always returns intersection point even if the line segments don't overlap\nLine.intersectAnywhere = (l1, l2) =>{\n    const { a: p1, b: p2 } = l1;\n    const { a: q1, b: q2 } = l2;\n  \n    const dx1 = p2.x - p1.x;\n    const dy1 = p2.y - p1.y;\n    const dx2 = q2.x - q1.x;\n    const dy2 = q2.y - q1.y;\n  \n    const determinant = dx1 * dy2 - dy1 * dx2;\n  \n    if (determinant === 0) {\n      // The lines are parallel or coincident\n      return null;\n    }\n  \n    const dx3 = p1.x - q1.x;\n    const dy3 = p1.y - q1.y;\n  \n    const t = (dx3 * dy2 - dy3 * dx2) / determinant;\n    const u = (dx1 * dy3 - dy1 * dx3) / determinant;\n  \n    const intersectionX = p1.x + t * dx1;\n    const intersectionY = p1.y + t * dy1;\n  \n    return { x: intersectionX, y: intersectionY };\n}\n\n// Get point along slope\nLine.getYforX = (line, x) => {\n    // Extract the coordinates of points a and b\n    const { a, b } = line;\n    const { x: x1, y: y1 } = a;\n    const { x: x2, y: y2 } = b;\n    \n    // Calculate the slope of the line\n    const slope = (y2 - y1) / (x2 - x1);\n    \n    // Calculate the y-coordinate for the given x-coordinate\n    const y = slope * (x - x1) + y1;\n    \n    return y;\n}\n\n// Get point along slope\nLine.getXforY = (line, y) => {\n    // Extract the coordinates of points a and b\n    const { a, b } = line;\n    const { x: x1, y: y1 } = a;\n    const { x: x2, y: y2 } = b;\n\n    // Calculate the slope of the line\n    const slope = (y2 - y1) / (x2 - x1);\n\n    // Calculate the x-coordinate for the given y-coordinate\n    const x = (y - y1) / slope + x1;\n\n    return x;\n}\n\n\nLine.distToPoint = (line, point) => {\n    const { a, b } = line;\n\n    // Calculate vector AB and AP\n    const AB = Vec.sub(b, a);\n    const AP = Vec.sub(point, a);\n  \n    // Calculate the projection of AP onto AB\n    const projection = Vec.dot(AP, AB) / Vec.dot(AB, AB);\n  \n    // Check if the projection is outside the line segment\n    if (projection <= 0) {\n        // Closest point is A\n        return Vec.len(AP);\n    } else if (projection >= 1) {\n        // Closest point is B\n        return Vec.dist(point, b);\n    } else {\n        // Closest point is between A and B\n        const closestPoint = Vec.add(a, Vec.mulS(AB, projection));\n        return Vec.dist(point, closestPoint);\n    }\n}", "import Vec from './lib/vec.js';\nimport Line from './lib/line.js';\n\n// Monotonically incrementing id counter\nlet nextId = 0;\n\nclass Point {\n    constructor(pos) {\n        this.id = nextId++;\n        this.pos = pos || Vec();\n    }\n\n    render(ctx) {\n        ctx.beginPath();\n        ctx.ellipse(this.pos.x, this.pos.y, 3, 3, 0, 0, Math.PI * 2);\n        ctx.fill();\n    }\n}\n\nfunction addInputElement() {\n    const input = document.createElement('input');\n    input.setAttribute('type', 'text');\n    if (Math.random() > 0.5) {\n        input.value = '2x';\n    }\n    input.style.setProperty('position', 'absolute');\n    input.contentEditable = true;\n    input.onchange = () => {\n        input.value = input.value.toLowerCase();\n        input.blur();\n    };\n    input.setPos = (x, y) => {\n        const rect = input.getBoundingClientRect();\n        input.style.setProperty('left', `${x - rect.width / 2}px`);\n        input.style.setProperty('top', `${y - rect.height / 2}px`);\n    };\n    document.body.appendChild(input);\n    return input;\n}\n\nclass LineStroke {\n    constructor(a, b) {\n        this.id = nextId++;\n        this.a = a;\n        this.b = b;\n        this.input = addInputElement();\n        this.updateInputPos();\n    }\n\n    render(ctx, highlight) {\n        ctx.lineWidth = 1.0;\n        ctx.strokeStyle = highlight ? '#F81ED5' : '#000000';\n        ctx.beginPath();\n        ctx.moveTo(this.a.pos.x, this.a.pos.y);\n        ctx.lineTo(this.b.pos.x, this.b.pos.y);\n        ctx.stroke();\n        this.updateInputPos();\n    }\n\n    updateInputPos() {\n        this.input.setPos(\n            (this.a.pos.x + this.b.pos.x) / 2,\n            (this.a.pos.y + this.b.pos.y) / 2\n        );\n    }\n}\n\nclass WetStroke {\n    constructor(pos) {\n        this.a = pos;\n        this.b = Vec.clone(pos);\n\n        this.last_b = Vec.clone(pos);\n        this.velocity = 0;\n\n        this.h_snap;\n        this.v_snap;\n        this.ref_line;\n        this.angle_snap;\n        this.angle_offset;\n        this.len_snap;\n        this.point_snap;\n    }\n\n    update(pos, points, ref_line) {\n        this.b = pos;\n        let new_velocity = Vec.dist(this.last_b, this.b);\n        this.last_b = Vec.clone(this.b);\n        this.velocity = 0.05 * new_velocity + (1 - 0.05) * this.velocity; // Filter velocity\n        //console.log(this.velocity);\n\n        this.h_snap = false;\n        this.v_snap = false;\n\n        if (Math.abs(this.a.x - this.b.x) < 10) {\n            this.b.x = this.a.x;\n            this.v_snap = true;\n        }\n    \n        if (Math.abs(this.a.y - this.b.y) < 10) {\n            this.b.y = this.a.y;\n            this.h_snap = true;\n        }\n        \n        const snaps = [];\n        if (this.velocity < 1.5) {\n            points.forEach(point => {\n                const sx = Line.getXforY(this, point.pos.y);\n                const sy = Line.getYforX(this, point.pos.x);\n                snaps.push(\n                    { type: 'horizontal', x: sx, y: point.pos.y, snap: point },\n                    { type: 'vertical', x: point.pos.x, y: sy, snap: point },\n                );\n            });\n\n            this.point_snap = false;\n            snaps.forEach(snap => {\n                if (Vec.dist(pos, snap) < 10) {\n                    this.b.x = snap.x;\n                    this.b.y = snap.y;\n                    this.point_snap = snap;\n                }\n            });\n        } \n\n        // Snap to point\n        const point_snap = points.find(point => Vec.dist(point.pos, pos) < 10);\n        if (point_snap) {\n            this.b = point_snap.pos;\n            this.point_snap = { type: 'coincident', snap: point_snap };\n        }\n\n        \n        // Snap with reference point\n        this.len_snap = false;\n        this.angle_snap = false;\n        this.angle_offset = null;\n        if (ref_line) {\n            this.ref_line = ref_line;\n            // Snap lengths\n            const ref_len = Line.len(Line(ref_line.a.pos, ref_line.b.pos));\n            let cur_len = Line.len(Line(this.a, this.b));\n            if (Math.abs(ref_len - cur_len) < 10) {\n                this.b = Vec.add(this.a, Vec.mulS(Vec.normalize(Vec.sub(this.b, this.a)), ref_len));\n                this.len_snap = true;\n                cur_len = ref_len;\n            }\n\n            // Snap Angles\n            const my_vec = Vec.sub(this.a, this.b);\n            const ref_vec = Vec.sub(ref_line.a.pos, ref_line.b.pos);\n\n            const my_angle = Vec.angle(my_vec);\n            const ref_angle = Vec.angle(ref_vec);\n\n            const diff_angle = (my_angle - ref_angle + 360) % 360;\n\n            const closest_round_angle = (Math.round(diff_angle / 90) * 90 + 360) % 360;\n            if (Math.abs(diff_angle - closest_round_angle) < 10) {\n                const new_angle = ref_angle + closest_round_angle;\n                this.b = Vec.add(this.a, Vec.polar(180 + new_angle, cur_len));\n                this.angle_snap = true;\n                this.angle_offset = closest_round_angle;\n            }\n        }\n    }\n\n    render(ctx) {\n        ctx.lineWidth = 1.0;\n        ctx.strokeStyle = this.len_snap ? '#F81ED5' : '#000000';\n        ctx.beginPath();\n        ctx.moveTo(this.a.x, this.a.y);\n        ctx.lineTo(this.b.x, this.b.y);\n        ctx.stroke();\n\n        if (this.h_snap || this.v_snap || this.angle_snap) {\n            const projected_a = Vec.add(this.b, Vec.mulS(Vec.sub(this.a, this.b), 100));\n            const projected_b = Vec.add(this.a, Vec.mulS(Vec.sub(this.b, this.a), 100));\n            ctx.lineWidth = 0.25;\n            ctx.strokeStyle = '#F81ED5';\n            ctx.beginPath();\n            ctx.moveTo(projected_a.x, projected_a.y);\n            ctx.lineTo(projected_b.x, projected_b.y);\n            ctx.stroke();\n        }\n\n        if (this.point_snap) {\n            const projected_a = Vec.add(this.b, Vec.mulS(Vec.sub(this.point_snap.snap.pos, this.b), 100));\n            const projected_b = Vec.add(this.point_snap.snap.pos, Vec.mulS(Vec.sub(this.b, this.point_snap.snap.pos), 100));\n            ctx.lineWidth = 0.25;\n            ctx.strokeStyle = '#F81ED5';\n            ctx.beginPath();\n            ctx.moveTo(projected_a.x, projected_a.y);\n            ctx.lineTo(projected_b.x, projected_b.y);\n            ctx.stroke();\n        }\n\n        if (this.ref_line) {\n            const ref_len = Line.len(Line(this.ref_line.a.pos, this.ref_line.b.pos));\n\n            const normalized_line = Vec.normalize(Vec.sub(this.b, this.a));\n\n            const long_b = Vec.add(this.a, Vec.mulS(normalized_line, 10000));\n            const len_vec = Vec.mulS(normalized_line, ref_len);\n\n            ctx.lineWidth = 0.25;\n            ctx.strokeStyle = '#F81ED5';\n\n            ctx.beginPath();\n            ctx.moveTo(this.a.x, this.a.y);\n            ctx.lineTo(long_b.x, long_b.y);\n            ctx.stroke();\n\n            for (let i = 0; i < 10; i += 0.25) {\n                const size = i % 1 === 0.0 ? 6 : 3;\n                const perpendicular = Vec.mulS(Vec.rotate90CCW(normalized_line), size);\n\n                const snap_pt = Vec.add(this.a, Vec.mulS(len_vec, i));\n                const snap_perp_a = Vec.add(snap_pt, perpendicular);\n                const snap_perp_b = Vec.sub(snap_pt, perpendicular);\n                ctx.beginPath();\n                ctx.moveTo(snap_perp_a.x, snap_perp_a.y);\n                ctx.lineTo(snap_perp_b.x, snap_perp_b.y);\n                ctx.stroke();\n            }\n        }\n    }\n}\n\nclass DrawSnap { \n    constructor(){\n        this.mode = 'draw';\n\n        this.wet_stroke = null;\n        this.ref_line = null;\n        this.points = [];\n        this.lines = [];\n\n        this.constraints = [];\n\n        this.___addLine({ x: 100, y: 100 }, { x: 300, y: 200 });\n        this.___addLine({ x: 150, y: 150 }, { x: 150, y: 400 });\n    }\n\n    find_point_near(pos) {\n        return this.points.find(point => Vec.dist(point.pos, pos) < 10);\n    }\n\n    find_stroke_near(pos) {\n        return this.lines.find(line=> {\n            const dist = Line.distToPoint(Line(line.a.pos, line.b.pos), pos);\n            return dist < 20;\n        })\n    }\n\n    begin_stroke(pos) {\n        const found = this.find_point_near(pos);\n        if (found) pos = found.pos;\n        this.wet_stroke = new WetStroke(pos);\n    }\n\n    update_stroke(pos){\n        if (this.wet_stroke) {\n            this.wet_stroke.update(pos, this.points, this.ref_line);\n        }\n    }\n\n    ___addLine(pos1, pos2) {\n        const p1 = new Point(pos1);\n        const p2 = new Point(pos2);\n        this.points.push(p1, p2);\n        const l = new LineStroke(p1, p2);\n        this.lines.push(l);\n    }\n\n    end_stroke(pos) {\n        let a = this.find_point_near(this.wet_stroke.a);\n        if (!a) a = new Point(this.wet_stroke.a);\n        this.points.push(a);\n\n        let b = this.find_point_near(this.wet_stroke.b);\n        if (!b) b = new Point(this.wet_stroke.b);\n        this.points.push(b);\n\n        const l = new LineStroke(a, b);\n        this.lines.push(l);\n        \n\n        // record constraints\n        this.constraints.push({ type: 'minLength', a:l, b: 50 });\n        const ws = this.wet_stroke;\n        if (ws.v_snap) {\n            this.constraints.push({ type: 'vertical', a, b });\n        }\n        if (ws.h_snap) {\n            this.constraints.push({ type: 'horizontal', a, b });\n        }\n        if (ws.point_snap && ws.point_snap.type != 'coincident') {\n            this.constraints.push({ type: ws.point_snap.type, a: b, b: ws.point_snap.snap });\n        }\n        if (ws.len_snap) {\n            this.constraints.push({ type: 'length', a: l, b: ws.ref_line });\n        }\n        if (ws.angle_snap && !ws.v_snap && !ws.h_snap) {\n            this.constraints.push({ type: 'angle', a: l, b: ws.ref_line, angle: ws.angle_offset });\n        }\n\n        // console.log(this.constraints);\n\n        this.wet_stroke = null\n    }\n    \n    update(events) {\n        // Handle input\n        events.pencil.forEach(event => {\n            const pos = Vec(event.x, event.y);\n            if (this.mode === 'draw') {\n                if (event.type === 'began') {\n                    this.begin_stroke(pos);\n                } else if (event.type === 'moved') {\n                    this.update_stroke(pos);\n                } else if (event.type === 'ended') {\n                    this.end_stroke(pos);\n                }\n            } else if (this.mode.startsWith('move')) {\n                if (event.type === 'began') {\n                    this.dragging = this.find_point_near(pos);\n                    if (this.dragging) {\n                        let fixedPointDistance = -Infinity;\n                        for (const p of this.points) {\n                            const distance = Vec.dist(this.dragging.pos, p.pos);\n                            if (distance > fixedPointDistance) {\n                                fixedPointDistance = distance;\n                                this.fixedPoint = p;\n                            }\n                        }\n                    }\n                }\n                if (event.type === 'moved') {\n                    if (this.dragging) {\n                        this.dragging.pos = pos;\n                    }\n                }\n                if (event.type === 'ended') {\n                    this.dragging = false;\n                    this.fixedPoint = null;\n                }\n            }\n        });\n\n        Object.entries(events.touches).forEach(([touchId, events]) => {\n            events.forEach(event => {\n                const pos = Vec(event.x, event.y);\n                if (event.type === 'began') {\n                    const found = this.find_stroke_near(pos);\n                    if (this.ref_line === found) {\n                        this.ref_line = null;\n                    } else {\n                        this.ref_line = found;\n                        this.finger_down_time = event.timestamp;\n                    }\n\n                    this.ref_line_id = touchId;\n\n                    if (Vec.dist(Vec(40, 40), pos) < 20) {\n                        this.toggleModes();\n                    }\n                }\n    \n                if (event.type == 'ended') {\n                    if (event.timestamp - this.finger_down_time > 1.0) {\n                        this.ref_line = null;\n                    }\n                }\n            }); \n        });\n    }\n\n    toggleModes() {\n        if (this.mode === 'draw') {\n            this.mode = 'move';\n        } else if (this.mode === 'move') {\n            this.mode = 'move-v2';\n        } else if (this.mode === 'move-v2') {\n            this.mode = 'scribble';\n            for (const input of document.body.getElementsByTagName('input')) {\n                input.placeholder = '...';\n            }\n        } else {\n            for (const input of document.body.getElementsByTagName('input')) {\n                input.placeholder = '';\n                input.blur();\n            }\n            this.mode = 'draw';\n        }\n        document.body.className = this.mode;\n        return this.mode;\n    }\n\n    render(ctx) {\n        this.lines.forEach(line => {\n            line.render(ctx, line === this.ref_line);\n        })\n        this.points.forEach(point => {\n            point.render(ctx);\n        })\n\n        if (this.wet_stroke) {\n            this.wet_stroke.render(ctx);\n        }\n\n        // Draw toggle\n        ctx.beginPath();\n        ctx.ellipse(40, 40, 20, 20, 0, 0, Math.PI * 2);\n        if (this.mode === 'draw') {\n            ctx.fill();\n        } else {\n            ctx.stroke();\n        }\n\n        ctx.fillText(this.mode, 70, 40);\n    }\n}\n\nexport default DrawSnap;\n", "import engine from './engine.js';\nimport Canvas from './canvas.js';\nimport Relax, {\n  FixedPoint,\n  Horizontal,\n  Length,\n  MinLength,\n  Orientation,\n  Point as RPoint,\n  Var,\n  Vertical,\n} from './lib/relax-pk.js';\n\nimport DrawSnap from './draw_snap.js';\n\n// import numeric from 'numeric';\n// console.log(numeric.uncmin(vs => Math.pow(vs[0] - 5, 2) + Math.pow(vs[1] - 3, 2), [0, 0]));\n\nconst draw = new DrawSnap();\n// draw.toggleModes();\n// draw.toggleModes();\n// draw.toggleModes();\nwindow.draw = draw;\n\nconst canvas = new Canvas(document.body, ctx => {\n  ctx.clearRect(0,0, window.innerWidth, window.innerHeight);\n  draw.render(ctx);\n});\n\n// setInterval(\n//   () => {\n//     if (document.activeElement != null) {\n//       console.log('blurring active element', document.activeElement);\n//       document.activeElement.blur();\n//     }\n//   },\n//   100\n// );\n\nengine((events) => {\n  draw.update(events);\n  relax();\n  canvas.render();\n});\n\nfunction relax() {\n  const r = new Relax();\n  addHandOfGodConstraints(r);\n  for (const c of draw.constraints) {\n    addConstraints(r, c);\n  }\n  r.iterateForUpToMillis(15);\n}\n\nfunction addHandOfGodConstraints(r) {\n  if (!draw.mode.startsWith('move') || !draw.dragging) {\n    return;\n  }\n\n  function addFixedPointConstraint(dp) {\n    const p = toRPoint(dp.pos);\n    dp.pos = p;\n    r.add(new FixedPoint(p, new RPoint(p.x, p.y)));\n  }\n\n  addFixedPointConstraint(draw.dragging);\n  if (draw.mode === 'move-v2') {\n    addFixedPointConstraint(draw.fixedPoint);\n  }\n}\n\nfunction addConstraints(r, c) {\n  if (c.type === 'vertical') {\n    c.a.pos = toRPoint(c.a.pos);\n    c.b.pos = toRPoint(c.b.pos);\n    r.add(new Vertical(c.a.pos, c.b.pos));\n  }\n\n  if (c.type === 'horizontal') {\n    c.a.pos = toRPoint(c.a.pos);\n    c.b.pos = toRPoint(c.b.pos);\n    r.add(new Horizontal(c.a.pos, c.b.pos));\n  }\n\n  if (c.type === 'length') {\n    c.a.a.pos = toRPoint(c.a.a.pos);\n    c.a.b.pos = toRPoint(c.a.b.pos);\n    c.b.a.pos = toRPoint(c.b.a.pos);\n    c.b.b.pos = toRPoint(c.b.b.pos);\n    const v = new Var(c.a.a.pos.distanceTo(c.a.b.pos));\n    r.add(new Length(c.a.a.pos, c.a.b.pos, v));\n    r.add(new Length(c.b.a.pos, c.b.b.pos, v));\n  }\n\n  if (c.type === 'minLength') {\n    c.a.a.pos = toRPoint(c.a.a.pos);\n    c.a.b.pos = toRPoint(c.a.b.pos);\n    r.add(new MinLength(c.a.a.pos, c.a.b.pos, c.b));\n  }\n\n  if (c.type === 'angle') {\n    c.a.a.pos = toRPoint(c.a.a.pos);\n    c.a.b.pos = toRPoint(c.a.b.pos);\n    c.b.a.pos = toRPoint(c.b.a.pos);\n    c.b.b.pos = toRPoint(c.b.b.pos);\n    r.add(new Orientation(c.a.a.pos, c.a.b.pos, c.b.a.pos, c.b.b.pos, Math.PI * c.angle / 180));\n  }\n}\n\nfunction toRPoint(p) {\n  return p instanceof RPoint ? p : new RPoint(p.x, p.y);\n}"],
  "mappings": "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",
  "names": []
}
