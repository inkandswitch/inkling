{
  "version": 3,
  "sources": ["../build/lib/math.js", "../build/lib/vec.js", "../build/engine.js", "../build/canvas.js", "../build/draw.js", "../build/main.js"],
  "sourcesContent": ["// Math\n// The JS Math APIs aren't great. Here's a few extras that are nice to have.\n\nexport const TAU = Math.PI * 2;\n\nexport const isZero = (v) => {\n  return Number.EPSILON > Math.abs(v);\n};\n\nexport const isNonZero = (v) => {\n  return !Math.zero(v);\n};\n\nexport const avg = (a, b) => {\n  return (a + b) / 2;\n};\n\nexport const clip = (v, min = 0, max = 1) => {\n  return Math.min(Math.max(min, v), max);\n};\n\nexport const lerpN = (input, outputMin = 0, outputMax = 1, doClip = false) => {\n  input *= outputMax - outputMin;\n  input += outputMin;\n  if (doClip) input = clip(input, outputMin, outputMax);\n  return input;\n};\n\n// Prettier really screwed this one up, alas.\n// The args should be: input, inputMin, inputMax, outputMin, outputMax, doClip\nexport const lerp = (i, im = 0, iM = 1, om = 0, oM = 1, doClip = true) => {\n  if (im == iM) return om; // Avoids a divide by zero\n  if (im > iM) [im, iM, om, oM] = [iM, im, oM, om];\n  if (doClip) i = clip(i, im, iM);\n  i -= im;\n  i /= iM - im;\n  return lerpN(i, om, oM, false);\n};\n\nexport const rand = (min = -1, max = 1) => {\n  return lerpN(Math.random(), min, max);\n};\n\nexport const randInt = (min, max) => {\n  return Math.round(rand(min, max));\n};\n\nexport const roundTo = (input, precision) => {\n  // Using the reciprocal avoids floating point errors. Eg: 3/10 is fine, but 3*0.1 is wrong.\n  p = 1 / precision;\n  return Math.round(input * p) / p;\n};\n\nexport const easeInOut = (t) => {\n  let ease = (t) => Math.pow(t, 3);\n  if (t < 0.5) return lerp(ease(t * 2), 0, 1, 0, 0.5);\n  else return lerp(ease((1 - t) * 2), 1, 0, 0.5, 1);\n};\n", "// Vec\n// This is a port of (part of) Ivan's homemade CoffeeScript vector library.\n// Feel free to add new functions as needed. And if we want additional vector\n// graphic libs, Ivan has a bunch: matrices, rectangles, etc.\n// Vecs aren't frozen, but the library treats them as immutable.\n// Worth saying â€” this code is much nicer in CoffeeScript (sorry), and holy cow\n// it'd be nice to have real operator overloading in JS. Anyway...\n// Feel free to make your own {x,y} objects, or manipulate Vecs yourself,\n// instead of using the functions here. They're just here if you want 'um.\n\nimport { isZero, roundTo, clip } from \"./math.js\";\n\n// Constructors ///////////////////////////////////////////////////////////////\n\nconst Vec = (x = 0, y = 0) => {\n  return { x, y };\n};\nexport default Vec;\n\nVec.clone = (v) => {\n  return Vec(v.x, v.y);\n};\n\nVec.fromRectXY = (r) => {\n  return Vec(r.x, r.y);\n};\n\nVec.fromRectWH = (r) => {\n  return Vec(r.w, r.h);\n};\n\nVec.fromRectRB = (r) => {\n  return Vec(r.x + r.w, r.y + r.h);\n};\n\nVec.of = (s) => {\n  return Vec(s, s);\n};\n\nVec.random = (scale = 1) => {\n  return Vec.Smul(\n    scale,\n    Vec.complement(Vec.Smul(2, Vec(Math.random(), Math.random())))\n  );\n};\n\nVec.toA = (v) => {\n  return [v.x, v.y];\n};\n\n// Static Vectors /////////////////////////////////////////////////////////////\n\nVec.x = Object.freeze(Vec(1));\nVec.y = Object.freeze(Vec(0, 1));\nVec.zero = Object.freeze(Vec());\n\n// FP /////////////////////////////////////////////////////////////////////////\n\nVec.map = (f, v) => {\n  return Vec(f(v.x), f(v.y));\n};\n\nVec.map2 = (f, a, b) => {\n  return Vec(f(a.x, b.x), f(a.y, b.y));\n};\n\nVec.reduce = (f, v) => {\n  return f(v.x, v.y);\n};\n\n// Vector Algebra /////////////////////////////////////////////////////////////\n\nVec.cross = () => {\n  throw new Error(\"There is no cross product in 2D\");\n  return;\n};\n\nVec.project = (a, b) => {\n  return Vec.mulS(b, Vec.dot(a, b) / Vec.len2(b));\n};\n\nVec.reject = (a, b) => {\n  return Vec.sub(a, Vec.project(a, b));\n};\n\n\nVec.scalarProjection = (p, a, b) => {\n  let ap = Vec.sub(p, a)\n  let ab = Vec.normalize(Vec.sub(b, a))\n  let f = Vec.mulS(ab,  Vec.dot(ap, ab))\n  return Vec.add(a, f)\n}\n\n// Piecewise Vector Arithmetic ////////////////////////////////////////////////\n\nVec.add = (a, b) => {\n  return Vec(a.x + b.x, a.y + b.y);\n};\n\nVec.div = (a, b) => {\n  return Vec(a.x / b.x, a.y / b.y);\n};\n\nVec.mul = (a, b) => {\n  return Vec(a.x * b.x, a.y * b.y);\n};\n\nVec.sub = (a, b) => {\n  return Vec(a.x - b.x, a.y - b.y);\n};\n\n// Vector-Scalar Arithmetic ///////////////////////////////////////////////////\n\nVec.addS = (v, s) => {\n  return Vec.add(v, Vec.of(s));\n};\n\nVec.divS = (v, s) => {\n  return Vec.div(v, Vec.of(s));\n};\n\nVec.mulS = (v, s) => {\n  return Vec.mul(v, Vec.of(s));\n};\n\nVec.subS = (v, s) => {\n  return Vec.sub(v, Vec.of(s));\n};\n\n// Scalar-Vector Arithmetic ///////////////////////////////////////////////////\n\nVec.Sadd = (s, v) => {\n  return Vec.add(Vec.of(s), v);\n};\n\nVec.Sdiv = (s, v) => {\n  return Vec.div(Vec.of(s), v);\n};\n\nVec.Smul = (s, v) => {\n  return Vec.mul(Vec.of(s), v);\n};\n\nVec.Ssub = (s, v) => {\n  return Vec.sub(Vec.of(s), v);\n};\n\n// Measurement ////////////////////////////////////////////////////////////////\n\nVec.dist = (a, b) => {\n  return Vec.len(Vec.sub(a, b));\n};\n\n// Strongly recommend using Vec.dist instead of Vec.dist2 (distance-squared)\nVec.dist2 = (a, b) => {\n  return Vec.len2(Vec.sub(a, b));\n};\n\nVec.dot = (a, b) => {\n  return a.x * b.x + a.y * b.y;\n};\n\nVec.equal = (a, b) => {\n  return isZero(Vec.dist2(a, b));\n};\n\n// Strongly recommend using Vec.len instead of Vec.len2 (length-squared)\nVec.len2 = (v) => {\n  return Vec.dot(v, v);\n};\n\nVec.len = (v) => {\n  return Math.sqrt(Vec.dot(v, v));\n};\n\n// Rounding ///////////////////////////////////////////////////////////////////\n\nVec.ceil = (v) => {\n  return Vec.map(Math.ceil, v);\n};\n\nVec.floor = (v) => {\n  return Vec.map(Math.floor, v);\n};\n\nVec.round = (v) => {\n  return Vec.map(Math.round, v);\n};\n\nVec.roundTo = (v, s) => {\n  return Vec.map2(roundTo, v, Vec.of(s));\n};\n\n// Variations ///////////////////////////////////////////////////////////////////\n\nVec.complement = (v) => {\n  return Vec.Ssub(1, v);\n};\n\nVec.half = (v) => {\n  return Vec.divS(v, 2);\n};\n\nVec.normalize = (v) => {\n  return Vec.divS(v, Vec.len(v));\n};\n\nVec.recip = (v) => {\n  return Vec.Sdiv(1, v);\n};\n\n// Prettier really screwed this one up, alas.\n// The args should be: input, inputMin, inputMax, outputMin, outputMax\nVec.renormalize = (v, im, iM, om, oM) => {\n  return Vec.add(\n    Vec.mul(Vec.div(Vec.sub(v, im), Vec.sub(iM, im)), Vec.sub(oM, om)),\n    om\n  );\n};\n\n// Combinations ///////////////////////////////////////////////////////////////////\n\nVec.avg = (a, b) => {\n  return Vec.half(Vec.add(a, b));\n};\n\nVec.lerp = (a, b, t) => {\n  return Vec.add(a, Vec.Smul(t, Vec.sub(b, a)));\n};\n\nVec.max = (a, b) => {\n  return Vec.map2(Math.max, a, b);\n};\n\nVec.min = (a, b) => {\n  return Vec.map2(Math.min, a, b);\n};\n\n// Reflections ///////////////////////////////////////////////////////////////////\n\nVec.abs = (v) => {\n  return Vec.map(Math.abs, v);\n};\n\nVec.invert = (v) => {\n  return Vec(-v.x, -v.y);\n};\n\nVec.invertX = (v) => {\n  return Vec(-v.x, v.y);\n};\n\nVec.invertY = (v) => {\n  return Vec(v.x, -v.y);\n};\n\n// Niceness for Crosscut //////////////////////////////////////////////////////////////////////////\n\nVec.midpoint = Vec.avg;\n\n// This will give you the normalized position (0 to 1) of a point that lies somewhere along a line.\n// p is the point whose position we want.\n// lineA and lineB are the endpoints of the line.\n// The return value will be 0 if p is right on top of lineA.\nVec.intersectionPosition = (p, lineA, lineB) => {\n  if (Vec.equal(lineA, lineB)) return 0; // Avoid divide-by-zero\n  return Vec.dist(p, lineA) / Vec.dist(lineA, lineB);\n};\n\nVec.distPointLine = (p, lineA, lineB) => {\n  // Here's my favourite (visual) explanation of the math that follows: https://www.youtube.com/watch?v=PMltMdi1Wzg\n\n  // Treat the lineA point as the origin, and make 2 vectors relative to it:\n  const vecToP = Vec.sub(p, lineA); // A vector from the origin to the target point.\n  const vecToB = Vec.sub(lineB, lineA); // A vector from the origin to the other end of the line.\n\n  // Imagine that the line from lineA to lineB actually stretches off to infinity in both directions.\n  // There's some imaginary point along this line that is closest to our target point.\n  // Let's call that imaginary point Q.\n  // We will compute where Q is along this line, relative to A and B.\n  // If Q is between A and B, we get numbers in the range 0-1. If Q is before A, we get < 0. If Q is after B, we get > 1.\n  let relativePosition = Vec.dot(vecToP, vecToB) / Vec.len2(vecToB);\n\n  // Now, let's clip this relativePosition to the range 0-1.\n  relativePosition = clip(relativePosition);\n\n  // Take the vector between A and B, and scale by this relative position.\n  // This gives us the actual point Q, but limited so that it can't go past A or B.\n  let vecToQ = Vec.mulS(vecToB, relativePosition);\n\n  // Boom! Now we can take the distance between our target point and point Q\n  return Vec.dist(vecToP, vecToQ);\n};\n\nVec.distPointAABBPerimeter = (p, aabb) => {\n  // Here's my favourite (visual) explanation of the math that follows: https://www.youtube.com/watch?v=62-pRVZuS5c\n\n  // Treat the aabb center as the origin.\n  p = Vec.sub(p, aabb.center);\n  // The aabb is symmetrical on both axes, so we can simplify to just the bottom-right quadrant\n  // (where everything is positive).\n  p = Vec.abs(p);\n  let size = Vec(aabb.width / 2, aabb.height / 2);\n  // Along each axis, get the distance between the point and the aabb perimeter.\n  let q = Vec.sub(p, size);\n\n  // It might seem like we could stop now, but the above doesn't correctly handle the case where\n  // the target point is outside the rect and closest to a corner (rather than an edge).\n  // To handle the corner, we need to get a little fancier.\n\n  // If the point is outside the aabb, this will be the distance from the point to the closest edge,\n  // or to the corner. If the point is inside, this will be zero.\n  let outside = Vec.len(Vec.max(q, Vec.zero));\n  // If the point is inside the aabb, this will be the negative(!) distance from the point to the closest edge.\n  // If the point is outside, this will be zero.\n  let inside = Math.min(Math.max(q.x, q.y), 0);\n  // Boom! We've got the signed distance between a point and an aabb.\n  let signedDistance = outside + inside;\n\n  // Since we don't care about the sign, we will just abs this before returning.\n  return Math.abs(signedDistance);\n};\n\nVec.closestPointOnAABBPerimeter = (p, aabb) => {\n  // Treat the aabb center as the origin.\n  p = Vec.sub(p, aabb.center);\n  let size = Vec(aabb.width / 2, aabb.height / 2);\n  // Along each axis, get the distance between the point and the aabb perimeter.\n  let q = Vec.sub(p, size);\n\n  // It might seem like we could stop now, but the above doesn't correctly handle the case where\n  // the target point is outside the rect and closest to a corner (rather than an edge).\n  // To handle the corner, we need to get a little fancier.\n\n  // If the point is outside the aabb, this will be the distance from the point to the closest edge,\n  // or to the corner. If the point is inside, this will be zero.\n  let outside = Vec.len(Vec.max(q, Vec.zero));\n  // If the point is inside the aabb, this will be the negative(!) distance from the point to the closest edge.\n  // If the point is outside, this will be zero.\n  let inside = Math.min(Math.max(q.x, q.y), 0);\n  // Boom! We've got the signed distance between a point and an aabb.\n  let signedDistance = outside + inside;\n\n  // Since we don't care about the sign, we will just abs this before returning.\n  return Math.abs(signedDistance);\n};\n\nVec.intersectPointAABBCenter = (p, aabb) => {\n  // Treat the aabb center as the origin.\n  let pAABB = Vec.sub(p, aabb.center);\n\n  // The aabb is symmetrical on both axes, so we can simplify to just the bottom-right quadrant\n  // (where everything is positive).\n  p = Vec.abs(pAABB);\n  let size = Vec(aabb.width / 2, aabb.height / 2);\n\n  // 0-----A\n  // |     |\n  // C-----B\n  const A = Vec(size.x, 0);\n  const B = Vec(size.x, size.y);\n  const C = Vec(0, size.y);\n\n  // Find the intersections on the right side and bottom side of the aabb\n  let right = Vec.intersectLineLine(Vec.zero, p, A, B);\n  let bottom = Vec.intersectLineLine(Vec.zero, p, B, C);\n\n  // Keep whichever intersection results in a shorter line between the intersection and the aabb center.\n  let q = Vec.len(right) < Vec.len(bottom) ? right : bottom;\n\n  // If the original point isn't actually in the bottom right quadrant, flip the sign\n  if (pAABB.x != p.x) q.x *= -1;\n  if (pAABB.y != p.y) q.y *= -1;\n\n  return Vec.add(q, aabb.center);\n};\n\nVec.intersectLineLine = (A, B, C, D) => {\n  // Caution â€” I *suspect* this function assumes the lines are infinitely long.\n  let AB = Vec.sub(B, A);\n  let CA = Vec.sub(A, C);\n  let CD = Vec.sub(D, C);\n  let den = CD.y * AB.x - CD.x * AB.y;\n  if (isZero(den)) return null;\n  var s = (CD.x * CA.y - CD.y * CA.x) / den;\n  return Vec.add(A, Vec.Smul(s, AB));\n};\n\nVec.intersectRayLine = (rayP, rayD, a, b) => {\n  // rayP is the start point of a ray\n  // rayD is the direction of the ray (eg: {x:1,y:0} to point straight to the right);\n  // a and b are the endpoints of a line segment\n\n  let AB = Vec.sub(b, a);\n  let AP = Vec.sub(rayP, a);\n\n  // If the ray is parallel to the line, there'll be no intersection.\n  if (rayD.y / rayD.x == AB.y / AB.x) return;\n\n  let den = rayD.x * AB.y - rayD.y * AB.x;\n\n  // If this denominator is zero, there'll be no intersection either.\n  if (den == 0) return;\n\n  // TBH, I don't quite grock how this works geometrically yet, but it comes up all the time in intersection math.\n  let r = (AP.y * AB.x - AP.x * AB.y) / den;\n  let s = (AP.y * rayD.x - AP.x * rayD.y) / den;\n\n  // If the intersection would be outside the line segment, no intersection.\n  if (r <= 0 || s <= 0 || s >= 1) return;\n\n  // Scale rayD so it's as long as the distance rayP is from the intersection point.\n  let scaledD = Vec.mulS(rayD, r);\n\n  // Add rayP to rayD, and you have the intersection! Yay.\n  return Vec.add(rayP, scaledD);\n};\n\nVec.isInside = (p, min, max) => {\n  return min.x <= p.x && p.x <= max.x && min.y <= p.y && p.y <= max.y;\n};\n\nVec.isFinite = (p) => {\n  return isFinite(p.x) && isFinite(p.y);\n};\n", "let eventQueue = {\n    pencil: [], // only one pencil - so a list of events\n    touches: {}, // map by touch id to a list of events\n};\n\nwindow.nativeEvent = (eventState, touches) => {\n    Object.entries(touches).forEach(([touchId, points]) => {\n        points.forEach((point) => {\n            if (point.type === \"pencil\") {\n                eventQueue.pencil.push({\n                    // there's more data in `point` that we're ignoring here\n                    type: eventState,\n                    x: point.x,\n                    y: point.y,\n                });\n            } else {\n                if (!eventQueue.touches[touchId]) {\n                    eventQueue.touches[touchId] = [];\n                }\n\n                eventQueue.touches[touchId].push({\n                    type: eventState,\n                    x: point.x,\n                    y: point.y,\n                });\n            }\n        });\n    });\n};\n\n\nlet callback = null\nfunction frame(){\n    callback(eventQueue)\n\n    eventQueue.pencil = []\n    eventQueue.touches = {}\n\n    window.requestAnimationFrame(frame);\n}\n\nexport default (cb) => {\n    callback = cb\n    window.requestAnimationFrame(frame);\n}", "class Canvas {\n    constructor(dom, cb){\n        // SETUP CANVAS\n        this.canvas = document.createElement(\"canvas\")\n        dom.appendChild(this.canvas)\n        const dpr = window.devicePixelRatio\n        let bounds = dom.getBoundingClientRect()\n        this.canvas.width = bounds.width * dpr\n        this.canvas.height = bounds.height * dpr\n        this.ctx = this.canvas.getContext(\"2d\")\n        this.ctx.scale(dpr, dpr)\n\n        // this.canvas.addEventListener(\"touchstart\", e=>e.preventDefault(), false)\n\n        this.callback = cb\n        cb(this.ctx)\n    }\n\n    render(){\n        this.callback(this.ctx)\n    }\n\n}\n\nexport default Canvas", "import Vec from \"./lib/vec.js\"\n\nclass Draw {\n    constructor(){\n        this.pencil_down = false\n        this.strokes = []\n        this.wet_strokes = []\n        this.drawing_stroke = null\n    }\n\n    begin_stroke(pos){\n        let stroke = {\n            input_points: [Vec.clone(pos)],\n            display_points: [Vec.clone(pos)],\n            fitted_curve: null,\n            velocity: new SmoothArray(0)\n        }\n        this.drawing_stroke = stroke\n        this.wet_strokes.push(stroke)\n        this.strokes.push(stroke)\n    }\n\n    update_stroke(pos) {\n        let prev_pos = this.drawing_stroke.input_points[this.drawing_stroke.input_points.length-1]\n        let v = Vec.dist(prev_pos, pos)\n        this.drawing_stroke.velocity.push(v)\n        this.drawing_stroke.input_points.push(pos)\n        this.drawing_stroke.display_points.push(Vec.clone(pos))\n\n        // Fit curve\n        this.drawing_stroke.fitted_curve = fit_stroke(this.drawing_stroke.input_points)\n\n        // ARC\n        if(this.drawing_stroke.input_points.length > 3) {\n            this.drawing_stroke.arc = fit_circle(this.drawing_stroke.input_points)\n        }\n\n\n        // Handle Velocity\n        let start = this.drawing_stroke.input_points[0]\n        let total_dist = Vec.dist(start, pos)\n        if(total_dist > 10 && v < 0.075) {\n            this.drawing_stroke.done = true\n            this.drawing_stroke = null\n            \n            // New stroke\n            this.begin_stroke(pos)\n        }\n    }\n    \n    update(events){\n        // Handle input\n        events.pencil.forEach(event=>{\n            let pos = Vec(event.x, event.y)\n            if(event.type == \"began\") {\n                this.begin_stroke(pos)\n            }\n            if(event.type == \"moved\") {\n                if(this.drawing_stroke) {\n                    this.update_stroke(pos)\n                }\n            }\n            if(event.type == \"ended\") {\n                if(this.drawing_stroke) {\n                    this.drawing_stroke.done = true\n                    this.drawing_stroke = null\n                }\n            }\n        })\n\n        // Update Wet strokes\n        for(let j = 0; j < this.wet_strokes.length; j++) {\n            const stroke = this.wet_strokes[j]\n            if(stroke.fitted_curve) {\n\n                if(stroke.fitted_curve.type == \"line\") {\n                    const line = stroke.fitted_curve.line\n\n                    for (let i = 1; i < stroke.display_points.length-1; i++) {\n                        let pt = stroke.display_points[i]\n                        let npt = Vec.scalarProjection(pt, line.a, line.b)\n                        let diff = Vec.sub(npt, pt)\n                        let dpt = Vec.add(pt, Vec.mulS(diff, 0.1))\n                        pt.x = dpt.x\n                        pt.y = dpt.y\n                    }\n    \n                    if(stroke.done){\n                        let fitness = fit_line(stroke.display_points).fitness\n                        if(fitness < 0.1) {\n                            stroke.display_points = [line.a, line.b]\n                            this.wet_strokes.splice(j, 1)\n                        }\n                    }\n                } else if(stroke.fitted_curve.type == \"circle\") { \n                    for (let i = 1; i < stroke.display_points.length-1; i++) {\n                        let pt = stroke.display_points[i]\n                        let npt = closest_point_on_circle(pt, stroke.fitted_curve)\n                        let diff = Vec.sub(npt, pt)\n                        let dpt = Vec.add(pt, Vec.mulS(diff, 0.1))\n                        pt.x = dpt.x\n                        pt.y = dpt.y\n                    }\n                }\n                \n            }\n        }\n    }\n\n    render(ctx) {\n        // STROKES\n        for(const stroke of this.strokes) {\n            ctx.strokeStyle = \"#000000\";\n            \n            // STROKE\n            let points = stroke.display_points\n            ctx.beginPath()\n            ctx.moveTo(points[0].x, points[0].y)\n            for (let i = 1; i < points.length; i++) {\n                ctx.lineTo(points[i].x, points[i].y)    \n            }\n            ctx.stroke()\n\n            // ctx.strokeStyle = \"#00000044\"\n            // if(stroke.input_points) {\n            //     let points = stroke.input_points\n            //     ctx.beginPath()\n            //     ctx.moveTo(points[0].x, points[0].y)\n            //     for (let i = 1; i < points.length; i++) {\n            //         ctx.lineTo(points[i].x, points[i].y)    \n            //     }\n            //     ctx.stroke()\n            // }\n\n            // if(stroke.simplified) {\n            //     let points = stroke.simplified\n            //     ctx.beginPath()\n            //     ctx.moveTo(points[0].x, points[0].y)\n            //     for (let i = 1; i < points.length; i++) {\n            //         ctx.lineTo(points[i].x, points[i].y)    \n            //     }\n            //     ctx.stroke()\n            // }\n\n            // if(stroke.arc) {\n            //     let circle = stroke.arc\n            //     ctx.beginPath()\n            //     //ctx.ellipse(circle.center.x, circle.center.y, circle.radius, circle.radius, 0, 0, Math.PI*2);\n            //     ctx.ellipse(circle.center.x, circle.center.y, circle.radius, circle.radius, 0, circle.startAngle, circle.endAngle);\n            //     ctx.stroke()\n            // }\n        }\n\n        ctx.strokeStyle = \"#00000022\";\n        \n        // VELOCITY PLOT\n        let recent_stroke = this.wet_strokes[this.wet_strokes.length-1]\n        if(recent_stroke) {\n            let velocity = recent_stroke.velocity.data\n            ctx.beginPath()\n            ctx.moveTo(50, velocity[0]*50+50)\n            for (let i = 1; i < velocity.length; i++) {\n                ctx.lineTo(50+i*2, velocity[i]*50+50) \n            }\n            ctx.stroke()\n        }\n\n        ctx.beginPath()\n        ctx.moveTo(50, 0.75*50+50)\n        ctx.lineTo(50+400, 0.75*50+50) \n        ctx.stroke()\n\n    }\n}\n\nexport default Draw\n\nclass SmoothArray {\n    constructor(value, alpha = 0.05){\n        this.data = [value];\n        this.filtered = value;\n        this.alpha = alpha\n    }\n\n    push(value) {\n        this.filtered = this.alpha * value + (1 - this.alpha) * this.filtered\n        this.data.push(this.filtered)\n    }\n}\n\n// SIMPLIFY\nfunction simplify_triangle(line){\n    let start = line[0]\n    let end = line[line.length-1]\n\n    var largestDistance = -1;\n    var furthestIndex = -1;\n    \n    for (let i = 0; i < line.length; i++) {\n      let point = line[i]\n      let dist = point_line_distance(point, start, end)\n      if(dist > largestDistance) {\n        largestDistance = dist\n        furthestIndex = i\n      }\n    }\n\n    return [start, line[furthestIndex], end]\n}\n\nfunction point_line_distance(p, a, b) {\n    let norm = Vec.scalarProjection(p, a, b)\n    return Vec.len(Vec.sub(p,norm))\n}\n\n\n// FIT CURVE\nfunction fit_stroke(points){\n    // Fit straight line\n    let line_fit = fit_line(points)\n    let arc_fit = fit_circle(points)\n\n    if(line_fit.fitness < 7) {\n        return line_fit\n    } else {\n        return arc_fit\n    }\n    \n}\n\n\n\nfunction fit_line(stroke){\n    let total_dist = 0\n    let line = {a: stroke[0], b: stroke[stroke.length-1]}\n    \n    for (let i = 1; i < stroke.length-1; i++) {\n        let pt = stroke[i]\n        let npt = Vec.scalarProjection(pt, line.a, line.b)\n        let dist = Vec.dist(npt, pt)\n        total_dist += dist\n    }\n\n    let line_dist = Vec.dist(line.a, line.b)\n\n    let fitness = total_dist / line_dist\n    return {\n        type: \"line\",\n        fitness,\n        line\n    }\n}\n\nfunction fit_circle(points) {\n    if(points.length < 3) return null\n    let simplified = simplify_triangle(points);\n    let [a, b, c] = simplified\n\n    if(!b) return null\n\n    let x1 = a.x;\n    let y1 = a.y;\n    let x2 = b.x;\n    let y2 = b.y;\n    let x3 = c.x;\n    let y3 = c.y;\n\n    const D = 2 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));\n    const centerX = ((x1 * x1 + y1 * y1) * (y2 - y3) + (x2 * x2 + y2 * y2) * (y3 - y1) + (x3 * x3 + y3 * y3) * (y1 - y2)) / D;\n    const centerY = ((x1 * x1 + y1 * y1) * (x3 - x2) + (x2 * x2 + y2 * y2) * (x1 - x3) + (x3 * x3 + y3 * y3) * (x2 - x1)) / D;\n    const radius = Math.sqrt((x1 - centerX) * (x1 - centerX) + (y1 - centerY) * (y1 - centerY));\n    \n    const startAngle = Math.atan2(y1 - centerY, x1 - centerX);\n    const endAngle = Math.atan2(y3 - centerY, x3 - centerX);\n\n    let circle = {\n        type: \"circle\",\n        center: { x: centerX, y: centerY },\n        radius: radius,\n        startAngle: startAngle,\n        endAngle: endAngle\n    };\n\n    // Compute fitness\n    let arc_dist = arc_length(radius, startAngle, endAngle)\n\n    let total_dist = 0\n    points.forEach(point=>{\n        total_dist += point_circle_distance(point, circle)\n    })\n\n    circle.fitness = total_dist / arc_dist\n\n    return circle\n}\n\nfunction arc_length(radius, startAngle, endAngle) {\n    // Convert angles from degrees to radians\n    const startAngleRad = (startAngle * Math.PI) / 180;\n    const endAngleRad = (endAngle * Math.PI) / 180;\n    \n    // Calculate the arc length using the formula: arc length = radius * angle\n    const length = radius * Math.abs(endAngleRad - startAngleRad);\n    \n    // Return the arc length\n    return length;\n  }\n\n\nfunction point_circle_distance(point, circle) {\n    let {x, y} = point\n    let circleX = circle.center.x\n    let circleY = circle.center.y\n    let radius = circle.radius\n\n    // Calculate the distance between the point and the center of the circle\n    const distance = Math.sqrt((x - circleX) ** 2 + (y - circleY) ** 2);\n    \n    // Subtract the radius from the distance to get the shortest distance from the point to the circle's circumference\n    const shortestDistance = distance - radius;\n    \n    // Return the absolute value of the shortest distance (to make sure it's positive)\n    return Math.abs(shortestDistance);\n}\n\nfunction closest_point_on_circle(point, circle) {\n    let {x, y} = point\n    let circleX = circle.center.x\n    let circleY = circle.center.y\n    let radius = circle.radius\n\n    // Calculate the angle between the point and the center of the circle\n    const angle = Math.atan2(y - circleY, x - circleX);\n    \n    // Calculate the closest point on the circle using trigonometry\n    const closestX = circleX + radius * Math.cos(angle);\n    const closestY = circleY + radius * Math.sin(angle);\n    \n    // Return the coordinates of the closest point\n    return { x: closestX, y: closestY };\n  }\n\n// Snapping\nfunction generate_snaps(stroke){\n\n}\n\n", "import Vec from \"./lib/vec.js\";\nimport engine from \"./engine.js\";\nimport Canvas from \"./canvas.js\";\n\nimport Draw from \"./draw.js\"\n\nlet draw = new Draw()\n\nlet canvas = new Canvas(document.body, ctx=>{\n    ctx.clearRect(0,0, window.innerWidth, window.innerHeight);\n    draw.render(ctx)\n\n    // for(const stroke of state.strokes) {\n    //     ctx.strokeStyle = \"#000000\";\n    //     let points = stroke.detailed\n    //     ctx.beginPath()\n    //     ctx.moveTo(points[0].x, points[0].y)\n    //     for (let i = 1; i < points.length; i++) {\n    //         ctx.lineTo(points[i].x, points[i].y)    \n    //     }\n    //     ctx.stroke()\n\n\n    //     let fit = stroke.fit\n    //     if(fit) {\n    //         // if(fit.type == \"line\") {\n    //         //     ctx.beginPath()\n    //         //     ctx.moveTo(fit.line.a.x, fit.line.a.y)\n    //         //     ctx.lineTo(fit.line.b.x, fit.line.b.y)\n    //         //     ctx.stroke()\n    //         // }\n    //     }\n    //     // //console.log(circle);\n    //     // if(circle != null) {\n    //     //     \n    //     //     ctx.beginPath()\n    //     //     ctx.ellipse(circle.center.x, circle.center.y, circle.radius, circle.radius, 0, 0, Math.PI*2)\n    //     //     ctx.stroke()\n    //     // }\n        \n    // }\n    \n    // // for(const circle of state.circles) { \n    // //     ctx.beginPath()\n    // //     ctx.ellipse(circle.center.x, circle.center.y, circle.radius, circle.radius, 0, 0, Math.PI*2)\n    // //     ctx.stroke()\n    // // }\n})\n\nengine((events)=>{\n  draw.update(events)\n  canvas.render()\n    // state.did_move++\n    // events.pencil.forEach(event=>{\n    //     if(event.type == \"began\") {\n    //         state.did_move = 0\n    //         let pos = Vec(event.x, event.y)\n    //         state.drawing = true\n    //         state.strokes.push({\n    //             detailed: [pos],\n    //             fit: null\n    //         })\n    //     }\n    //     if(event.type == \"moved\") {\n    //         let stroke = state.strokes[state.strokes.length-1]\n    //         let last_point = stroke.detailed[stroke.detailed.length-1]\n    //         let pos = Vec(event.x, event.y)\n    //         if(Vec.dist(last_point, pos) > 1) {\n    //             stroke.detailed.push(pos)\n    //             //stroke.fit = fitArcToPoints(stroke.detailed)\n                \n    //         }\n\n    //         if(Vec.dist(last_point, pos) > 2) {\n    //             state.did_move = 0\n    //         }\n            \n            \n    //     }\n    //     if(event.type == \"ended\") {\n    //         state.drawing = false\n    //         let stroke = state.strokes[state.strokes.length-1]\n    //         //state.circles.push(fitArcToPoints(stroke))\n    //         //\n    //     }\n    // })\n\n    // if(state.drawing && state.did_move>10) {\n        \n    //     let stroke = state.strokes[state.strokes.length-1]\n    //     //stroke.fit = fitArcToPoints(stroke.detailed)\n    //     let line_fit = computeStraightness(stroke.detailed)\n    //     if(line_fit && line_fit.fitness < 2) {\n    //         stroke.fit = line_fit\n    //         state.strokes.push({\n    //             detailed: [Vec.clone(stroke.detailed[stroke.detailed.length-1])],\n    //             fit: null\n    //         })\n    //         state.did_move = 0\n    //     }\n        \n    // }\n\n    // let stroke = state.strokes[state.strokes.length-1]\n    // if(stroke && stroke.fit) {\n    //     let line = stroke.fit.line\n        \n    //     for (let i = 1; i < stroke.detailed.length-1; i++) {\n    //         let pt = stroke.detailed[i]\n    //         let npt = Vec.scalarProjection(pt, line.a, line.b)\n\n    //         let diff = Vec.mulS(Vec.sub(npt, pt), 0.2)\n    //         let dpt = Vec.add(pt, diff)\n    //         pt.x = dpt.x\n    //         pt.y = dpt.y\n    //         //ctx.lineTo(stroke[i].x, stroke[i].y)    \n    //     }\n    // }\n\n    // \n})\n\n// Define a helper function to calculate the distance between two points\nfunction calculateDistance(point1, point2) {\n    const dx = point2.x - point1.x;\n    const dy = point2.y - point1.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n  \n  // Define a helper function to calculate the distance between a point and an arc\n  function calculateDistanceToArc(point, center, radius, startAngle, endAngle) {\n    const dx = point.x - center.x;\n    const dy = point.y - center.y;\n    const angle = Math.atan2(dy, dx);\n    const distance = Math.abs(radius - Math.sqrt(dx * dx + dy * dy));\n    const angleDiff = endAngle - startAngle;\n    const normalizedAngleDiff = ((angleDiff % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);\n    const normalizedAngle = ((angle - startAngle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);\n    if (normalizedAngleDiff < Math.PI && (normalizedAngle < 0 || normalizedAngle > normalizedAngleDiff)) {\n      return Number.POSITIVE_INFINITY;\n    }\n    return distance;\n  }\n  \n  // RANSAC-based arc fitting algorithm\n  function fitArcToPoints(points, iterations = 1000, threshold = 0.1) {\n    const numPoints = points.length;\n    if (numPoints < 3) {\n      //throw new Error('At least three points are required to fit an arc.');\n      return null\n    }\n  \n    let bestCenter = null;\n    let bestRadius = null;\n    let bestStartAngle = null;\n    let bestEndAngle = null;\n    let bestInliers = [];\n  \n    for (let i = 0; i < iterations; i++) {\n      // Randomly select three points to form an arc\n      const sampleIndices = new Set();\n      while (sampleIndices.size < 3) {\n        sampleIndices.add(Math.floor(Math.random() * numPoints));\n      }\n      const sample = Array.from(sampleIndices).map(index => points[index]);\n  \n      // Calculate the circle parameters using the selected sample\n      const pointA = sample[0];\n      const pointB = sample[1];\n      const pointC = sample[2];\n  \n      const dA = calculateDistance(pointB, pointC);\n      const dB = calculateDistance(pointA, pointC);\n      const dC = calculateDistance(pointA, pointB);\n  \n      const cosAngle = (dB * dB + dC * dC - dA * dA) / (2 * dB * dC);\n      const angle = Math.acos(cosAngle);\n      const radius = dA / (2 * Math.sin(angle));\n  \n      const midPointAB = {\n        x: (pointA.x + pointB.x) / 2,\n        y: (pointA.y + pointB.y) / 2\n      };\n      const midPointBC = {\n        x: (pointB.x + pointC.x) / 2,\n        y: (pointB.y + pointC.y) / 2\n      };\n  \n      const slopeAB = (pointB.y - pointA.y) / (pointB.x - pointA.x);\n      const slopeBC = (pointC.y - pointB.y) / (pointC.x - pointB.x);\n  \n      const slopePerpendicularAB = -1 / slopeAB;\n      const slopePerpendicularBC = -1 / slopeBC;\n  \n      const center = {\n        x: (slopePerpendicularAB * midPointAB.x - slopePerpendicularBC * midPointBC.x +\n          midPointBC.y - midPointAB.y) /\n          (slopePerpendicularAB - slopePerpendicularBC),\n        y: slopePerpendicularAB * ((\n          slopePerpendicularAB * midPointAB.x - slopePerpendicularBC * midPointBC.x +\n          midPointBC.y - midPointAB.y) /\n          (slopePerpendicularAB - slopePerpendicularBC)) - midPointAB.x + midPointAB.y\n      };\n  \n      const startAngle = Math.atan2(pointA.y - center.y, pointA.x - center.x);\n      const endAngle = Math.atan2(pointC.y - center.y, pointC.x - center.x);\n  \n      // Count inliers\n      const inliers = [];\n      for (let j = 0; j < numPoints; j++) {\n        const point = points[j];\n        const distance = calculateDistanceToArc(point, center, radius, startAngle, endAngle);\n        if (distance <= threshold) {\n          inliers.push(point);\n        }\n      }\n  \n      // Update the best model if the current model has more inliers\n      if (inliers.length > bestInliers.length) {\n        bestCenter = center;\n        bestRadius = radius;\n        bestStartAngle = startAngle;\n        bestEndAngle = endAngle;\n        bestInliers = inliers;\n      }\n    }\n\n    if(!bestCenter) {\n        return null\n    }\n  \n    return {\n      center: bestCenter,\n      radius: bestRadius,\n      startAngle: bestStartAngle,\n      endAngle: bestEndAngle,\n      inliers: bestInliers\n    };\n}\n\nfunction computeStraightness(stroke){\n    let total_dist = 0\n    let line = {a: stroke[0], b: stroke[stroke.length-1]}\n    \n    for (let i = 1; i < stroke.length-1; i++) {\n        let pt = stroke[i]\n        let npt = Vec.scalarProjection(pt, line.a, line.b)\n        let dist = Vec.dist(npt, pt)\n        total_dist += dist\n    }\n\n    let line_dist = Vec.dist(line.a, line.b)\n\n    let fitness = total_dist / line_dist\n    if(fitness < 2.5) {\n        return {\n            type: \"line\",\n            fitness,\n            line\n        }\n    }\n}"],
  "mappings": "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",
  "names": []
}
